// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/commands.proto

#ifndef PROTOBUF_INCLUDED_protocol_2fcommands_2eproto
#define PROTOBUF_INCLUDED_protocol_2fcommands_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "protocol/candidates.pb.h"
#include "protocol/config.pb.h"
#include "protocol/engine_builder.pb.h"
#include "protocol/user_dictionary_storage.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2fcommands_2eproto 

namespace protobuf_protocol_2fcommands_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2fcommands_2eproto
namespace mozc {
namespace commands {
class ApplicationInfo;
class ApplicationInfoDefaultTypeInternal;
extern ApplicationInfoDefaultTypeInternal _ApplicationInfo_default_instance_;
class Capability;
class CapabilityDefaultTypeInternal;
extern CapabilityDefaultTypeInternal _Capability_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CommandList;
class CommandListDefaultTypeInternal;
extern CommandListDefaultTypeInternal _CommandList_default_instance_;
class Context;
class ContextDefaultTypeInternal;
extern ContextDefaultTypeInternal _Context_default_instance_;
class DeletionRange;
class DeletionRangeDefaultTypeInternal;
extern DeletionRangeDefaultTypeInternal _DeletionRange_default_instance_;
class GenericStorageEntry;
class GenericStorageEntryDefaultTypeInternal;
extern GenericStorageEntryDefaultTypeInternal _GenericStorageEntry_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class Input_TouchEvent;
class Input_TouchEventDefaultTypeInternal;
extern Input_TouchEventDefaultTypeInternal _Input_TouchEvent_default_instance_;
class Input_TouchPosition;
class Input_TouchPositionDefaultTypeInternal;
extern Input_TouchPositionDefaultTypeInternal _Input_TouchPosition_default_instance_;
class KeyEvent;
class KeyEventDefaultTypeInternal;
extern KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
class KeyEvent_ProbableKeyEvent;
class KeyEvent_ProbableKeyEventDefaultTypeInternal;
extern KeyEvent_ProbableKeyEventDefaultTypeInternal _KeyEvent_ProbableKeyEvent_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Output_Callback;
class Output_CallbackDefaultTypeInternal;
extern Output_CallbackDefaultTypeInternal _Output_Callback_default_instance_;
class Preedit;
class PreeditDefaultTypeInternal;
extern PreeditDefaultTypeInternal _Preedit_default_instance_;
class Preedit_Segment;
class Preedit_SegmentDefaultTypeInternal;
extern Preedit_SegmentDefaultTypeInternal _Preedit_Segment_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class SessionCommand;
class SessionCommandDefaultTypeInternal;
extern SessionCommandDefaultTypeInternal _SessionCommand_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace commands
}  // namespace mozc
namespace google {
namespace protobuf {
template<> ::mozc::commands::ApplicationInfo* Arena::CreateMaybeMessage<::mozc::commands::ApplicationInfo>(Arena*);
template<> ::mozc::commands::Capability* Arena::CreateMaybeMessage<::mozc::commands::Capability>(Arena*);
template<> ::mozc::commands::Command* Arena::CreateMaybeMessage<::mozc::commands::Command>(Arena*);
template<> ::mozc::commands::CommandList* Arena::CreateMaybeMessage<::mozc::commands::CommandList>(Arena*);
template<> ::mozc::commands::Context* Arena::CreateMaybeMessage<::mozc::commands::Context>(Arena*);
template<> ::mozc::commands::DeletionRange* Arena::CreateMaybeMessage<::mozc::commands::DeletionRange>(Arena*);
template<> ::mozc::commands::GenericStorageEntry* Arena::CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(Arena*);
template<> ::mozc::commands::Input* Arena::CreateMaybeMessage<::mozc::commands::Input>(Arena*);
template<> ::mozc::commands::Input_TouchEvent* Arena::CreateMaybeMessage<::mozc::commands::Input_TouchEvent>(Arena*);
template<> ::mozc::commands::Input_TouchPosition* Arena::CreateMaybeMessage<::mozc::commands::Input_TouchPosition>(Arena*);
template<> ::mozc::commands::KeyEvent* Arena::CreateMaybeMessage<::mozc::commands::KeyEvent>(Arena*);
template<> ::mozc::commands::KeyEvent_ProbableKeyEvent* Arena::CreateMaybeMessage<::mozc::commands::KeyEvent_ProbableKeyEvent>(Arena*);
template<> ::mozc::commands::Output* Arena::CreateMaybeMessage<::mozc::commands::Output>(Arena*);
template<> ::mozc::commands::Output_Callback* Arena::CreateMaybeMessage<::mozc::commands::Output_Callback>(Arena*);
template<> ::mozc::commands::Preedit* Arena::CreateMaybeMessage<::mozc::commands::Preedit>(Arena*);
template<> ::mozc::commands::Preedit_Segment* Arena::CreateMaybeMessage<::mozc::commands::Preedit_Segment>(Arena*);
template<> ::mozc::commands::Request* Arena::CreateMaybeMessage<::mozc::commands::Request>(Arena*);
template<> ::mozc::commands::Result* Arena::CreateMaybeMessage<::mozc::commands::Result>(Arena*);
template<> ::mozc::commands::SessionCommand* Arena::CreateMaybeMessage<::mozc::commands::SessionCommand>(Arena*);
template<> ::mozc::commands::Status* Arena::CreateMaybeMessage<::mozc::commands::Status>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mozc {
namespace commands {

enum KeyEvent_SpecialKey {
  KeyEvent_SpecialKey_NO_SPECIALKEY = 0,
  KeyEvent_SpecialKey_DIGIT = 1,
  KeyEvent_SpecialKey_ON = 2,
  KeyEvent_SpecialKey_OFF = 3,
  KeyEvent_SpecialKey_SPACE = 4,
  KeyEvent_SpecialKey_ENTER = 5,
  KeyEvent_SpecialKey_LEFT = 6,
  KeyEvent_SpecialKey_RIGHT = 7,
  KeyEvent_SpecialKey_UP = 8,
  KeyEvent_SpecialKey_DOWN = 9,
  KeyEvent_SpecialKey_ESCAPE = 10,
  KeyEvent_SpecialKey_DEL = 11,
  KeyEvent_SpecialKey_BACKSPACE = 12,
  KeyEvent_SpecialKey_HENKAN = 13,
  KeyEvent_SpecialKey_MUHENKAN = 14,
  KeyEvent_SpecialKey_KANA = 15,
  KeyEvent_SpecialKey_HOME = 16,
  KeyEvent_SpecialKey_END = 17,
  KeyEvent_SpecialKey_TAB = 18,
  KeyEvent_SpecialKey_F1 = 19,
  KeyEvent_SpecialKey_F2 = 20,
  KeyEvent_SpecialKey_F3 = 21,
  KeyEvent_SpecialKey_F4 = 22,
  KeyEvent_SpecialKey_F5 = 23,
  KeyEvent_SpecialKey_F6 = 24,
  KeyEvent_SpecialKey_F7 = 25,
  KeyEvent_SpecialKey_F8 = 26,
  KeyEvent_SpecialKey_F9 = 27,
  KeyEvent_SpecialKey_F10 = 28,
  KeyEvent_SpecialKey_F11 = 29,
  KeyEvent_SpecialKey_F12 = 30,
  KeyEvent_SpecialKey_PAGE_UP = 31,
  KeyEvent_SpecialKey_PAGE_DOWN = 32,
  KeyEvent_SpecialKey_INSERT = 33,
  KeyEvent_SpecialKey_F13 = 34,
  KeyEvent_SpecialKey_F14 = 35,
  KeyEvent_SpecialKey_F15 = 36,
  KeyEvent_SpecialKey_F16 = 37,
  KeyEvent_SpecialKey_F17 = 38,
  KeyEvent_SpecialKey_F18 = 39,
  KeyEvent_SpecialKey_F19 = 40,
  KeyEvent_SpecialKey_F20 = 41,
  KeyEvent_SpecialKey_F21 = 42,
  KeyEvent_SpecialKey_F22 = 43,
  KeyEvent_SpecialKey_F23 = 44,
  KeyEvent_SpecialKey_F24 = 45,
  KeyEvent_SpecialKey_EISU = 46,
  KeyEvent_SpecialKey_NUMPAD0 = 47,
  KeyEvent_SpecialKey_NUMPAD1 = 48,
  KeyEvent_SpecialKey_NUMPAD2 = 49,
  KeyEvent_SpecialKey_NUMPAD3 = 50,
  KeyEvent_SpecialKey_NUMPAD4 = 51,
  KeyEvent_SpecialKey_NUMPAD5 = 52,
  KeyEvent_SpecialKey_NUMPAD6 = 53,
  KeyEvent_SpecialKey_NUMPAD7 = 54,
  KeyEvent_SpecialKey_NUMPAD8 = 55,
  KeyEvent_SpecialKey_NUMPAD9 = 56,
  KeyEvent_SpecialKey_MULTIPLY = 57,
  KeyEvent_SpecialKey_ADD = 58,
  KeyEvent_SpecialKey_SEPARATOR = 59,
  KeyEvent_SpecialKey_SUBTRACT = 60,
  KeyEvent_SpecialKey_DECIMAL = 61,
  KeyEvent_SpecialKey_DIVIDE = 62,
  KeyEvent_SpecialKey_EQUALS = 63,
  KeyEvent_SpecialKey_TEXT_INPUT = 64,
  KeyEvent_SpecialKey_HANKAKU = 65,
  KeyEvent_SpecialKey_KANJI = 66,
  KeyEvent_SpecialKey_KATAKANA = 67,
  KeyEvent_SpecialKey_CAPS_LOCK = 68,
  KeyEvent_SpecialKey_UNDEFINED_KEY = 69,
  KeyEvent_SpecialKey_COMMA = 70,
  KeyEvent_SpecialKey_CLEAR = 71,
  KeyEvent_SpecialKey_VIRTUAL_LEFT = 72,
  KeyEvent_SpecialKey_VIRTUAL_RIGHT = 73,
  KeyEvent_SpecialKey_VIRTUAL_ENTER = 74,
  KeyEvent_SpecialKey_VIRTUAL_UP = 75,
  KeyEvent_SpecialKey_VIRTUAL_DOWN = 76,
  KeyEvent_SpecialKey_NUM_SPECIALKEYS = 77
};
bool KeyEvent_SpecialKey_IsValid(int value);
const KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MIN = KeyEvent_SpecialKey_NO_SPECIALKEY;
const KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MAX = KeyEvent_SpecialKey_NUM_SPECIALKEYS;
const int KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE = KeyEvent_SpecialKey_SpecialKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_SpecialKey_descriptor();
inline const ::std::string& KeyEvent_SpecialKey_Name(KeyEvent_SpecialKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_SpecialKey_descriptor(), value);
}
inline bool KeyEvent_SpecialKey_Parse(
    const ::std::string& name, KeyEvent_SpecialKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_SpecialKey>(
    KeyEvent_SpecialKey_descriptor(), name, value);
}
enum KeyEvent_ModifierKey {
  KeyEvent_ModifierKey_CTRL = 1,
  KeyEvent_ModifierKey_ALT = 2,
  KeyEvent_ModifierKey_SHIFT = 4,
  KeyEvent_ModifierKey_KEY_DOWN = 8,
  KeyEvent_ModifierKey_KEY_UP = 16,
  KeyEvent_ModifierKey_LEFT_CTRL = 32,
  KeyEvent_ModifierKey_LEFT_ALT = 64,
  KeyEvent_ModifierKey_LEFT_SHIFT = 128,
  KeyEvent_ModifierKey_RIGHT_CTRL = 256,
  KeyEvent_ModifierKey_RIGHT_ALT = 512,
  KeyEvent_ModifierKey_RIGHT_SHIFT = 1024,
  KeyEvent_ModifierKey_CAPS = 2048
};
bool KeyEvent_ModifierKey_IsValid(int value);
const KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MIN = KeyEvent_ModifierKey_CTRL;
const KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MAX = KeyEvent_ModifierKey_CAPS;
const int KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE = KeyEvent_ModifierKey_ModifierKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_ModifierKey_descriptor();
inline const ::std::string& KeyEvent_ModifierKey_Name(KeyEvent_ModifierKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_ModifierKey_descriptor(), value);
}
inline bool KeyEvent_ModifierKey_Parse(
    const ::std::string& name, KeyEvent_ModifierKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_ModifierKey>(
    KeyEvent_ModifierKey_descriptor(), name, value);
}
enum KeyEvent_InputStyle {
  KeyEvent_InputStyle_FOLLOW_MODE = 0,
  KeyEvent_InputStyle_AS_IS = 1,
  KeyEvent_InputStyle_DIRECT_INPUT = 2
};
bool KeyEvent_InputStyle_IsValid(int value);
const KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MIN = KeyEvent_InputStyle_FOLLOW_MODE;
const KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MAX = KeyEvent_InputStyle_DIRECT_INPUT;
const int KeyEvent_InputStyle_InputStyle_ARRAYSIZE = KeyEvent_InputStyle_InputStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_InputStyle_descriptor();
inline const ::std::string& KeyEvent_InputStyle_Name(KeyEvent_InputStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_InputStyle_descriptor(), value);
}
inline bool KeyEvent_InputStyle_Parse(
    const ::std::string& name, KeyEvent_InputStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_InputStyle>(
    KeyEvent_InputStyle_descriptor(), name, value);
}
enum GenericStorageEntry_StorageType {
  GenericStorageEntry_StorageType_SYMBOL_HISTORY = 0,
  GenericStorageEntry_StorageType_EMOTICON_HISTORY = 1,
  GenericStorageEntry_StorageType_EMOJI_HISTORY = 2
};
bool GenericStorageEntry_StorageType_IsValid(int value);
const GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MIN = GenericStorageEntry_StorageType_SYMBOL_HISTORY;
const GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MAX = GenericStorageEntry_StorageType_EMOJI_HISTORY;
const int GenericStorageEntry_StorageType_StorageType_ARRAYSIZE = GenericStorageEntry_StorageType_StorageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GenericStorageEntry_StorageType_descriptor();
inline const ::std::string& GenericStorageEntry_StorageType_Name(GenericStorageEntry_StorageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GenericStorageEntry_StorageType_descriptor(), value);
}
inline bool GenericStorageEntry_StorageType_Parse(
    const ::std::string& name, GenericStorageEntry_StorageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenericStorageEntry_StorageType>(
    GenericStorageEntry_StorageType_descriptor(), name, value);
}
enum SessionCommand_CommandType {
  SessionCommand_CommandType_REVERT = 1,
  SessionCommand_CommandType_SUBMIT = 2,
  SessionCommand_CommandType_SELECT_CANDIDATE = 3,
  SessionCommand_CommandType_HIGHLIGHT_CANDIDATE = 4,
  SessionCommand_CommandType_SWITCH_INPUT_MODE = 5,
  SessionCommand_CommandType_GET_STATUS = 6,
  SessionCommand_CommandType_SUBMIT_CANDIDATE = 7,
  SessionCommand_CommandType_CONVERT_REVERSE = 8,
  SessionCommand_CommandType_UNDO = 9,
  SessionCommand_CommandType_RESET_CONTEXT = 10,
  SessionCommand_CommandType_MOVE_CURSOR = 11,
  SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE = 12,
  SessionCommand_CommandType_USAGE_STATS_EVENT = 13,
  SessionCommand_CommandType_UNDO_OR_REWIND = 14,
  SessionCommand_CommandType_EXPAND_SUGGESTION = 15,
  SessionCommand_CommandType_OBSOLETE_SEND_CARET_LOCATION = 16,
  SessionCommand_CommandType_OBSOLETE_SEND_LANGUAGE_BAR_COMMAND = 17,
  SessionCommand_CommandType_OBSOLETE_GET_ASYNC_RESULT = 18,
  SessionCommand_CommandType_COMMIT_RAW_TEXT = 19,
  SessionCommand_CommandType_CONVERT_PREV_PAGE = 20,
  SessionCommand_CommandType_CONVERT_NEXT_PAGE = 21,
  SessionCommand_CommandType_TURN_ON_IME = 22,
  SessionCommand_CommandType_TURN_OFF_IME = 23,
  SessionCommand_CommandType_NUM_OF_COMMANDS = 24
};
bool SessionCommand_CommandType_IsValid(int value);
const SessionCommand_CommandType SessionCommand_CommandType_CommandType_MIN = SessionCommand_CommandType_REVERT;
const SessionCommand_CommandType SessionCommand_CommandType_CommandType_MAX = SessionCommand_CommandType_NUM_OF_COMMANDS;
const int SessionCommand_CommandType_CommandType_ARRAYSIZE = SessionCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionCommand_CommandType_descriptor();
inline const ::std::string& SessionCommand_CommandType_Name(SessionCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionCommand_CommandType_descriptor(), value);
}
inline bool SessionCommand_CommandType_Parse(
    const ::std::string& name, SessionCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionCommand_CommandType>(
    SessionCommand_CommandType_descriptor(), name, value);
}
enum SessionCommand_UsageStatsEvent {
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW = 1,
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE = 2,
  SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT = 3,
  SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT = 4,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT = 5,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT = 6,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE = 7,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT = 8,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_0 = 9,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_1 = 10,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_2 = 11,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_3 = 12,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_4 = 13,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_5 = 14,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_6 = 15,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_7 = 16,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_8 = 17,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_9 = 18,
  SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_GE10 = 19,
  SessionCommand_UsageStatsEvent_KEYBOARD_FOLD_EVENT = 20,
  SessionCommand_UsageStatsEvent_KEYBOARD_EXPAND_EVENT = 21,
  SessionCommand_UsageStatsEvent_MUSHROOM_SELECTION_DIALOG_OPEN_EVENT = 22,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_HEIGHT_DIP_LANDSCAPE = 23,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_HEIGHT_DIP_PORTRAIT = 24,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE = 25,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT = 26,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE = 27,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT = 28
};
bool SessionCommand_UsageStatsEvent_IsValid(int value);
const SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN = SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
const SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX = SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT;
const int SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE = SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionCommand_UsageStatsEvent_descriptor();
inline const ::std::string& SessionCommand_UsageStatsEvent_Name(SessionCommand_UsageStatsEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionCommand_UsageStatsEvent_descriptor(), value);
}
inline bool SessionCommand_UsageStatsEvent_Parse(
    const ::std::string& name, SessionCommand_UsageStatsEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionCommand_UsageStatsEvent>(
    SessionCommand_UsageStatsEvent_descriptor(), name, value);
}
enum Context_InputFieldType {
  Context_InputFieldType_NORMAL = 1,
  Context_InputFieldType_PASSWORD = 2,
  Context_InputFieldType_TEL = 3,
  Context_InputFieldType_NUMBER = 4
};
bool Context_InputFieldType_IsValid(int value);
const Context_InputFieldType Context_InputFieldType_InputFieldType_MIN = Context_InputFieldType_NORMAL;
const Context_InputFieldType Context_InputFieldType_InputFieldType_MAX = Context_InputFieldType_NUMBER;
const int Context_InputFieldType_InputFieldType_ARRAYSIZE = Context_InputFieldType_InputFieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Context_InputFieldType_descriptor();
inline const ::std::string& Context_InputFieldType_Name(Context_InputFieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Context_InputFieldType_descriptor(), value);
}
inline bool Context_InputFieldType_Parse(
    const ::std::string& name, Context_InputFieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Context_InputFieldType>(
    Context_InputFieldType_descriptor(), name, value);
}
enum Capability_TextDeletionCapabilityType {
  Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY = 0,
  Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT = 1
};
bool Capability_TextDeletionCapabilityType_IsValid(int value);
const Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN = Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
const Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX = Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
const int Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE = Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Capability_TextDeletionCapabilityType_descriptor();
inline const ::std::string& Capability_TextDeletionCapabilityType_Name(Capability_TextDeletionCapabilityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Capability_TextDeletionCapabilityType_descriptor(), value);
}
inline bool Capability_TextDeletionCapabilityType_Parse(
    const ::std::string& name, Capability_TextDeletionCapabilityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Capability_TextDeletionCapabilityType>(
    Capability_TextDeletionCapabilityType_descriptor(), name, value);
}
enum Request_SpecialRomanjiTable {
  Request_SpecialRomanjiTable_DEFAULT_TABLE = 0,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA = 10,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII = 11,
  Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA = 13,
  Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII = 14,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA = 16,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII = 17,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA = 20,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII = 22,
  Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA = 30,
  Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII = 31,
  Request_SpecialRomanjiTable_NOTOUCH_TO_HIRAGANA = 40,
  Request_SpecialRomanjiTable_NOTOUCH_TO_HALFWIDTHASCII = 41,
  Request_SpecialRomanjiTable_OBSOLETE_TWELVE_KEYS_TO_NUMBER = 12,
  Request_SpecialRomanjiTable_OBSOLETE_FLICK_TO_NUMBER = 15,
  Request_SpecialRomanjiTable_OBSOLETE_GODAN_TO_NUMBER = 32,
  Request_SpecialRomanjiTable_OBSOLETE_QWERTY_MOBILE_TO_HIRAGANA_NUMBER = 21,
  Request_SpecialRomanjiTable_OBSOLETE_TOGGLE_FLICK_TO_NUMBER = 18
};
bool Request_SpecialRomanjiTable_IsValid(int value);
const Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN = Request_SpecialRomanjiTable_DEFAULT_TABLE;
const Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX = Request_SpecialRomanjiTable_NOTOUCH_TO_HALFWIDTHASCII;
const int Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE = Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_SpecialRomanjiTable_descriptor();
inline const ::std::string& Request_SpecialRomanjiTable_Name(Request_SpecialRomanjiTable value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_SpecialRomanjiTable_descriptor(), value);
}
inline bool Request_SpecialRomanjiTable_Parse(
    const ::std::string& name, Request_SpecialRomanjiTable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_SpecialRomanjiTable>(
    Request_SpecialRomanjiTable_descriptor(), name, value);
}
enum Request_SpaceOnAlphanumeric {
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0,
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION = 1,
  Request_SpaceOnAlphanumeric_COMMIT = 2
};
bool Request_SpaceOnAlphanumeric_IsValid(int value);
const Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN = Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
const Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX = Request_SpaceOnAlphanumeric_COMMIT;
const int Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE = Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_SpaceOnAlphanumeric_descriptor();
inline const ::std::string& Request_SpaceOnAlphanumeric_Name(Request_SpaceOnAlphanumeric value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_SpaceOnAlphanumeric_descriptor(), value);
}
inline bool Request_SpaceOnAlphanumeric_Parse(
    const ::std::string& name, Request_SpaceOnAlphanumeric* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_SpaceOnAlphanumeric>(
    Request_SpaceOnAlphanumeric_descriptor(), name, value);
}
enum Request_EmojiCarrierType {
  Request_EmojiCarrierType_UNICODE_EMOJI = 1,
  Request_EmojiCarrierType_DOCOMO_EMOJI = 2,
  Request_EmojiCarrierType_SOFTBANK_EMOJI = 4,
  Request_EmojiCarrierType_KDDI_EMOJI = 8
};
bool Request_EmojiCarrierType_IsValid(int value);
const Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MIN = Request_EmojiCarrierType_UNICODE_EMOJI;
const Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MAX = Request_EmojiCarrierType_KDDI_EMOJI;
const int Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE = Request_EmojiCarrierType_EmojiCarrierType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_EmojiCarrierType_descriptor();
inline const ::std::string& Request_EmojiCarrierType_Name(Request_EmojiCarrierType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_EmojiCarrierType_descriptor(), value);
}
inline bool Request_EmojiCarrierType_Parse(
    const ::std::string& name, Request_EmojiCarrierType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_EmojiCarrierType>(
    Request_EmojiCarrierType_descriptor(), name, value);
}
enum Request_RewriterCapability {
  Request_RewriterCapability_NOT_AVAILABLE = 0,
  Request_RewriterCapability_CONVERSION = 1,
  Request_RewriterCapability_PREDICTION = 2,
  Request_RewriterCapability_SUGGESTION = 4,
  Request_RewriterCapability_ALL = 7
};
bool Request_RewriterCapability_IsValid(int value);
const Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MIN = Request_RewriterCapability_NOT_AVAILABLE;
const Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MAX = Request_RewriterCapability_ALL;
const int Request_RewriterCapability_RewriterCapability_ARRAYSIZE = Request_RewriterCapability_RewriterCapability_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RewriterCapability_descriptor();
inline const ::std::string& Request_RewriterCapability_Name(Request_RewriterCapability value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RewriterCapability_descriptor(), value);
}
inline bool Request_RewriterCapability_Parse(
    const ::std::string& name, Request_RewriterCapability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RewriterCapability>(
    Request_RewriterCapability_descriptor(), name, value);
}
enum Request_CrossingEdgeBehavior {
  Request_CrossingEdgeBehavior_DO_NOTHING = 0,
  Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING = 1
};
bool Request_CrossingEdgeBehavior_IsValid(int value);
const Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN = Request_CrossingEdgeBehavior_DO_NOTHING;
const Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX = Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
const int Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE = Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_CrossingEdgeBehavior_descriptor();
inline const ::std::string& Request_CrossingEdgeBehavior_Name(Request_CrossingEdgeBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_CrossingEdgeBehavior_descriptor(), value);
}
inline bool Request_CrossingEdgeBehavior_Parse(
    const ::std::string& name, Request_CrossingEdgeBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_CrossingEdgeBehavior>(
    Request_CrossingEdgeBehavior_descriptor(), name, value);
}
enum Request_LanguageAwareInputBehavior {
  Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0,
  Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT = 1,
  Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION = 2
};
bool Request_LanguageAwareInputBehavior_IsValid(int value);
const Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN = Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
const Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX = Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
const int Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE = Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_LanguageAwareInputBehavior_descriptor();
inline const ::std::string& Request_LanguageAwareInputBehavior_Name(Request_LanguageAwareInputBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_LanguageAwareInputBehavior_descriptor(), value);
}
inline bool Request_LanguageAwareInputBehavior_Parse(
    const ::std::string& name, Request_LanguageAwareInputBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_LanguageAwareInputBehavior>(
    Request_LanguageAwareInputBehavior_descriptor(), name, value);
}
enum Input_CommandType {
  Input_CommandType_NONE = 0,
  Input_CommandType_CREATE_SESSION = 1,
  Input_CommandType_DELETE_SESSION = 2,
  Input_CommandType_SEND_KEY = 3,
  Input_CommandType_TEST_SEND_KEY = 4,
  Input_CommandType_SEND_COMMAND = 5,
  Input_CommandType_GET_CONFIG = 6,
  Input_CommandType_SET_CONFIG = 7,
  Input_CommandType_SET_IMPOSED_CONFIG = 22,
  Input_CommandType_SET_REQUEST = 17,
  Input_CommandType_SYNC_DATA = 8,
  Input_CommandType_SHUTDOWN = 9,
  Input_CommandType_RELOAD = 10,
  Input_CommandType_CLEAR_USER_HISTORY = 11,
  Input_CommandType_CLEAR_USER_PREDICTION = 12,
  Input_CommandType_CLEAR_UNUSED_USER_PREDICTION = 16,
  Input_CommandType_CLEANUP = 13,
  Input_CommandType_NO_OPERATION = 14,
  Input_CommandType_OBSOLETE_START_CLOUD_SYNC = 18,
  Input_CommandType_OBSOLETE_GET_CLOUD_SYNC_STATUS = 23,
  Input_CommandType_OBSOLETE_ADD_AUTH_CODE = 24,
  Input_CommandType_INSERT_TO_STORAGE = 20,
  Input_CommandType_READ_ALL_FROM_STORAGE = 21,
  Input_CommandType_CLEAR_STORAGE = 25,
  Input_CommandType_SEND_USER_DICTIONARY_COMMAND = 26,
  Input_CommandType_SEND_ENGINE_RELOAD_REQUEST = 27,
  Input_CommandType_NUM_OF_COMMANDS = 28
};
bool Input_CommandType_IsValid(int value);
const Input_CommandType Input_CommandType_CommandType_MIN = Input_CommandType_NONE;
const Input_CommandType Input_CommandType_CommandType_MAX = Input_CommandType_NUM_OF_COMMANDS;
const int Input_CommandType_CommandType_ARRAYSIZE = Input_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Input_CommandType_descriptor();
inline const ::std::string& Input_CommandType_Name(Input_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Input_CommandType_descriptor(), value);
}
inline bool Input_CommandType_Parse(
    const ::std::string& name, Input_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Input_CommandType>(
    Input_CommandType_descriptor(), name, value);
}
enum Input_TouchAction {
  Input_TouchAction_TOUCH_DOWN = 1,
  Input_TouchAction_TOUCH_MOVE = 2,
  Input_TouchAction_TOUCH_UP = 3
};
bool Input_TouchAction_IsValid(int value);
const Input_TouchAction Input_TouchAction_TouchAction_MIN = Input_TouchAction_TOUCH_DOWN;
const Input_TouchAction Input_TouchAction_TouchAction_MAX = Input_TouchAction_TOUCH_UP;
const int Input_TouchAction_TouchAction_ARRAYSIZE = Input_TouchAction_TouchAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Input_TouchAction_descriptor();
inline const ::std::string& Input_TouchAction_Name(Input_TouchAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Input_TouchAction_descriptor(), value);
}
inline bool Input_TouchAction_Parse(
    const ::std::string& name, Input_TouchAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Input_TouchAction>(
    Input_TouchAction_descriptor(), name, value);
}
enum Result_ResultType {
  Result_ResultType_NONE = 0,
  Result_ResultType_STRING = 1
};
bool Result_ResultType_IsValid(int value);
const Result_ResultType Result_ResultType_ResultType_MIN = Result_ResultType_NONE;
const Result_ResultType Result_ResultType_ResultType_MAX = Result_ResultType_STRING;
const int Result_ResultType_ResultType_ARRAYSIZE = Result_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_ResultType_descriptor();
inline const ::std::string& Result_ResultType_Name(Result_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_ResultType_descriptor(), value);
}
inline bool Result_ResultType_Parse(
    const ::std::string& name, Result_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result_ResultType>(
    Result_ResultType_descriptor(), name, value);
}
enum Preedit_Segment_Annotation {
  Preedit_Segment_Annotation_NONE = 0,
  Preedit_Segment_Annotation_UNDERLINE = 1,
  Preedit_Segment_Annotation_HIGHLIGHT = 2
};
bool Preedit_Segment_Annotation_IsValid(int value);
const Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MIN = Preedit_Segment_Annotation_NONE;
const Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MAX = Preedit_Segment_Annotation_HIGHLIGHT;
const int Preedit_Segment_Annotation_Annotation_ARRAYSIZE = Preedit_Segment_Annotation_Annotation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Preedit_Segment_Annotation_descriptor();
inline const ::std::string& Preedit_Segment_Annotation_Name(Preedit_Segment_Annotation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Preedit_Segment_Annotation_descriptor(), value);
}
inline bool Preedit_Segment_Annotation_Parse(
    const ::std::string& name, Preedit_Segment_Annotation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Preedit_Segment_Annotation>(
    Preedit_Segment_Annotation_descriptor(), name, value);
}
enum Output_PreeditMethod {
  Output_PreeditMethod_ASCII = 0,
  Output_PreeditMethod_KANA = 1
};
bool Output_PreeditMethod_IsValid(int value);
const Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MIN = Output_PreeditMethod_ASCII;
const Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MAX = Output_PreeditMethod_KANA;
const int Output_PreeditMethod_PreeditMethod_ARRAYSIZE = Output_PreeditMethod_PreeditMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_PreeditMethod_descriptor();
inline const ::std::string& Output_PreeditMethod_Name(Output_PreeditMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_PreeditMethod_descriptor(), value);
}
inline bool Output_PreeditMethod_Parse(
    const ::std::string& name, Output_PreeditMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_PreeditMethod>(
    Output_PreeditMethod_descriptor(), name, value);
}
enum Output_ErrorCode {
  Output_ErrorCode_SESSION_SUCCESS = 0,
  Output_ErrorCode_SESSION_FAILURE = 1
};
bool Output_ErrorCode_IsValid(int value);
const Output_ErrorCode Output_ErrorCode_ErrorCode_MIN = Output_ErrorCode_SESSION_SUCCESS;
const Output_ErrorCode Output_ErrorCode_ErrorCode_MAX = Output_ErrorCode_SESSION_FAILURE;
const int Output_ErrorCode_ErrorCode_ARRAYSIZE = Output_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_ErrorCode_descriptor();
inline const ::std::string& Output_ErrorCode_Name(Output_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_ErrorCode_descriptor(), value);
}
inline bool Output_ErrorCode_Parse(
    const ::std::string& name, Output_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_ErrorCode>(
    Output_ErrorCode_descriptor(), name, value);
}
enum Output_ToolMode {
  Output_ToolMode_NO_TOOL = 0,
  Output_ToolMode_CONFIG_DIALOG = 1,
  Output_ToolMode_DICTIONARY_TOOL = 2,
  Output_ToolMode_WORD_REGISTER_DIALOG = 3
};
bool Output_ToolMode_IsValid(int value);
const Output_ToolMode Output_ToolMode_ToolMode_MIN = Output_ToolMode_NO_TOOL;
const Output_ToolMode Output_ToolMode_ToolMode_MAX = Output_ToolMode_WORD_REGISTER_DIALOG;
const int Output_ToolMode_ToolMode_ARRAYSIZE = Output_ToolMode_ToolMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_ToolMode_descriptor();
inline const ::std::string& Output_ToolMode_Name(Output_ToolMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_ToolMode_descriptor(), value);
}
inline bool Output_ToolMode_Parse(
    const ::std::string& name, Output_ToolMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_ToolMode>(
    Output_ToolMode_descriptor(), name, value);
}
enum CompositionMode {
  DIRECT = 0,
  HIRAGANA = 1,
  FULL_KATAKANA = 2,
  HALF_ASCII = 3,
  FULL_ASCII = 4,
  HALF_KATAKANA = 5,
  NUM_OF_COMPOSITIONS = 6
};
bool CompositionMode_IsValid(int value);
const CompositionMode CompositionMode_MIN = DIRECT;
const CompositionMode CompositionMode_MAX = NUM_OF_COMPOSITIONS;
const int CompositionMode_ARRAYSIZE = CompositionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompositionMode_descriptor();
inline const ::std::string& CompositionMode_Name(CompositionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompositionMode_descriptor(), value);
}
inline bool CompositionMode_Parse(
    const ::std::string& name, CompositionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompositionMode>(
    CompositionMode_descriptor(), name, value);
}
// ===================================================================

class KeyEvent_ProbableKeyEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.KeyEvent.ProbableKeyEvent) */ {
 public:
  KeyEvent_ProbableKeyEvent();
  virtual ~KeyEvent_ProbableKeyEvent();

  KeyEvent_ProbableKeyEvent(const KeyEvent_ProbableKeyEvent& from);

  inline KeyEvent_ProbableKeyEvent& operator=(const KeyEvent_ProbableKeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyEvent_ProbableKeyEvent(KeyEvent_ProbableKeyEvent&& from) noexcept
    : KeyEvent_ProbableKeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent_ProbableKeyEvent& operator=(KeyEvent_ProbableKeyEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyEvent_ProbableKeyEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyEvent_ProbableKeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent_ProbableKeyEvent*>(
               &_KeyEvent_ProbableKeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(KeyEvent_ProbableKeyEvent* other);
  friend void swap(KeyEvent_ProbableKeyEvent& a, KeyEvent_ProbableKeyEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyEvent_ProbableKeyEvent* New() const final {
    return CreateMaybeMessage<KeyEvent_ProbableKeyEvent>(NULL);
  }

  KeyEvent_ProbableKeyEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyEvent_ProbableKeyEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyEvent_ProbableKeyEvent& from);
  void MergeFrom(const KeyEvent_ProbableKeyEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyEvent_ProbableKeyEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  int modifier_keys_size() const;
  void clear_modifier_keys();
  static const int kModifierKeysFieldNumber = 4;
  ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  const ::google::protobuf::RepeatedField<int>& modifier_keys() const;
  ::google::protobuf::RepeatedField<int>* mutable_modifier_keys();

  // optional uint32 key_code = 1;
  bool has_key_code() const;
  void clear_key_code();
  static const int kKeyCodeFieldNumber = 1;
  ::google::protobuf::uint32 key_code() const;
  void set_key_code(::google::protobuf::uint32 value);

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  bool has_special_key() const;
  void clear_special_key();
  static const int kSpecialKeyFieldNumber = 3;
  ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);

  // optional double probability = 10;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 10;
  double probability() const;
  void set_probability(double value);

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
 private:
  void set_has_key_code();
  void clear_has_key_code();
  void set_has_special_key();
  void clear_has_special_key();
  void set_has_probability();
  void clear_has_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> modifier_keys_;
  ::google::protobuf::uint32 key_code_;
  int special_key_;
  double probability_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.KeyEvent) */ {
 public:
  KeyEvent();
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyEvent(KeyEvent&& from) noexcept
    : KeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent& operator=(KeyEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent*>(
               &_KeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(KeyEvent* other);
  friend void swap(KeyEvent& a, KeyEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyEvent* New() const final {
    return CreateMaybeMessage<KeyEvent>(NULL);
  }

  KeyEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KeyEvent_ProbableKeyEvent ProbableKeyEvent;

  typedef KeyEvent_SpecialKey SpecialKey;
  static const SpecialKey NO_SPECIALKEY =
    KeyEvent_SpecialKey_NO_SPECIALKEY;
  static const SpecialKey DIGIT =
    KeyEvent_SpecialKey_DIGIT;
  static const SpecialKey ON =
    KeyEvent_SpecialKey_ON;
  static const SpecialKey OFF =
    KeyEvent_SpecialKey_OFF;
  static const SpecialKey SPACE =
    KeyEvent_SpecialKey_SPACE;
  static const SpecialKey ENTER =
    KeyEvent_SpecialKey_ENTER;
  static const SpecialKey LEFT =
    KeyEvent_SpecialKey_LEFT;
  static const SpecialKey RIGHT =
    KeyEvent_SpecialKey_RIGHT;
  static const SpecialKey UP =
    KeyEvent_SpecialKey_UP;
  static const SpecialKey DOWN =
    KeyEvent_SpecialKey_DOWN;
  static const SpecialKey ESCAPE =
    KeyEvent_SpecialKey_ESCAPE;
  static const SpecialKey DEL =
    KeyEvent_SpecialKey_DEL;
  static const SpecialKey BACKSPACE =
    KeyEvent_SpecialKey_BACKSPACE;
  static const SpecialKey HENKAN =
    KeyEvent_SpecialKey_HENKAN;
  static const SpecialKey MUHENKAN =
    KeyEvent_SpecialKey_MUHENKAN;
  static const SpecialKey KANA =
    KeyEvent_SpecialKey_KANA;
  static const SpecialKey HOME =
    KeyEvent_SpecialKey_HOME;
  static const SpecialKey END =
    KeyEvent_SpecialKey_END;
  static const SpecialKey TAB =
    KeyEvent_SpecialKey_TAB;
  static const SpecialKey F1 =
    KeyEvent_SpecialKey_F1;
  static const SpecialKey F2 =
    KeyEvent_SpecialKey_F2;
  static const SpecialKey F3 =
    KeyEvent_SpecialKey_F3;
  static const SpecialKey F4 =
    KeyEvent_SpecialKey_F4;
  static const SpecialKey F5 =
    KeyEvent_SpecialKey_F5;
  static const SpecialKey F6 =
    KeyEvent_SpecialKey_F6;
  static const SpecialKey F7 =
    KeyEvent_SpecialKey_F7;
  static const SpecialKey F8 =
    KeyEvent_SpecialKey_F8;
  static const SpecialKey F9 =
    KeyEvent_SpecialKey_F9;
  static const SpecialKey F10 =
    KeyEvent_SpecialKey_F10;
  static const SpecialKey F11 =
    KeyEvent_SpecialKey_F11;
  static const SpecialKey F12 =
    KeyEvent_SpecialKey_F12;
  static const SpecialKey PAGE_UP =
    KeyEvent_SpecialKey_PAGE_UP;
  static const SpecialKey PAGE_DOWN =
    KeyEvent_SpecialKey_PAGE_DOWN;
  static const SpecialKey INSERT =
    KeyEvent_SpecialKey_INSERT;
  static const SpecialKey F13 =
    KeyEvent_SpecialKey_F13;
  static const SpecialKey F14 =
    KeyEvent_SpecialKey_F14;
  static const SpecialKey F15 =
    KeyEvent_SpecialKey_F15;
  static const SpecialKey F16 =
    KeyEvent_SpecialKey_F16;
  static const SpecialKey F17 =
    KeyEvent_SpecialKey_F17;
  static const SpecialKey F18 =
    KeyEvent_SpecialKey_F18;
  static const SpecialKey F19 =
    KeyEvent_SpecialKey_F19;
  static const SpecialKey F20 =
    KeyEvent_SpecialKey_F20;
  static const SpecialKey F21 =
    KeyEvent_SpecialKey_F21;
  static const SpecialKey F22 =
    KeyEvent_SpecialKey_F22;
  static const SpecialKey F23 =
    KeyEvent_SpecialKey_F23;
  static const SpecialKey F24 =
    KeyEvent_SpecialKey_F24;
  static const SpecialKey EISU =
    KeyEvent_SpecialKey_EISU;
  static const SpecialKey NUMPAD0 =
    KeyEvent_SpecialKey_NUMPAD0;
  static const SpecialKey NUMPAD1 =
    KeyEvent_SpecialKey_NUMPAD1;
  static const SpecialKey NUMPAD2 =
    KeyEvent_SpecialKey_NUMPAD2;
  static const SpecialKey NUMPAD3 =
    KeyEvent_SpecialKey_NUMPAD3;
  static const SpecialKey NUMPAD4 =
    KeyEvent_SpecialKey_NUMPAD4;
  static const SpecialKey NUMPAD5 =
    KeyEvent_SpecialKey_NUMPAD5;
  static const SpecialKey NUMPAD6 =
    KeyEvent_SpecialKey_NUMPAD6;
  static const SpecialKey NUMPAD7 =
    KeyEvent_SpecialKey_NUMPAD7;
  static const SpecialKey NUMPAD8 =
    KeyEvent_SpecialKey_NUMPAD8;
  static const SpecialKey NUMPAD9 =
    KeyEvent_SpecialKey_NUMPAD9;
  static const SpecialKey MULTIPLY =
    KeyEvent_SpecialKey_MULTIPLY;
  static const SpecialKey ADD =
    KeyEvent_SpecialKey_ADD;
  static const SpecialKey SEPARATOR =
    KeyEvent_SpecialKey_SEPARATOR;
  static const SpecialKey SUBTRACT =
    KeyEvent_SpecialKey_SUBTRACT;
  static const SpecialKey DECIMAL =
    KeyEvent_SpecialKey_DECIMAL;
  static const SpecialKey DIVIDE =
    KeyEvent_SpecialKey_DIVIDE;
  static const SpecialKey EQUALS =
    KeyEvent_SpecialKey_EQUALS;
  static const SpecialKey TEXT_INPUT =
    KeyEvent_SpecialKey_TEXT_INPUT;
  static const SpecialKey HANKAKU =
    KeyEvent_SpecialKey_HANKAKU;
  static const SpecialKey KANJI =
    KeyEvent_SpecialKey_KANJI;
  static const SpecialKey KATAKANA =
    KeyEvent_SpecialKey_KATAKANA;
  static const SpecialKey CAPS_LOCK =
    KeyEvent_SpecialKey_CAPS_LOCK;
  static const SpecialKey UNDEFINED_KEY =
    KeyEvent_SpecialKey_UNDEFINED_KEY;
  static const SpecialKey COMMA =
    KeyEvent_SpecialKey_COMMA;
  static const SpecialKey CLEAR =
    KeyEvent_SpecialKey_CLEAR;
  static const SpecialKey VIRTUAL_LEFT =
    KeyEvent_SpecialKey_VIRTUAL_LEFT;
  static const SpecialKey VIRTUAL_RIGHT =
    KeyEvent_SpecialKey_VIRTUAL_RIGHT;
  static const SpecialKey VIRTUAL_ENTER =
    KeyEvent_SpecialKey_VIRTUAL_ENTER;
  static const SpecialKey VIRTUAL_UP =
    KeyEvent_SpecialKey_VIRTUAL_UP;
  static const SpecialKey VIRTUAL_DOWN =
    KeyEvent_SpecialKey_VIRTUAL_DOWN;
  static const SpecialKey NUM_SPECIALKEYS =
    KeyEvent_SpecialKey_NUM_SPECIALKEYS;
  static inline bool SpecialKey_IsValid(int value) {
    return KeyEvent_SpecialKey_IsValid(value);
  }
  static const SpecialKey SpecialKey_MIN =
    KeyEvent_SpecialKey_SpecialKey_MIN;
  static const SpecialKey SpecialKey_MAX =
    KeyEvent_SpecialKey_SpecialKey_MAX;
  static const int SpecialKey_ARRAYSIZE =
    KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpecialKey_descriptor() {
    return KeyEvent_SpecialKey_descriptor();
  }
  static inline const ::std::string& SpecialKey_Name(SpecialKey value) {
    return KeyEvent_SpecialKey_Name(value);
  }
  static inline bool SpecialKey_Parse(const ::std::string& name,
      SpecialKey* value) {
    return KeyEvent_SpecialKey_Parse(name, value);
  }

  typedef KeyEvent_ModifierKey ModifierKey;
  static const ModifierKey CTRL =
    KeyEvent_ModifierKey_CTRL;
  static const ModifierKey ALT =
    KeyEvent_ModifierKey_ALT;
  static const ModifierKey SHIFT =
    KeyEvent_ModifierKey_SHIFT;
  static const ModifierKey KEY_DOWN =
    KeyEvent_ModifierKey_KEY_DOWN;
  static const ModifierKey KEY_UP =
    KeyEvent_ModifierKey_KEY_UP;
  static const ModifierKey LEFT_CTRL =
    KeyEvent_ModifierKey_LEFT_CTRL;
  static const ModifierKey LEFT_ALT =
    KeyEvent_ModifierKey_LEFT_ALT;
  static const ModifierKey LEFT_SHIFT =
    KeyEvent_ModifierKey_LEFT_SHIFT;
  static const ModifierKey RIGHT_CTRL =
    KeyEvent_ModifierKey_RIGHT_CTRL;
  static const ModifierKey RIGHT_ALT =
    KeyEvent_ModifierKey_RIGHT_ALT;
  static const ModifierKey RIGHT_SHIFT =
    KeyEvent_ModifierKey_RIGHT_SHIFT;
  static const ModifierKey CAPS =
    KeyEvent_ModifierKey_CAPS;
  static inline bool ModifierKey_IsValid(int value) {
    return KeyEvent_ModifierKey_IsValid(value);
  }
  static const ModifierKey ModifierKey_MIN =
    KeyEvent_ModifierKey_ModifierKey_MIN;
  static const ModifierKey ModifierKey_MAX =
    KeyEvent_ModifierKey_ModifierKey_MAX;
  static const int ModifierKey_ARRAYSIZE =
    KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModifierKey_descriptor() {
    return KeyEvent_ModifierKey_descriptor();
  }
  static inline const ::std::string& ModifierKey_Name(ModifierKey value) {
    return KeyEvent_ModifierKey_Name(value);
  }
  static inline bool ModifierKey_Parse(const ::std::string& name,
      ModifierKey* value) {
    return KeyEvent_ModifierKey_Parse(name, value);
  }

  typedef KeyEvent_InputStyle InputStyle;
  static const InputStyle FOLLOW_MODE =
    KeyEvent_InputStyle_FOLLOW_MODE;
  static const InputStyle AS_IS =
    KeyEvent_InputStyle_AS_IS;
  static const InputStyle DIRECT_INPUT =
    KeyEvent_InputStyle_DIRECT_INPUT;
  static inline bool InputStyle_IsValid(int value) {
    return KeyEvent_InputStyle_IsValid(value);
  }
  static const InputStyle InputStyle_MIN =
    KeyEvent_InputStyle_InputStyle_MIN;
  static const InputStyle InputStyle_MAX =
    KeyEvent_InputStyle_InputStyle_MAX;
  static const int InputStyle_ARRAYSIZE =
    KeyEvent_InputStyle_InputStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InputStyle_descriptor() {
    return KeyEvent_InputStyle_descriptor();
  }
  static inline const ::std::string& InputStyle_Name(InputStyle value) {
    return KeyEvent_InputStyle_Name(value);
  }
  static inline bool InputStyle_Parse(const ::std::string& name,
      InputStyle* value) {
    return KeyEvent_InputStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  int modifier_keys_size() const;
  void clear_modifier_keys();
  static const int kModifierKeysFieldNumber = 4;
  ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  const ::google::protobuf::RepeatedField<int>& modifier_keys() const;
  ::google::protobuf::RepeatedField<int>* mutable_modifier_keys();

  // repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
  int probable_key_event_size() const;
  void clear_probable_key_event();
  static const int kProbableKeyEventFieldNumber = 8;
  ::mozc::commands::KeyEvent_ProbableKeyEvent* mutable_probable_key_event(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
      mutable_probable_key_event();
  const ::mozc::commands::KeyEvent_ProbableKeyEvent& probable_key_event(int index) const;
  ::mozc::commands::KeyEvent_ProbableKeyEvent* add_probable_key_event();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
      probable_key_event() const;

  // optional string key_string = 5;
  bool has_key_string() const;
  void clear_key_string();
  static const int kKeyStringFieldNumber = 5;
  const ::std::string& key_string() const;
  void set_key_string(const ::std::string& value);
  #if LANG_CXX11
  void set_key_string(::std::string&& value);
  #endif
  void set_key_string(const char* value);
  void set_key_string(const char* value, size_t size);
  ::std::string* mutable_key_string();
  ::std::string* release_key_string();
  void set_allocated_key_string(::std::string* key_string);

  // optional uint32 key_code = 1;
  bool has_key_code() const;
  void clear_key_code();
  static const int kKeyCodeFieldNumber = 1;
  ::google::protobuf::uint32 key_code() const;
  void set_key_code(::google::protobuf::uint32 value);

  // optional uint32 modifiers = 2;
  bool has_modifiers() const;
  void clear_modifiers();
  static const int kModifiersFieldNumber = 2;
  ::google::protobuf::uint32 modifiers() const;
  void set_modifiers(::google::protobuf::uint32 value);

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  bool has_special_key() const;
  void clear_special_key();
  static const int kSpecialKeyFieldNumber = 3;
  ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);

  // optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
  bool has_input_style() const;
  void clear_input_style();
  static const int kInputStyleFieldNumber = 6;
  ::mozc::commands::KeyEvent_InputStyle input_style() const;
  void set_input_style(::mozc::commands::KeyEvent_InputStyle value);

  // optional .mozc.commands.CompositionMode mode = 7;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 7;
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);

  // optional bool activated = 9;
  bool has_activated() const;
  void clear_activated();
  static const int kActivatedFieldNumber = 9;
  bool activated() const;
  void set_activated(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent)
 private:
  void set_has_key_code();
  void clear_has_key_code();
  void set_has_modifiers();
  void clear_has_modifiers();
  void set_has_special_key();
  void clear_has_special_key();
  void set_has_key_string();
  void clear_has_key_string();
  void set_has_input_style();
  void clear_has_input_style();
  void set_has_mode();
  void clear_has_mode();
  void set_has_activated();
  void clear_has_activated();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> modifier_keys_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent > probable_key_event_;
  ::google::protobuf::internal::ArenaStringPtr key_string_;
  ::google::protobuf::uint32 key_code_;
  ::google::protobuf::uint32 modifiers_;
  int special_key_;
  int input_style_;
  int mode_;
  bool activated_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GenericStorageEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.GenericStorageEntry) */ {
 public:
  GenericStorageEntry();
  virtual ~GenericStorageEntry();

  GenericStorageEntry(const GenericStorageEntry& from);

  inline GenericStorageEntry& operator=(const GenericStorageEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GenericStorageEntry(GenericStorageEntry&& from) noexcept
    : GenericStorageEntry() {
    *this = ::std::move(from);
  }

  inline GenericStorageEntry& operator=(GenericStorageEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericStorageEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericStorageEntry* internal_default_instance() {
    return reinterpret_cast<const GenericStorageEntry*>(
               &_GenericStorageEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GenericStorageEntry* other);
  friend void swap(GenericStorageEntry& a, GenericStorageEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GenericStorageEntry* New() const final {
    return CreateMaybeMessage<GenericStorageEntry>(NULL);
  }

  GenericStorageEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GenericStorageEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GenericStorageEntry& from);
  void MergeFrom(const GenericStorageEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericStorageEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GenericStorageEntry_StorageType StorageType;
  static const StorageType SYMBOL_HISTORY =
    GenericStorageEntry_StorageType_SYMBOL_HISTORY;
  static const StorageType EMOTICON_HISTORY =
    GenericStorageEntry_StorageType_EMOTICON_HISTORY;
  static const StorageType EMOJI_HISTORY =
    GenericStorageEntry_StorageType_EMOJI_HISTORY;
  static inline bool StorageType_IsValid(int value) {
    return GenericStorageEntry_StorageType_IsValid(value);
  }
  static const StorageType StorageType_MIN =
    GenericStorageEntry_StorageType_StorageType_MIN;
  static const StorageType StorageType_MAX =
    GenericStorageEntry_StorageType_StorageType_MAX;
  static const int StorageType_ARRAYSIZE =
    GenericStorageEntry_StorageType_StorageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StorageType_descriptor() {
    return GenericStorageEntry_StorageType_descriptor();
  }
  static inline const ::std::string& StorageType_Name(StorageType value) {
    return GenericStorageEntry_StorageType_Name(value);
  }
  static inline bool StorageType_Parse(const ::std::string& name,
      StorageType* value) {
    return GenericStorageEntry_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes value = 3;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mozc::commands::GenericStorageEntry_StorageType type() const;
  void set_type(::mozc::commands::GenericStorageEntry_StorageType value);

  // @@protoc_insertion_point(class_scope:mozc.commands.GenericStorageEntry)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int type_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.SessionCommand) */ {
 public:
  SessionCommand();
  virtual ~SessionCommand();

  SessionCommand(const SessionCommand& from);

  inline SessionCommand& operator=(const SessionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionCommand(SessionCommand&& from) noexcept
    : SessionCommand() {
    *this = ::std::move(from);
  }

  inline SessionCommand& operator=(SessionCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionCommand* internal_default_instance() {
    return reinterpret_cast<const SessionCommand*>(
               &_SessionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SessionCommand* other);
  friend void swap(SessionCommand& a, SessionCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionCommand* New() const final {
    return CreateMaybeMessage<SessionCommand>(NULL);
  }

  SessionCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SessionCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SessionCommand& from);
  void MergeFrom(const SessionCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SessionCommand_CommandType CommandType;
  static const CommandType REVERT =
    SessionCommand_CommandType_REVERT;
  static const CommandType SUBMIT =
    SessionCommand_CommandType_SUBMIT;
  static const CommandType SELECT_CANDIDATE =
    SessionCommand_CommandType_SELECT_CANDIDATE;
  static const CommandType HIGHLIGHT_CANDIDATE =
    SessionCommand_CommandType_HIGHLIGHT_CANDIDATE;
  static const CommandType SWITCH_INPUT_MODE =
    SessionCommand_CommandType_SWITCH_INPUT_MODE;
  static const CommandType GET_STATUS =
    SessionCommand_CommandType_GET_STATUS;
  static const CommandType SUBMIT_CANDIDATE =
    SessionCommand_CommandType_SUBMIT_CANDIDATE;
  static const CommandType CONVERT_REVERSE =
    SessionCommand_CommandType_CONVERT_REVERSE;
  static const CommandType UNDO =
    SessionCommand_CommandType_UNDO;
  static const CommandType RESET_CONTEXT =
    SessionCommand_CommandType_RESET_CONTEXT;
  static const CommandType MOVE_CURSOR =
    SessionCommand_CommandType_MOVE_CURSOR;
  static const CommandType SWITCH_INPUT_FIELD_TYPE =
    SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE;
  static const CommandType USAGE_STATS_EVENT =
    SessionCommand_CommandType_USAGE_STATS_EVENT;
  static const CommandType UNDO_OR_REWIND =
    SessionCommand_CommandType_UNDO_OR_REWIND;
  static const CommandType EXPAND_SUGGESTION =
    SessionCommand_CommandType_EXPAND_SUGGESTION;
  static const CommandType OBSOLETE_SEND_CARET_LOCATION =
    SessionCommand_CommandType_OBSOLETE_SEND_CARET_LOCATION;
  static const CommandType OBSOLETE_SEND_LANGUAGE_BAR_COMMAND =
    SessionCommand_CommandType_OBSOLETE_SEND_LANGUAGE_BAR_COMMAND;
  static const CommandType OBSOLETE_GET_ASYNC_RESULT =
    SessionCommand_CommandType_OBSOLETE_GET_ASYNC_RESULT;
  static const CommandType COMMIT_RAW_TEXT =
    SessionCommand_CommandType_COMMIT_RAW_TEXT;
  static const CommandType CONVERT_PREV_PAGE =
    SessionCommand_CommandType_CONVERT_PREV_PAGE;
  static const CommandType CONVERT_NEXT_PAGE =
    SessionCommand_CommandType_CONVERT_NEXT_PAGE;
  static const CommandType TURN_ON_IME =
    SessionCommand_CommandType_TURN_ON_IME;
  static const CommandType TURN_OFF_IME =
    SessionCommand_CommandType_TURN_OFF_IME;
  static const CommandType NUM_OF_COMMANDS =
    SessionCommand_CommandType_NUM_OF_COMMANDS;
  static inline bool CommandType_IsValid(int value) {
    return SessionCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    SessionCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    SessionCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    SessionCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return SessionCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return SessionCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return SessionCommand_CommandType_Parse(name, value);
  }

  typedef SessionCommand_UsageStatsEvent UsageStatsEvent;
  static const UsageStatsEvent INFOLIST_WINDOW_SHOW =
    SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
  static const UsageStatsEvent INFOLIST_WINDOW_HIDE =
    SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE;
  static const UsageStatsEvent HANDWRITING_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT;
  static const UsageStatsEvent HANDWRITING_COMMIT_EVENT =
    SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT;
  static const UsageStatsEvent CHARACTER_PALETTE_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT;
  static const UsageStatsEvent CHARACTER_PALETTE_COMMIT_EVENT =
    SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_0 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_0;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_1 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_1;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_2 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_2;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_3 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_3;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_4 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_4;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_5 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_5;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_6 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_6;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_7 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_7;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_8 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_8;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_9 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_9;
  static const UsageStatsEvent SUBMITTED_CANDIDATE_ROW_GE10 =
    SessionCommand_UsageStatsEvent_SUBMITTED_CANDIDATE_ROW_GE10;
  static const UsageStatsEvent KEYBOARD_FOLD_EVENT =
    SessionCommand_UsageStatsEvent_KEYBOARD_FOLD_EVENT;
  static const UsageStatsEvent KEYBOARD_EXPAND_EVENT =
    SessionCommand_UsageStatsEvent_KEYBOARD_EXPAND_EVENT;
  static const UsageStatsEvent MUSHROOM_SELECTION_DIALOG_OPEN_EVENT =
    SessionCommand_UsageStatsEvent_MUSHROOM_SELECTION_DIALOG_OPEN_EVENT;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_HEIGHT_DIP_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_HEIGHT_DIP_LANDSCAPE;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_HEIGHT_DIP_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_HEIGHT_DIP_PORTRAIT;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_LANDSCAPE;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ADJUSTMENT_ENABLED_PORTRAIT;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_LANDSCAPE;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT =
    SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_ENGLISH_PORTRAIT;
  static inline bool UsageStatsEvent_IsValid(int value) {
    return SessionCommand_UsageStatsEvent_IsValid(value);
  }
  static const UsageStatsEvent UsageStatsEvent_MIN =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN;
  static const UsageStatsEvent UsageStatsEvent_MAX =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX;
  static const int UsageStatsEvent_ARRAYSIZE =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UsageStatsEvent_descriptor() {
    return SessionCommand_UsageStatsEvent_descriptor();
  }
  static inline const ::std::string& UsageStatsEvent_Name(UsageStatsEvent value) {
    return SessionCommand_UsageStatsEvent_Name(value);
  }
  static inline bool UsageStatsEvent_Parse(const ::std::string& name,
      UsageStatsEvent* value) {
    return SessionCommand_UsageStatsEvent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .mozc.commands.CompositionMode composition_mode = 3;
  bool has_composition_mode() const;
  void clear_composition_mode();
  static const int kCompositionModeFieldNumber = 3;
  ::mozc::commands::CompositionMode composition_mode() const;
  void set_composition_mode(::mozc::commands::CompositionMode value);

  // optional uint32 cursor_position = 5;
  bool has_cursor_position() const;
  void clear_cursor_position();
  static const int kCursorPositionFieldNumber = 5;
  ::google::protobuf::uint32 cursor_position() const;
  void set_cursor_position(::google::protobuf::uint32 value);

  // optional int32 usage_stats_event_int_value = 9;
  bool has_usage_stats_event_int_value() const;
  void clear_usage_stats_event_int_value();
  static const int kUsageStatsEventIntValueFieldNumber = 9;
  ::google::protobuf::int32 usage_stats_event_int_value() const;
  void set_usage_stats_event_int_value(::google::protobuf::int32 value);

  // required .mozc.commands.SessionCommand.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mozc::commands::SessionCommand_CommandType type() const;
  void set_type(::mozc::commands::SessionCommand_CommandType value);

  // optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
  bool has_usage_stats_event() const;
  void clear_usage_stats_event();
  static const int kUsageStatsEventFieldNumber = 7;
  ::mozc::commands::SessionCommand_UsageStatsEvent usage_stats_event() const;
  void set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value);

  // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();
  void set_has_composition_mode();
  void clear_has_composition_mode();
  void set_has_text();
  void clear_has_text();
  void set_has_cursor_position();
  void clear_has_cursor_position();
  void set_has_usage_stats_event();
  void clear_has_usage_stats_event();
  void set_has_usage_stats_event_int_value();
  void clear_has_usage_stats_event_int_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 id_;
  int composition_mode_;
  ::google::protobuf::uint32 cursor_position_;
  ::google::protobuf::int32 usage_stats_event_int_value_;
  int type_;
  int usage_stats_event_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Context : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Context) */ {
 public:
  Context();
  virtual ~Context();

  Context(const Context& from);

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Context(Context&& from) noexcept
    : Context() {
    *this = ::std::move(from);
  }

  inline Context& operator=(Context&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Context& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Context* internal_default_instance() {
    return reinterpret_cast<const Context*>(
               &_Context_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Context* other);
  friend void swap(Context& a, Context& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Context* New() const final {
    return CreateMaybeMessage<Context>(NULL);
  }

  Context* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Context>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Context* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Context_InputFieldType InputFieldType;
  static const InputFieldType NORMAL =
    Context_InputFieldType_NORMAL;
  static const InputFieldType PASSWORD =
    Context_InputFieldType_PASSWORD;
  static const InputFieldType TEL =
    Context_InputFieldType_TEL;
  static const InputFieldType NUMBER =
    Context_InputFieldType_NUMBER;
  static inline bool InputFieldType_IsValid(int value) {
    return Context_InputFieldType_IsValid(value);
  }
  static const InputFieldType InputFieldType_MIN =
    Context_InputFieldType_InputFieldType_MIN;
  static const InputFieldType InputFieldType_MAX =
    Context_InputFieldType_InputFieldType_MAX;
  static const int InputFieldType_ARRAYSIZE =
    Context_InputFieldType_InputFieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InputFieldType_descriptor() {
    return Context_InputFieldType_descriptor();
  }
  static inline const ::std::string& InputFieldType_Name(InputFieldType value) {
    return Context_InputFieldType_Name(value);
  }
  static inline bool InputFieldType_Parse(const ::std::string& name,
      InputFieldType* value) {
    return Context_InputFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string experimental_features = 100;
  int experimental_features_size() const;
  void clear_experimental_features();
  static const int kExperimentalFeaturesFieldNumber = 100;
  const ::std::string& experimental_features(int index) const;
  ::std::string* mutable_experimental_features(int index);
  void set_experimental_features(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_experimental_features(int index, ::std::string&& value);
  #endif
  void set_experimental_features(int index, const char* value);
  void set_experimental_features(int index, const char* value, size_t size);
  ::std::string* add_experimental_features();
  void add_experimental_features(const ::std::string& value);
  #if LANG_CXX11
  void add_experimental_features(::std::string&& value);
  #endif
  void add_experimental_features(const char* value);
  void add_experimental_features(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& experimental_features() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_experimental_features();

  // optional string preceding_text = 1;
  bool has_preceding_text() const;
  void clear_preceding_text();
  static const int kPrecedingTextFieldNumber = 1;
  const ::std::string& preceding_text() const;
  void set_preceding_text(const ::std::string& value);
  #if LANG_CXX11
  void set_preceding_text(::std::string&& value);
  #endif
  void set_preceding_text(const char* value);
  void set_preceding_text(const char* value, size_t size);
  ::std::string* mutable_preceding_text();
  ::std::string* release_preceding_text();
  void set_allocated_preceding_text(::std::string* preceding_text);

  // optional string following_text = 2;
  bool has_following_text() const;
  void clear_following_text();
  static const int kFollowingTextFieldNumber = 2;
  const ::std::string& following_text() const;
  void set_following_text(const ::std::string& value);
  #if LANG_CXX11
  void set_following_text(::std::string&& value);
  #endif
  void set_following_text(const char* value);
  void set_following_text(const char* value, size_t size);
  ::std::string* mutable_following_text();
  ::std::string* release_following_text();
  void set_allocated_following_text(::std::string* following_text);

  // optional bool suppress_suggestion = 3 [default = false];
  bool has_suppress_suggestion() const;
  void clear_suppress_suggestion();
  static const int kSuppressSuggestionFieldNumber = 3;
  bool suppress_suggestion() const;
  void set_suppress_suggestion(bool value);

  // optional int32 revision = 5 [default = 0];
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 5;
  ::google::protobuf::int32 revision() const;
  void set_revision(::google::protobuf::int32 value);

  // optional .mozc.commands.Context.InputFieldType input_field_type = 4;
  bool has_input_field_type() const;
  void clear_input_field_type();
  static const int kInputFieldTypeFieldNumber = 4;
  ::mozc::commands::Context_InputFieldType input_field_type() const;
  void set_input_field_type(::mozc::commands::Context_InputFieldType value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Context)
 private:
  void set_has_preceding_text();
  void clear_has_preceding_text();
  void set_has_following_text();
  void clear_has_following_text();
  void set_has_suppress_suggestion();
  void clear_has_suppress_suggestion();
  void set_has_input_field_type();
  void clear_has_input_field_type();
  void set_has_revision();
  void clear_has_revision();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> experimental_features_;
  ::google::protobuf::internal::ArenaStringPtr preceding_text_;
  ::google::protobuf::internal::ArenaStringPtr following_text_;
  bool suppress_suggestion_;
  ::google::protobuf::int32 revision_;
  int input_field_type_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Capability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Capability) */ {
 public:
  Capability();
  virtual ~Capability();

  Capability(const Capability& from);

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capability(Capability&& from) noexcept
    : Capability() {
    *this = ::std::move(from);
  }

  inline Capability& operator=(Capability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capability* internal_default_instance() {
    return reinterpret_cast<const Capability*>(
               &_Capability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Capability* other);
  friend void swap(Capability& a, Capability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capability* New() const final {
    return CreateMaybeMessage<Capability>(NULL);
  }

  Capability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Capability_TextDeletionCapabilityType TextDeletionCapabilityType;
  static const TextDeletionCapabilityType NO_TEXT_DELETION_CAPABILITY =
    Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
  static const TextDeletionCapabilityType DELETE_PRECEDING_TEXT =
    Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
  static inline bool TextDeletionCapabilityType_IsValid(int value) {
    return Capability_TextDeletionCapabilityType_IsValid(value);
  }
  static const TextDeletionCapabilityType TextDeletionCapabilityType_MIN =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN;
  static const TextDeletionCapabilityType TextDeletionCapabilityType_MAX =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX;
  static const int TextDeletionCapabilityType_ARRAYSIZE =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextDeletionCapabilityType_descriptor() {
    return Capability_TextDeletionCapabilityType_descriptor();
  }
  static inline const ::std::string& TextDeletionCapabilityType_Name(TextDeletionCapabilityType value) {
    return Capability_TextDeletionCapabilityType_Name(value);
  }
  static inline bool TextDeletionCapabilityType_Parse(const ::std::string& name,
      TextDeletionCapabilityType* value) {
    return Capability_TextDeletionCapabilityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
  bool has_text_deletion() const;
  void clear_text_deletion();
  static const int kTextDeletionFieldNumber = 1;
  ::mozc::commands::Capability_TextDeletionCapabilityType text_deletion() const;
  void set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Capability)
 private:
  void set_has_text_deletion();
  void clear_has_text_deletion();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int text_deletion_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_SpecialRomanjiTable SpecialRomanjiTable;
  static const SpecialRomanjiTable DEFAULT_TABLE =
    Request_SpecialRomanjiTable_DEFAULT_TABLE;
  static const SpecialRomanjiTable TWELVE_KEYS_TO_HIRAGANA =
    Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA;
  static const SpecialRomanjiTable TWELVE_KEYS_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable FLICK_TO_HIRAGANA =
    Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA;
  static const SpecialRomanjiTable FLICK_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable TOGGLE_FLICK_TO_HIRAGANA =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA;
  static const SpecialRomanjiTable TOGGLE_FLICK_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable QWERTY_MOBILE_TO_HIRAGANA =
    Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA;
  static const SpecialRomanjiTable QWERTY_MOBILE_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable GODAN_TO_HIRAGANA =
    Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA;
  static const SpecialRomanjiTable GODAN_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable NOTOUCH_TO_HIRAGANA =
    Request_SpecialRomanjiTable_NOTOUCH_TO_HIRAGANA;
  static const SpecialRomanjiTable NOTOUCH_TO_HALFWIDTHASCII =
    Request_SpecialRomanjiTable_NOTOUCH_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable OBSOLETE_TWELVE_KEYS_TO_NUMBER =
    Request_SpecialRomanjiTable_OBSOLETE_TWELVE_KEYS_TO_NUMBER;
  static const SpecialRomanjiTable OBSOLETE_FLICK_TO_NUMBER =
    Request_SpecialRomanjiTable_OBSOLETE_FLICK_TO_NUMBER;
  static const SpecialRomanjiTable OBSOLETE_GODAN_TO_NUMBER =
    Request_SpecialRomanjiTable_OBSOLETE_GODAN_TO_NUMBER;
  static const SpecialRomanjiTable OBSOLETE_QWERTY_MOBILE_TO_HIRAGANA_NUMBER =
    Request_SpecialRomanjiTable_OBSOLETE_QWERTY_MOBILE_TO_HIRAGANA_NUMBER;
  static const SpecialRomanjiTable OBSOLETE_TOGGLE_FLICK_TO_NUMBER =
    Request_SpecialRomanjiTable_OBSOLETE_TOGGLE_FLICK_TO_NUMBER;
  static inline bool SpecialRomanjiTable_IsValid(int value) {
    return Request_SpecialRomanjiTable_IsValid(value);
  }
  static const SpecialRomanjiTable SpecialRomanjiTable_MIN =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN;
  static const SpecialRomanjiTable SpecialRomanjiTable_MAX =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX;
  static const int SpecialRomanjiTable_ARRAYSIZE =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpecialRomanjiTable_descriptor() {
    return Request_SpecialRomanjiTable_descriptor();
  }
  static inline const ::std::string& SpecialRomanjiTable_Name(SpecialRomanjiTable value) {
    return Request_SpecialRomanjiTable_Name(value);
  }
  static inline bool SpecialRomanjiTable_Parse(const ::std::string& name,
      SpecialRomanjiTable* value) {
    return Request_SpecialRomanjiTable_Parse(name, value);
  }

  typedef Request_SpaceOnAlphanumeric SpaceOnAlphanumeric;
  static const SpaceOnAlphanumeric SPACE_OR_CONVERT_KEEPING_COMPOSITION =
    Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
  static const SpaceOnAlphanumeric SPACE_OR_CONVERT_COMMITING_COMPOSITION =
    Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION;
  static const SpaceOnAlphanumeric COMMIT =
    Request_SpaceOnAlphanumeric_COMMIT;
  static inline bool SpaceOnAlphanumeric_IsValid(int value) {
    return Request_SpaceOnAlphanumeric_IsValid(value);
  }
  static const SpaceOnAlphanumeric SpaceOnAlphanumeric_MIN =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN;
  static const SpaceOnAlphanumeric SpaceOnAlphanumeric_MAX =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX;
  static const int SpaceOnAlphanumeric_ARRAYSIZE =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpaceOnAlphanumeric_descriptor() {
    return Request_SpaceOnAlphanumeric_descriptor();
  }
  static inline const ::std::string& SpaceOnAlphanumeric_Name(SpaceOnAlphanumeric value) {
    return Request_SpaceOnAlphanumeric_Name(value);
  }
  static inline bool SpaceOnAlphanumeric_Parse(const ::std::string& name,
      SpaceOnAlphanumeric* value) {
    return Request_SpaceOnAlphanumeric_Parse(name, value);
  }

  typedef Request_EmojiCarrierType EmojiCarrierType;
  static const EmojiCarrierType UNICODE_EMOJI =
    Request_EmojiCarrierType_UNICODE_EMOJI;
  static const EmojiCarrierType DOCOMO_EMOJI =
    Request_EmojiCarrierType_DOCOMO_EMOJI;
  static const EmojiCarrierType SOFTBANK_EMOJI =
    Request_EmojiCarrierType_SOFTBANK_EMOJI;
  static const EmojiCarrierType KDDI_EMOJI =
    Request_EmojiCarrierType_KDDI_EMOJI;
  static inline bool EmojiCarrierType_IsValid(int value) {
    return Request_EmojiCarrierType_IsValid(value);
  }
  static const EmojiCarrierType EmojiCarrierType_MIN =
    Request_EmojiCarrierType_EmojiCarrierType_MIN;
  static const EmojiCarrierType EmojiCarrierType_MAX =
    Request_EmojiCarrierType_EmojiCarrierType_MAX;
  static const int EmojiCarrierType_ARRAYSIZE =
    Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EmojiCarrierType_descriptor() {
    return Request_EmojiCarrierType_descriptor();
  }
  static inline const ::std::string& EmojiCarrierType_Name(EmojiCarrierType value) {
    return Request_EmojiCarrierType_Name(value);
  }
  static inline bool EmojiCarrierType_Parse(const ::std::string& name,
      EmojiCarrierType* value) {
    return Request_EmojiCarrierType_Parse(name, value);
  }

  typedef Request_RewriterCapability RewriterCapability;
  static const RewriterCapability NOT_AVAILABLE =
    Request_RewriterCapability_NOT_AVAILABLE;
  static const RewriterCapability CONVERSION =
    Request_RewriterCapability_CONVERSION;
  static const RewriterCapability PREDICTION =
    Request_RewriterCapability_PREDICTION;
  static const RewriterCapability SUGGESTION =
    Request_RewriterCapability_SUGGESTION;
  static const RewriterCapability ALL =
    Request_RewriterCapability_ALL;
  static inline bool RewriterCapability_IsValid(int value) {
    return Request_RewriterCapability_IsValid(value);
  }
  static const RewriterCapability RewriterCapability_MIN =
    Request_RewriterCapability_RewriterCapability_MIN;
  static const RewriterCapability RewriterCapability_MAX =
    Request_RewriterCapability_RewriterCapability_MAX;
  static const int RewriterCapability_ARRAYSIZE =
    Request_RewriterCapability_RewriterCapability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RewriterCapability_descriptor() {
    return Request_RewriterCapability_descriptor();
  }
  static inline const ::std::string& RewriterCapability_Name(RewriterCapability value) {
    return Request_RewriterCapability_Name(value);
  }
  static inline bool RewriterCapability_Parse(const ::std::string& name,
      RewriterCapability* value) {
    return Request_RewriterCapability_Parse(name, value);
  }

  typedef Request_CrossingEdgeBehavior CrossingEdgeBehavior;
  static const CrossingEdgeBehavior DO_NOTHING =
    Request_CrossingEdgeBehavior_DO_NOTHING;
  static const CrossingEdgeBehavior COMMIT_WITHOUT_CONSUMING =
    Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
  static inline bool CrossingEdgeBehavior_IsValid(int value) {
    return Request_CrossingEdgeBehavior_IsValid(value);
  }
  static const CrossingEdgeBehavior CrossingEdgeBehavior_MIN =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN;
  static const CrossingEdgeBehavior CrossingEdgeBehavior_MAX =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX;
  static const int CrossingEdgeBehavior_ARRAYSIZE =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CrossingEdgeBehavior_descriptor() {
    return Request_CrossingEdgeBehavior_descriptor();
  }
  static inline const ::std::string& CrossingEdgeBehavior_Name(CrossingEdgeBehavior value) {
    return Request_CrossingEdgeBehavior_Name(value);
  }
  static inline bool CrossingEdgeBehavior_Parse(const ::std::string& name,
      CrossingEdgeBehavior* value) {
    return Request_CrossingEdgeBehavior_Parse(name, value);
  }

  typedef Request_LanguageAwareInputBehavior LanguageAwareInputBehavior;
  static const LanguageAwareInputBehavior DEFAULT_LANGUAGE_AWARE_BEHAVIOR =
    Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
  static const LanguageAwareInputBehavior NO_LANGUAGE_AWARE_INPUT =
    Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT;
  static const LanguageAwareInputBehavior LANGUAGE_AWARE_SUGGESTION =
    Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
  static inline bool LanguageAwareInputBehavior_IsValid(int value) {
    return Request_LanguageAwareInputBehavior_IsValid(value);
  }
  static const LanguageAwareInputBehavior LanguageAwareInputBehavior_MIN =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN;
  static const LanguageAwareInputBehavior LanguageAwareInputBehavior_MAX =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX;
  static const int LanguageAwareInputBehavior_ARRAYSIZE =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LanguageAwareInputBehavior_descriptor() {
    return Request_LanguageAwareInputBehavior_descriptor();
  }
  static inline const ::std::string& LanguageAwareInputBehavior_Name(LanguageAwareInputBehavior value) {
    return Request_LanguageAwareInputBehavior_Name(value);
  }
  static inline bool LanguageAwareInputBehavior_Parse(const ::std::string& name,
      LanguageAwareInputBehavior* value) {
    return Request_LanguageAwareInputBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string keyboard_name = 7;
  bool has_keyboard_name() const;
  void clear_keyboard_name();
  static const int kKeyboardNameFieldNumber = 7;
  const ::std::string& keyboard_name() const;
  void set_keyboard_name(const ::std::string& value);
  #if LANG_CXX11
  void set_keyboard_name(::std::string&& value);
  #endif
  void set_keyboard_name(const char* value);
  void set_keyboard_name(const char* value, size_t size);
  ::std::string* mutable_keyboard_name();
  ::std::string* release_keyboard_name();
  void set_allocated_keyboard_name(::std::string* keyboard_name);

  // optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
  bool has_special_romanji_table() const;
  void clear_special_romanji_table();
  static const int kSpecialRomanjiTableFieldNumber = 4;
  ::mozc::commands::Request_SpecialRomanjiTable special_romanji_table() const;
  void set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value);

  // optional bool zero_query_suggestion = 1 [default = false];
  bool has_zero_query_suggestion() const;
  void clear_zero_query_suggestion();
  static const int kZeroQuerySuggestionFieldNumber = 1;
  bool zero_query_suggestion() const;
  void set_zero_query_suggestion(bool value);

  // optional bool mixed_conversion = 2 [default = false];
  bool has_mixed_conversion() const;
  void clear_mixed_conversion();
  static const int kMixedConversionFieldNumber = 2;
  bool mixed_conversion() const;
  void set_mixed_conversion(bool value);

  // optional bool kana_modifier_insensitive_conversion = 9 [default = false];
  bool has_kana_modifier_insensitive_conversion() const;
  void clear_kana_modifier_insensitive_conversion();
  static const int kKanaModifierInsensitiveConversionFieldNumber = 9;
  bool kana_modifier_insensitive_conversion() const;
  void set_kana_modifier_insensitive_conversion(bool value);

  // optional bool auto_partial_suggestion = 10 [default = false];
  bool has_auto_partial_suggestion() const;
  void clear_auto_partial_suggestion();
  static const int kAutoPartialSuggestionFieldNumber = 10;
  bool auto_partial_suggestion() const;
  void set_auto_partial_suggestion(bool value);

  // optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
  bool has_space_on_alphanumeric() const;
  void clear_space_on_alphanumeric();
  static const int kSpaceOnAlphanumericFieldNumber = 6;
  ::mozc::commands::Request_SpaceOnAlphanumeric space_on_alphanumeric() const;
  void set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value);

  // optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
  bool has_crossing_edge_behavior() const;
  void clear_crossing_edge_behavior();
  static const int kCrossingEdgeBehaviorFieldNumber = 13;
  ::mozc::commands::Request_CrossingEdgeBehavior crossing_edge_behavior() const;
  void set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value);

  // optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
  bool has_language_aware_input() const;
  void clear_language_aware_input();
  static const int kLanguageAwareInputFieldNumber = 14;
  ::mozc::commands::Request_LanguageAwareInputBehavior language_aware_input() const;
  void set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value);

  // optional int32 candidates_size_limit = 16;
  bool has_candidates_size_limit() const;
  void clear_candidates_size_limit();
  static const int kCandidatesSizeLimitFieldNumber = 16;
  ::google::protobuf::int32 candidates_size_limit() const;
  void set_candidates_size_limit(::google::protobuf::int32 value);

  // optional bool update_input_mode_from_surrounding_text = 8 [default = true];
  bool has_update_input_mode_from_surrounding_text() const;
  void clear_update_input_mode_from_surrounding_text();
  static const int kUpdateInputModeFromSurroundingTextFieldNumber = 8;
  bool update_input_mode_from_surrounding_text() const;
  void set_update_input_mode_from_surrounding_text(bool value);

  // optional int32 available_emoji_carrier = 11 [default = 1];
  bool has_available_emoji_carrier() const;
  void clear_available_emoji_carrier();
  static const int kAvailableEmojiCarrierFieldNumber = 11;
  ::google::protobuf::int32 available_emoji_carrier() const;
  void set_available_emoji_carrier(::google::protobuf::int32 value);

  // optional int32 emoji_rewriter_capability = 12 [default = 1];
  bool has_emoji_rewriter_capability() const;
  void clear_emoji_rewriter_capability();
  static const int kEmojiRewriterCapabilityFieldNumber = 12;
  ::google::protobuf::int32 emoji_rewriter_capability() const;
  void set_emoji_rewriter_capability(::google::protobuf::int32 value);

  // optional int32 candidate_page_size = 15 [default = 9];
  bool has_candidate_page_size() const;
  void clear_candidate_page_size();
  static const int kCandidatePageSizeFieldNumber = 15;
  ::google::protobuf::int32 candidate_page_size() const;
  void set_candidate_page_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Request)
 private:
  void set_has_zero_query_suggestion();
  void clear_has_zero_query_suggestion();
  void set_has_mixed_conversion();
  void clear_has_mixed_conversion();
  void set_has_special_romanji_table();
  void clear_has_special_romanji_table();
  void set_has_space_on_alphanumeric();
  void clear_has_space_on_alphanumeric();
  void set_has_keyboard_name();
  void clear_has_keyboard_name();
  void set_has_update_input_mode_from_surrounding_text();
  void clear_has_update_input_mode_from_surrounding_text();
  void set_has_kana_modifier_insensitive_conversion();
  void clear_has_kana_modifier_insensitive_conversion();
  void set_has_auto_partial_suggestion();
  void clear_has_auto_partial_suggestion();
  void set_has_available_emoji_carrier();
  void clear_has_available_emoji_carrier();
  void set_has_emoji_rewriter_capability();
  void clear_has_emoji_rewriter_capability();
  void set_has_crossing_edge_behavior();
  void clear_has_crossing_edge_behavior();
  void set_has_language_aware_input();
  void clear_has_language_aware_input();
  void set_has_candidate_page_size();
  void clear_has_candidate_page_size();
  void set_has_candidates_size_limit();
  void clear_has_candidates_size_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keyboard_name_;
  int special_romanji_table_;
  bool zero_query_suggestion_;
  bool mixed_conversion_;
  bool kana_modifier_insensitive_conversion_;
  bool auto_partial_suggestion_;
  int space_on_alphanumeric_;
  int crossing_edge_behavior_;
  int language_aware_input_;
  ::google::protobuf::int32 candidates_size_limit_;
  bool update_input_mode_from_surrounding_text_;
  ::google::protobuf::int32 available_emoji_carrier_;
  ::google::protobuf::int32 emoji_rewriter_capability_;
  ::google::protobuf::int32 candidate_page_size_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplicationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.ApplicationInfo) */ {
 public:
  ApplicationInfo();
  virtual ~ApplicationInfo();

  ApplicationInfo(const ApplicationInfo& from);

  inline ApplicationInfo& operator=(const ApplicationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApplicationInfo(ApplicationInfo&& from) noexcept
    : ApplicationInfo() {
    *this = ::std::move(from);
  }

  inline ApplicationInfo& operator=(ApplicationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplicationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplicationInfo* internal_default_instance() {
    return reinterpret_cast<const ApplicationInfo*>(
               &_ApplicationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ApplicationInfo* other);
  friend void swap(ApplicationInfo& a, ApplicationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApplicationInfo* New() const final {
    return CreateMaybeMessage<ApplicationInfo>(NULL);
  }

  ApplicationInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApplicationInfo& from);
  void MergeFrom(const ApplicationInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 process_id = 1;
  bool has_process_id() const;
  void clear_process_id();
  static const int kProcessIdFieldNumber = 1;
  ::google::protobuf::uint32 process_id() const;
  void set_process_id(::google::protobuf::uint32 value);

  // optional uint32 thread_id = 2;
  bool has_thread_id() const;
  void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  ::google::protobuf::uint32 thread_id() const;
  void set_thread_id(::google::protobuf::uint32 value);

  // optional int32 timezone_offset = 3;
  bool has_timezone_offset() const;
  void clear_timezone_offset();
  static const int kTimezoneOffsetFieldNumber = 3;
  ::google::protobuf::int32 timezone_offset() const;
  void set_timezone_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.ApplicationInfo)
 private:
  void set_has_process_id();
  void clear_has_process_id();
  void set_has_thread_id();
  void clear_has_thread_id();
  void set_has_timezone_offset();
  void clear_has_timezone_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 process_id_;
  ::google::protobuf::uint32 thread_id_;
  ::google::protobuf::int32 timezone_offset_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input_TouchPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input.TouchPosition) */ {
 public:
  Input_TouchPosition();
  virtual ~Input_TouchPosition();

  Input_TouchPosition(const Input_TouchPosition& from);

  inline Input_TouchPosition& operator=(const Input_TouchPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input_TouchPosition(Input_TouchPosition&& from) noexcept
    : Input_TouchPosition() {
    *this = ::std::move(from);
  }

  inline Input_TouchPosition& operator=(Input_TouchPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_TouchPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_TouchPosition* internal_default_instance() {
    return reinterpret_cast<const Input_TouchPosition*>(
               &_Input_TouchPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Input_TouchPosition* other);
  friend void swap(Input_TouchPosition& a, Input_TouchPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input_TouchPosition* New() const final {
    return CreateMaybeMessage<Input_TouchPosition>(NULL);
  }

  Input_TouchPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input_TouchPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input_TouchPosition& from);
  void MergeFrom(const Input_TouchPosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input_TouchPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // optional float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // optional int64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional .mozc.commands.Input.TouchAction action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::mozc::commands::Input_TouchAction action() const;
  void set_action(::mozc::commands::Input_TouchAction value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchPosition)
 private:
  void set_has_action();
  void clear_has_action();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  ::google::protobuf::int64 timestamp_;
  int action_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input_TouchEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input.TouchEvent) */ {
 public:
  Input_TouchEvent();
  virtual ~Input_TouchEvent();

  Input_TouchEvent(const Input_TouchEvent& from);

  inline Input_TouchEvent& operator=(const Input_TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input_TouchEvent(Input_TouchEvent&& from) noexcept
    : Input_TouchEvent() {
    *this = ::std::move(from);
  }

  inline Input_TouchEvent& operator=(Input_TouchEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_TouchEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_TouchEvent* internal_default_instance() {
    return reinterpret_cast<const Input_TouchEvent*>(
               &_Input_TouchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Input_TouchEvent* other);
  friend void swap(Input_TouchEvent& a, Input_TouchEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input_TouchEvent* New() const final {
    return CreateMaybeMessage<Input_TouchEvent>(NULL);
  }

  Input_TouchEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input_TouchEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input_TouchEvent& from);
  void MergeFrom(const Input_TouchEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input_TouchEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.Input.TouchPosition stroke = 2;
  int stroke_size() const;
  void clear_stroke();
  static const int kStrokeFieldNumber = 2;
  ::mozc::commands::Input_TouchPosition* mutable_stroke(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
      mutable_stroke();
  const ::mozc::commands::Input_TouchPosition& stroke(int index) const;
  ::mozc::commands::Input_TouchPosition* add_stroke();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
      stroke() const;

  // optional uint32 source_id = 1;
  bool has_source_id() const;
  void clear_source_id();
  static const int kSourceIdFieldNumber = 1;
  ::google::protobuf::uint32 source_id() const;
  void set_source_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchEvent)
 private:
  void set_has_source_id();
  void clear_has_source_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition > stroke_;
  ::google::protobuf::uint32 source_id_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Input) */ {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Input* other);
  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(NULL);
  }

  Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Input_TouchPosition TouchPosition;
  typedef Input_TouchEvent TouchEvent;

  typedef Input_CommandType CommandType;
  static const CommandType NONE =
    Input_CommandType_NONE;
  static const CommandType CREATE_SESSION =
    Input_CommandType_CREATE_SESSION;
  static const CommandType DELETE_SESSION =
    Input_CommandType_DELETE_SESSION;
  static const CommandType SEND_KEY =
    Input_CommandType_SEND_KEY;
  static const CommandType TEST_SEND_KEY =
    Input_CommandType_TEST_SEND_KEY;
  static const CommandType SEND_COMMAND =
    Input_CommandType_SEND_COMMAND;
  static const CommandType GET_CONFIG =
    Input_CommandType_GET_CONFIG;
  static const CommandType SET_CONFIG =
    Input_CommandType_SET_CONFIG;
  static const CommandType SET_IMPOSED_CONFIG =
    Input_CommandType_SET_IMPOSED_CONFIG;
  static const CommandType SET_REQUEST =
    Input_CommandType_SET_REQUEST;
  static const CommandType SYNC_DATA =
    Input_CommandType_SYNC_DATA;
  static const CommandType SHUTDOWN =
    Input_CommandType_SHUTDOWN;
  static const CommandType RELOAD =
    Input_CommandType_RELOAD;
  static const CommandType CLEAR_USER_HISTORY =
    Input_CommandType_CLEAR_USER_HISTORY;
  static const CommandType CLEAR_USER_PREDICTION =
    Input_CommandType_CLEAR_USER_PREDICTION;
  static const CommandType CLEAR_UNUSED_USER_PREDICTION =
    Input_CommandType_CLEAR_UNUSED_USER_PREDICTION;
  static const CommandType CLEANUP =
    Input_CommandType_CLEANUP;
  static const CommandType NO_OPERATION =
    Input_CommandType_NO_OPERATION;
  static const CommandType OBSOLETE_START_CLOUD_SYNC =
    Input_CommandType_OBSOLETE_START_CLOUD_SYNC;
  static const CommandType OBSOLETE_GET_CLOUD_SYNC_STATUS =
    Input_CommandType_OBSOLETE_GET_CLOUD_SYNC_STATUS;
  static const CommandType OBSOLETE_ADD_AUTH_CODE =
    Input_CommandType_OBSOLETE_ADD_AUTH_CODE;
  static const CommandType INSERT_TO_STORAGE =
    Input_CommandType_INSERT_TO_STORAGE;
  static const CommandType READ_ALL_FROM_STORAGE =
    Input_CommandType_READ_ALL_FROM_STORAGE;
  static const CommandType CLEAR_STORAGE =
    Input_CommandType_CLEAR_STORAGE;
  static const CommandType SEND_USER_DICTIONARY_COMMAND =
    Input_CommandType_SEND_USER_DICTIONARY_COMMAND;
  static const CommandType SEND_ENGINE_RELOAD_REQUEST =
    Input_CommandType_SEND_ENGINE_RELOAD_REQUEST;
  static const CommandType NUM_OF_COMMANDS =
    Input_CommandType_NUM_OF_COMMANDS;
  static inline bool CommandType_IsValid(int value) {
    return Input_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Input_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Input_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Input_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Input_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Input_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Input_CommandType_Parse(name, value);
  }

  typedef Input_TouchAction TouchAction;
  static const TouchAction TOUCH_DOWN =
    Input_TouchAction_TOUCH_DOWN;
  static const TouchAction TOUCH_MOVE =
    Input_TouchAction_TOUCH_MOVE;
  static const TouchAction TOUCH_UP =
    Input_TouchAction_TOUCH_UP;
  static inline bool TouchAction_IsValid(int value) {
    return Input_TouchAction_IsValid(value);
  }
  static const TouchAction TouchAction_MIN =
    Input_TouchAction_TouchAction_MIN;
  static const TouchAction TouchAction_MAX =
    Input_TouchAction_TouchAction_MAX;
  static const int TouchAction_ARRAYSIZE =
    Input_TouchAction_TouchAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TouchAction_descriptor() {
    return Input_TouchAction_descriptor();
  }
  static inline const ::std::string& TouchAction_Name(TouchAction value) {
    return Input_TouchAction_Name(value);
  }
  static inline bool TouchAction_Parse(const ::std::string& name,
      TouchAction* value) {
    return Input_TouchAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.Input.TouchEvent touch_events = 12;
  int touch_events_size() const;
  void clear_touch_events();
  static const int kTouchEventsFieldNumber = 12;
  ::mozc::commands::Input_TouchEvent* mutable_touch_events(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
      mutable_touch_events();
  const ::mozc::commands::Input_TouchEvent& touch_events(int index) const;
  ::mozc::commands::Input_TouchEvent* add_touch_events();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
      touch_events() const;

  // optional .mozc.commands.KeyEvent key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  private:
  const ::mozc::commands::KeyEvent& _internal_key() const;
  public:
  const ::mozc::commands::KeyEvent& key() const;
  ::mozc::commands::KeyEvent* release_key();
  ::mozc::commands::KeyEvent* mutable_key();
  void set_allocated_key(::mozc::commands::KeyEvent* key);

  // optional .mozc.commands.SessionCommand command = 4;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 4;
  private:
  const ::mozc::commands::SessionCommand& _internal_command() const;
  public:
  const ::mozc::commands::SessionCommand& command() const;
  ::mozc::commands::SessionCommand* release_command();
  ::mozc::commands::SessionCommand* mutable_command();
  void set_allocated_command(::mozc::commands::SessionCommand* command);

  // optional .mozc.config.Config config = 5;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 5;
  private:
  const ::mozc::config::Config& _internal_config() const;
  public:
  const ::mozc::config::Config& config() const;
  ::mozc::config::Config* release_config();
  ::mozc::config::Config* mutable_config();
  void set_allocated_config(::mozc::config::Config* config);

  // optional .mozc.commands.Context context = 6;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 6;
  private:
  const ::mozc::commands::Context& _internal_context() const;
  public:
  const ::mozc::commands::Context& context() const;
  ::mozc::commands::Context* release_context();
  ::mozc::commands::Context* mutable_context();
  void set_allocated_context(::mozc::commands::Context* context);

  // optional .mozc.commands.Capability capability = 7;
  bool has_capability() const;
  void clear_capability();
  static const int kCapabilityFieldNumber = 7;
  private:
  const ::mozc::commands::Capability& _internal_capability() const;
  public:
  const ::mozc::commands::Capability& capability() const;
  ::mozc::commands::Capability* release_capability();
  ::mozc::commands::Capability* mutable_capability();
  void set_allocated_capability(::mozc::commands::Capability* capability);

  // optional .mozc.commands.ApplicationInfo application_info = 8;
  bool has_application_info() const;
  void clear_application_info();
  static const int kApplicationInfoFieldNumber = 8;
  private:
  const ::mozc::commands::ApplicationInfo& _internal_application_info() const;
  public:
  const ::mozc::commands::ApplicationInfo& application_info() const;
  ::mozc::commands::ApplicationInfo* release_application_info();
  ::mozc::commands::ApplicationInfo* mutable_application_info();
  void set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info);

  // optional .mozc.commands.Request request = 9;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 9;
  private:
  const ::mozc::commands::Request& _internal_request() const;
  public:
  const ::mozc::commands::Request& request() const;
  ::mozc::commands::Request* release_request();
  ::mozc::commands::Request* mutable_request();
  void set_allocated_request(::mozc::commands::Request* request);

  // optional .mozc.commands.GenericStorageEntry storage_entry = 10;
  bool has_storage_entry() const;
  void clear_storage_entry();
  static const int kStorageEntryFieldNumber = 10;
  private:
  const ::mozc::commands::GenericStorageEntry& _internal_storage_entry() const;
  public:
  const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  ::mozc::commands::GenericStorageEntry* release_storage_entry();
  ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);

  // optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
  bool has_user_dictionary_command() const;
  void clear_user_dictionary_command();
  static const int kUserDictionaryCommandFieldNumber = 13;
  private:
  const ::mozc::user_dictionary::UserDictionaryCommand& _internal_user_dictionary_command() const;
  public:
  const ::mozc::user_dictionary::UserDictionaryCommand& user_dictionary_command() const;
  ::mozc::user_dictionary::UserDictionaryCommand* release_user_dictionary_command();
  ::mozc::user_dictionary::UserDictionaryCommand* mutable_user_dictionary_command();
  void set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command);

  // optional .mozc.EngineReloadRequest engine_reload_request = 15;
  bool has_engine_reload_request() const;
  void clear_engine_reload_request();
  static const int kEngineReloadRequestFieldNumber = 15;
  private:
  const ::mozc::EngineReloadRequest& _internal_engine_reload_request() const;
  public:
  const ::mozc::EngineReloadRequest& engine_reload_request() const;
  ::mozc::EngineReloadRequest* release_engine_reload_request();
  ::mozc::EngineReloadRequest* mutable_engine_reload_request();
  void set_allocated_engine_reload_request(::mozc::EngineReloadRequest* engine_reload_request);

  // optional uint64 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required .mozc.commands.Input.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mozc::commands::Input_CommandType type() const;
  void set_type(::mozc::commands::Input_CommandType value);

  // optional bool request_suggestion = 14 [default = true];
  bool has_request_suggestion() const;
  void clear_request_suggestion();
  static const int kRequestSuggestionFieldNumber = 14;
  bool request_suggestion() const;
  void set_request_suggestion(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Input)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();
  void set_has_key();
  void clear_has_key();
  void set_has_command();
  void clear_has_command();
  void set_has_config();
  void clear_has_config();
  void set_has_context();
  void clear_has_context();
  void set_has_capability();
  void clear_has_capability();
  void set_has_application_info();
  void clear_has_application_info();
  void set_has_request();
  void clear_has_request();
  void set_has_storage_entry();
  void clear_has_storage_entry();
  void set_has_user_dictionary_command();
  void clear_has_user_dictionary_command();
  void set_has_request_suggestion();
  void clear_has_request_suggestion();
  void set_has_engine_reload_request();
  void clear_has_engine_reload_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent > touch_events_;
  ::mozc::commands::KeyEvent* key_;
  ::mozc::commands::SessionCommand* command_;
  ::mozc::config::Config* config_;
  ::mozc::commands::Context* context_;
  ::mozc::commands::Capability* capability_;
  ::mozc::commands::ApplicationInfo* application_info_;
  ::mozc::commands::Request* request_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command_;
  ::mozc::EngineReloadRequest* engine_reload_request_;
  ::google::protobuf::uint64 id_;
  int type_;
  bool request_suggestion_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Result* other);
  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(NULL);
  }

  Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Result_ResultType ResultType;
  static const ResultType NONE =
    Result_ResultType_NONE;
  static const ResultType STRING =
    Result_ResultType_STRING;
  static inline bool ResultType_IsValid(int value) {
    return Result_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    Result_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    Result_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    Result_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return Result_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return Result_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return Result_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional string key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .mozc.commands.Result.ResultType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mozc::commands::Result_ResultType type() const;
  void set_type(::mozc::commands::Result_ResultType value);

  // optional int32 cursor_offset = 4 [default = 0];
  bool has_cursor_offset() const;
  void clear_cursor_offset();
  static const int kCursorOffsetFieldNumber = 4;
  ::google::protobuf::int32 cursor_offset() const;
  void set_cursor_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Result)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();
  void set_has_key();
  void clear_has_key();
  void set_has_cursor_offset();
  void clear_has_cursor_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int type_;
  ::google::protobuf::int32 cursor_offset_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Preedit_Segment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Preedit.Segment) */ {
 public:
  Preedit_Segment();
  virtual ~Preedit_Segment();

  Preedit_Segment(const Preedit_Segment& from);

  inline Preedit_Segment& operator=(const Preedit_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Preedit_Segment(Preedit_Segment&& from) noexcept
    : Preedit_Segment() {
    *this = ::std::move(from);
  }

  inline Preedit_Segment& operator=(Preedit_Segment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Preedit_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Preedit_Segment* internal_default_instance() {
    return reinterpret_cast<const Preedit_Segment*>(
               &_Preedit_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Preedit_Segment* other);
  friend void swap(Preedit_Segment& a, Preedit_Segment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Preedit_Segment* New() const final {
    return CreateMaybeMessage<Preedit_Segment>(NULL);
  }

  Preedit_Segment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Preedit_Segment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Preedit_Segment& from);
  void MergeFrom(const Preedit_Segment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Preedit_Segment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Preedit_Segment_Annotation Annotation;
  static const Annotation NONE =
    Preedit_Segment_Annotation_NONE;
  static const Annotation UNDERLINE =
    Preedit_Segment_Annotation_UNDERLINE;
  static const Annotation HIGHLIGHT =
    Preedit_Segment_Annotation_HIGHLIGHT;
  static inline bool Annotation_IsValid(int value) {
    return Preedit_Segment_Annotation_IsValid(value);
  }
  static const Annotation Annotation_MIN =
    Preedit_Segment_Annotation_Annotation_MIN;
  static const Annotation Annotation_MAX =
    Preedit_Segment_Annotation_Annotation_MAX;
  static const int Annotation_ARRAYSIZE =
    Preedit_Segment_Annotation_Annotation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Annotation_descriptor() {
    return Preedit_Segment_Annotation_descriptor();
  }
  static inline const ::std::string& Annotation_Name(Annotation value) {
    return Preedit_Segment_Annotation_Name(value);
  }
  static inline bool Annotation_Parse(const ::std::string& name,
      Annotation* value) {
    return Preedit_Segment_Annotation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional string key = 6;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 3;
  ::mozc::commands::Preedit_Segment_Annotation annotation() const;
  void set_annotation(::mozc::commands::Preedit_Segment_Annotation value);

  // required uint32 value_length = 5;
  bool has_value_length() const;
  void clear_value_length();
  static const int kValueLengthFieldNumber = 5;
  ::google::protobuf::uint32 value_length() const;
  void set_value_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit.Segment)
 private:
  void set_has_annotation();
  void clear_has_annotation();
  void set_has_value();
  void clear_has_value();
  void set_has_value_length();
  void clear_has_value_length();
  void set_has_key();
  void clear_has_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int annotation_;
  ::google::protobuf::uint32 value_length_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Preedit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Preedit) */ {
 public:
  Preedit();
  virtual ~Preedit();

  Preedit(const Preedit& from);

  inline Preedit& operator=(const Preedit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Preedit(Preedit&& from) noexcept
    : Preedit() {
    *this = ::std::move(from);
  }

  inline Preedit& operator=(Preedit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Preedit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Preedit* internal_default_instance() {
    return reinterpret_cast<const Preedit*>(
               &_Preedit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Preedit* other);
  friend void swap(Preedit& a, Preedit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Preedit* New() const final {
    return CreateMaybeMessage<Preedit>(NULL);
  }

  Preedit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Preedit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Preedit& from);
  void MergeFrom(const Preedit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Preedit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Preedit_Segment Segment;

  // accessors -------------------------------------------------------

  // repeated group Segment = 2 { ... };
  int segment_size() const;
  void clear_segment();
  static const int kSegmentFieldNumber = 2;
  ::mozc::commands::Preedit_Segment* mutable_segment(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
      mutable_segment();
  const ::mozc::commands::Preedit_Segment& segment(int index) const;
  ::mozc::commands::Preedit_Segment* add_segment();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
      segment() const;

  // required uint32 cursor = 1;
  bool has_cursor() const;
  void clear_cursor();
  static const int kCursorFieldNumber = 1;
  ::google::protobuf::uint32 cursor() const;
  void set_cursor(::google::protobuf::uint32 value);

  // optional uint32 highlighted_position = 3;
  bool has_highlighted_position() const;
  void clear_highlighted_position();
  static const int kHighlightedPositionFieldNumber = 3;
  ::google::protobuf::uint32 highlighted_position() const;
  void set_highlighted_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit)
 private:
  void set_has_cursor();
  void clear_has_cursor();
  void set_has_highlighted_position();
  void clear_has_highlighted_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment > segment_;
  ::google::protobuf::uint32 cursor_;
  ::google::protobuf::uint32 highlighted_position_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool activated = 1;
  bool has_activated() const;
  void clear_activated();
  static const int kActivatedFieldNumber = 1;
  bool activated() const;
  void set_activated(bool value);

  // optional .mozc.commands.CompositionMode mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);

  // optional .mozc.commands.CompositionMode comeback_mode = 3;
  bool has_comeback_mode() const;
  void clear_comeback_mode();
  static const int kComebackModeFieldNumber = 3;
  ::mozc::commands::CompositionMode comeback_mode() const;
  void set_comeback_mode(::mozc::commands::CompositionMode value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Status)
 private:
  void set_has_activated();
  void clear_has_activated();
  void set_has_mode();
  void clear_has_mode();
  void set_has_comeback_mode();
  void clear_has_comeback_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool activated_;
  int mode_;
  int comeback_mode_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeletionRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.DeletionRange) */ {
 public:
  DeletionRange();
  virtual ~DeletionRange();

  DeletionRange(const DeletionRange& from);

  inline DeletionRange& operator=(const DeletionRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeletionRange(DeletionRange&& from) noexcept
    : DeletionRange() {
    *this = ::std::move(from);
  }

  inline DeletionRange& operator=(DeletionRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeletionRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeletionRange* internal_default_instance() {
    return reinterpret_cast<const DeletionRange*>(
               &_DeletionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DeletionRange* other);
  friend void swap(DeletionRange& a, DeletionRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeletionRange* New() const final {
    return CreateMaybeMessage<DeletionRange>(NULL);
  }

  DeletionRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeletionRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeletionRange& from);
  void MergeFrom(const DeletionRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletionRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // optional int32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::int32 length() const;
  void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.DeletionRange)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_length();
  void clear_has_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 length_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output_Callback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Output.Callback) */ {
 public:
  Output_Callback();
  virtual ~Output_Callback();

  Output_Callback(const Output_Callback& from);

  inline Output_Callback& operator=(const Output_Callback& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output_Callback(Output_Callback&& from) noexcept
    : Output_Callback() {
    *this = ::std::move(from);
  }

  inline Output_Callback& operator=(Output_Callback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output_Callback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output_Callback* internal_default_instance() {
    return reinterpret_cast<const Output_Callback*>(
               &_Output_Callback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Output_Callback* other);
  friend void swap(Output_Callback& a, Output_Callback& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output_Callback* New() const final {
    return CreateMaybeMessage<Output_Callback>(NULL);
  }

  Output_Callback* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output_Callback>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output_Callback& from);
  void MergeFrom(const Output_Callback& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output_Callback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozc.commands.SessionCommand session_command = 1;
  bool has_session_command() const;
  void clear_session_command();
  static const int kSessionCommandFieldNumber = 1;
  private:
  const ::mozc::commands::SessionCommand& _internal_session_command() const;
  public:
  const ::mozc::commands::SessionCommand& session_command() const;
  ::mozc::commands::SessionCommand* release_session_command();
  ::mozc::commands::SessionCommand* mutable_session_command();
  void set_allocated_session_command(::mozc::commands::SessionCommand* session_command);

  // optional uint32 delay_millisec = 2;
  bool has_delay_millisec() const;
  void clear_delay_millisec();
  static const int kDelayMillisecFieldNumber = 2;
  ::google::protobuf::uint32 delay_millisec() const;
  void set_delay_millisec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Output.Callback)
 private:
  void set_has_session_command();
  void clear_has_session_command();
  void set_has_delay_millisec();
  void clear_has_delay_millisec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mozc::commands::SessionCommand* session_command_;
  ::google::protobuf::uint32 delay_millisec_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(NULL);
  }

  Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Output_Callback Callback;

  typedef Output_PreeditMethod PreeditMethod;
  static const PreeditMethod ASCII =
    Output_PreeditMethod_ASCII;
  static const PreeditMethod KANA =
    Output_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Output_PreeditMethod_IsValid(value);
  }
  static const PreeditMethod PreeditMethod_MIN =
    Output_PreeditMethod_PreeditMethod_MIN;
  static const PreeditMethod PreeditMethod_MAX =
    Output_PreeditMethod_PreeditMethod_MAX;
  static const int PreeditMethod_ARRAYSIZE =
    Output_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Output_PreeditMethod_descriptor();
  }
  static inline const ::std::string& PreeditMethod_Name(PreeditMethod value) {
    return Output_PreeditMethod_Name(value);
  }
  static inline bool PreeditMethod_Parse(const ::std::string& name,
      PreeditMethod* value) {
    return Output_PreeditMethod_Parse(name, value);
  }

  typedef Output_ErrorCode ErrorCode;
  static const ErrorCode SESSION_SUCCESS =
    Output_ErrorCode_SESSION_SUCCESS;
  static const ErrorCode SESSION_FAILURE =
    Output_ErrorCode_SESSION_FAILURE;
  static inline bool ErrorCode_IsValid(int value) {
    return Output_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    Output_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    Output_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    Output_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return Output_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return Output_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return Output_ErrorCode_Parse(name, value);
  }

  typedef Output_ToolMode ToolMode;
  static const ToolMode NO_TOOL =
    Output_ToolMode_NO_TOOL;
  static const ToolMode CONFIG_DIALOG =
    Output_ToolMode_CONFIG_DIALOG;
  static const ToolMode DICTIONARY_TOOL =
    Output_ToolMode_DICTIONARY_TOOL;
  static const ToolMode WORD_REGISTER_DIALOG =
    Output_ToolMode_WORD_REGISTER_DIALOG;
  static inline bool ToolMode_IsValid(int value) {
    return Output_ToolMode_IsValid(value);
  }
  static const ToolMode ToolMode_MIN =
    Output_ToolMode_ToolMode_MIN;
  static const ToolMode ToolMode_MAX =
    Output_ToolMode_ToolMode_MAX;
  static const int ToolMode_ARRAYSIZE =
    Output_ToolMode_ToolMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ToolMode_descriptor() {
    return Output_ToolMode_descriptor();
  }
  static inline const ::std::string& ToolMode_Name(ToolMode value) {
    return Output_ToolMode_Name(value);
  }
  static inline bool ToolMode_Parse(const ::std::string& name,
      ToolMode* value) {
    return Output_ToolMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string url = 8;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 8;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .mozc.commands.Result result = 4;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 4;
  private:
  const ::mozc::commands::Result& _internal_result() const;
  public:
  const ::mozc::commands::Result& result() const;
  ::mozc::commands::Result* release_result();
  ::mozc::commands::Result* mutable_result();
  void set_allocated_result(::mozc::commands::Result* result);

  // optional .mozc.commands.Preedit preedit = 5;
  bool has_preedit() const;
  void clear_preedit();
  static const int kPreeditFieldNumber = 5;
  private:
  const ::mozc::commands::Preedit& _internal_preedit() const;
  public:
  const ::mozc::commands::Preedit& preedit() const;
  ::mozc::commands::Preedit* release_preedit();
  ::mozc::commands::Preedit* mutable_preedit();
  void set_allocated_preedit(::mozc::commands::Preedit* preedit);

  // optional .mozc.commands.Candidates candidates = 6;
  bool has_candidates() const;
  void clear_candidates();
  static const int kCandidatesFieldNumber = 6;
  private:
  const ::mozc::commands::Candidates& _internal_candidates() const;
  public:
  const ::mozc::commands::Candidates& candidates() const;
  ::mozc::commands::Candidates* release_candidates();
  ::mozc::commands::Candidates* mutable_candidates();
  void set_allocated_candidates(::mozc::commands::Candidates* candidates);

  // optional .mozc.commands.KeyEvent key = 7;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 7;
  private:
  const ::mozc::commands::KeyEvent& _internal_key() const;
  public:
  const ::mozc::commands::KeyEvent& key() const;
  ::mozc::commands::KeyEvent* release_key();
  ::mozc::commands::KeyEvent* mutable_key();
  void set_allocated_key(::mozc::commands::KeyEvent* key);

  // optional .mozc.config.Config config = 9;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 9;
  private:
  const ::mozc::config::Config& _internal_config() const;
  public:
  const ::mozc::config::Config& config() const;
  ::mozc::config::Config* release_config();
  ::mozc::config::Config* mutable_config();
  void set_allocated_config(::mozc::config::Config* config);

  // optional .mozc.commands.Status status = 13;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 13;
  private:
  const ::mozc::commands::Status& _internal_status() const;
  public:
  const ::mozc::commands::Status& status() const;
  ::mozc::commands::Status* release_status();
  ::mozc::commands::Status* mutable_status();
  void set_allocated_status(::mozc::commands::Status* status);

  // optional .mozc.commands.CandidateList all_candidate_words = 14;
  bool has_all_candidate_words() const;
  void clear_all_candidate_words();
  static const int kAllCandidateWordsFieldNumber = 14;
  private:
  const ::mozc::commands::CandidateList& _internal_all_candidate_words() const;
  public:
  const ::mozc::commands::CandidateList& all_candidate_words() const;
  ::mozc::commands::CandidateList* release_all_candidate_words();
  ::mozc::commands::CandidateList* mutable_all_candidate_words();
  void set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words);

  // optional .mozc.commands.DeletionRange deletion_range = 16;
  bool has_deletion_range() const;
  void clear_deletion_range();
  static const int kDeletionRangeFieldNumber = 16;
  private:
  const ::mozc::commands::DeletionRange& _internal_deletion_range() const;
  public:
  const ::mozc::commands::DeletionRange& deletion_range() const;
  ::mozc::commands::DeletionRange* release_deletion_range();
  ::mozc::commands::DeletionRange* mutable_deletion_range();
  void set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range);

  // optional .mozc.commands.Output.Callback callback = 18;
  bool has_callback() const;
  void clear_callback();
  static const int kCallbackFieldNumber = 18;
  private:
  const ::mozc::commands::Output_Callback& _internal_callback() const;
  public:
  const ::mozc::commands::Output_Callback& callback() const;
  ::mozc::commands::Output_Callback* release_callback();
  ::mozc::commands::Output_Callback* mutable_callback();
  void set_allocated_callback(::mozc::commands::Output_Callback* callback);

  // optional .mozc.commands.GenericStorageEntry storage_entry = 19;
  bool has_storage_entry() const;
  void clear_storage_entry();
  static const int kStorageEntryFieldNumber = 19;
  private:
  const ::mozc::commands::GenericStorageEntry& _internal_storage_entry() const;
  public:
  const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  ::mozc::commands::GenericStorageEntry* release_storage_entry();
  ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);

  // optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
  bool has_user_dictionary_command_status() const;
  void clear_user_dictionary_command_status();
  static const int kUserDictionaryCommandStatusFieldNumber = 21;
  private:
  const ::mozc::user_dictionary::UserDictionaryCommandStatus& _internal_user_dictionary_command_status() const;
  public:
  const ::mozc::user_dictionary::UserDictionaryCommandStatus& user_dictionary_command_status() const;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* release_user_dictionary_command_status();
  ::mozc::user_dictionary::UserDictionaryCommandStatus* mutable_user_dictionary_command_status();
  void set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status);

  // optional .mozc.EngineReloadResponse engine_reload_response = 22;
  bool has_engine_reload_response() const;
  void clear_engine_reload_response();
  static const int kEngineReloadResponseFieldNumber = 22;
  private:
  const ::mozc::EngineReloadResponse& _internal_engine_reload_response() const;
  public:
  const ::mozc::EngineReloadResponse& engine_reload_response() const;
  ::mozc::EngineReloadResponse* release_engine_reload_response();
  ::mozc::EngineReloadResponse* mutable_engine_reload_response();
  void set_allocated_engine_reload_response(::mozc::EngineReloadResponse* engine_reload_response);

  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional .mozc.commands.CompositionMode mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::mozc::commands::CompositionMode mode() const;
  void set_mode(::mozc::commands::CompositionMode value);

  // optional bool consumed = 3;
  bool has_consumed() const;
  void clear_consumed();
  static const int kConsumedFieldNumber = 3;
  bool consumed() const;
  void set_consumed(bool value);

  // optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
  bool has_preedit_method() const;
  void clear_preedit_method();
  static const int kPreeditMethodFieldNumber = 10;
  ::mozc::commands::Output_PreeditMethod preedit_method() const;
  void set_preedit_method(::mozc::commands::Output_PreeditMethod value);

  // optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 11;
  ::mozc::commands::Output_ErrorCode error_code() const;
  void set_error_code(::mozc::commands::Output_ErrorCode value);

  // optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
  bool has_launch_tool_mode() const;
  void clear_launch_tool_mode();
  static const int kLaunchToolModeFieldNumber = 17;
  ::mozc::commands::Output_ToolMode launch_tool_mode() const;
  void set_launch_tool_mode(::mozc::commands::Output_ToolMode value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Output)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_mode();
  void clear_has_mode();
  void set_has_consumed();
  void clear_has_consumed();
  void set_has_result();
  void clear_has_result();
  void set_has_preedit();
  void clear_has_preedit();
  void set_has_candidates();
  void clear_has_candidates();
  void set_has_key();
  void clear_has_key();
  void set_has_url();
  void clear_has_url();
  void set_has_config();
  void clear_has_config();
  void set_has_preedit_method();
  void clear_has_preedit_method();
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_status();
  void clear_has_status();
  void set_has_all_candidate_words();
  void clear_has_all_candidate_words();
  void set_has_deletion_range();
  void clear_has_deletion_range();
  void set_has_launch_tool_mode();
  void clear_has_launch_tool_mode();
  void set_has_callback();
  void clear_has_callback();
  void set_has_storage_entry();
  void clear_has_storage_entry();
  void set_has_user_dictionary_command_status();
  void clear_has_user_dictionary_command_status();
  void set_has_engine_reload_response();
  void clear_has_engine_reload_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::mozc::commands::Result* result_;
  ::mozc::commands::Preedit* preedit_;
  ::mozc::commands::Candidates* candidates_;
  ::mozc::commands::KeyEvent* key_;
  ::mozc::config::Config* config_;
  ::mozc::commands::Status* status_;
  ::mozc::commands::CandidateList* all_candidate_words_;
  ::mozc::commands::DeletionRange* deletion_range_;
  ::mozc::commands::Output_Callback* callback_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status_;
  ::mozc::EngineReloadResponse* engine_reload_response_;
  ::google::protobuf::uint64 id_;
  int mode_;
  bool consumed_;
  int preedit_method_;
  int error_code_;
  int launch_tool_mode_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(NULL);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mozc.commands.Input input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  private:
  const ::mozc::commands::Input& _internal_input() const;
  public:
  const ::mozc::commands::Input& input() const;
  ::mozc::commands::Input* release_input();
  ::mozc::commands::Input* mutable_input();
  void set_allocated_input(::mozc::commands::Input* input);

  // required .mozc.commands.Output output = 2;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  private:
  const ::mozc::commands::Output& _internal_output() const;
  public:
  const ::mozc::commands::Output& output() const;
  ::mozc::commands::Output* release_output();
  ::mozc::commands::Output* mutable_output();
  void set_allocated_output(::mozc::commands::Output* output);

  // @@protoc_insertion_point(class_scope:mozc.commands.Command)
 private:
  void set_has_input();
  void clear_has_input();
  void set_has_output();
  void clear_has_output();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mozc::commands::Input* input_;
  ::mozc::commands::Output* output_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommandList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.CommandList) */ {
 public:
  CommandList();
  virtual ~CommandList();

  CommandList(const CommandList& from);

  inline CommandList& operator=(const CommandList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommandList(CommandList&& from) noexcept
    : CommandList() {
    *this = ::std::move(from);
  }

  inline CommandList& operator=(CommandList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandList* internal_default_instance() {
    return reinterpret_cast<const CommandList*>(
               &_CommandList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CommandList* other);
  friend void swap(CommandList& a, CommandList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommandList* New() const final {
    return CreateMaybeMessage<CommandList>(NULL);
  }

  CommandList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommandList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommandList& from);
  void MergeFrom(const CommandList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.Command commands = 1;
  int commands_size() const;
  void clear_commands();
  static const int kCommandsFieldNumber = 1;
  ::mozc::commands::Command* mutable_commands(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >*
      mutable_commands();
  const ::mozc::commands::Command& commands(int index) const;
  ::mozc::commands::Command* add_commands();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >&
      commands() const;

  // @@protoc_insertion_point(class_scope:mozc.commands.CommandList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command > commands_;
  friend struct ::protobuf_protocol_2fcommands_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyEvent_ProbableKeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent_ProbableKeyEvent::has_key_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_key_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_key_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent_ProbableKeyEvent::clear_key_code() {
  key_code_ = 0u;
  clear_has_key_code();
}
inline ::google::protobuf::uint32 KeyEvent_ProbableKeyEvent::key_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.key_code)
  return key_code_;
}
inline void KeyEvent_ProbableKeyEvent::set_key_code(::google::protobuf::uint32 value) {
  set_has_key_code();
  key_code_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.key_code)
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent_ProbableKeyEvent::has_special_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_special_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_special_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent_ProbableKeyEvent::clear_special_key() {
  special_key_ = 0;
  clear_has_special_key();
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent_ProbableKeyEvent::special_key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.special_key)
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline void KeyEvent_ProbableKeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  set_has_special_key();
  special_key_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.special_key)
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent_ProbableKeyEvent::modifier_keys_size() const {
  return modifier_keys_.size();
}
inline void KeyEvent_ProbableKeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent_ProbableKeyEvent::modifier_keys(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline void KeyEvent_ProbableKeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
}
inline void KeyEvent_ProbableKeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
}
inline const ::google::protobuf::RepeatedField<int>&
KeyEvent_ProbableKeyEvent::modifier_keys() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return modifier_keys_;
}
inline ::google::protobuf::RepeatedField<int>*
KeyEvent_ProbableKeyEvent::mutable_modifier_keys() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.ProbableKeyEvent.modifier_keys)
  return &modifier_keys_;
}

// optional double probability = 10;
inline bool KeyEvent_ProbableKeyEvent::has_probability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_probability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_probability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyEvent_ProbableKeyEvent::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double KeyEvent_ProbableKeyEvent::probability() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.ProbableKeyEvent.probability)
  return probability_;
}
inline void KeyEvent_ProbableKeyEvent::set_probability(double value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.ProbableKeyEvent.probability)
}

// -------------------------------------------------------------------

// KeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent::has_key_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent::set_has_key_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent::clear_has_key_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent::clear_key_code() {
  key_code_ = 0u;
  clear_has_key_code();
}
inline ::google::protobuf::uint32 KeyEvent::key_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.key_code)
  return key_code_;
}
inline void KeyEvent::set_key_code(::google::protobuf::uint32 value) {
  set_has_key_code();
  key_code_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.key_code)
}

// optional uint32 modifiers = 2;
inline bool KeyEvent::has_modifiers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyEvent::set_has_modifiers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyEvent::clear_has_modifiers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyEvent::clear_modifiers() {
  modifiers_ = 0u;
  clear_has_modifiers();
}
inline ::google::protobuf::uint32 KeyEvent::modifiers() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.modifiers)
  return modifiers_;
}
inline void KeyEvent::set_modifiers(::google::protobuf::uint32 value) {
  set_has_modifiers();
  modifiers_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.modifiers)
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent::has_special_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyEvent::set_has_special_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyEvent::clear_has_special_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyEvent::clear_special_key() {
  special_key_ = 0;
  clear_has_special_key();
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent::special_key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.special_key)
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline void KeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  set_has_special_key();
  special_key_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.special_key)
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent::modifier_keys_size() const {
  return modifier_keys_.size();
}
inline void KeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent::modifier_keys(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.modifier_keys)
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline void KeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.modifier_keys)
}
inline void KeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.modifier_keys)
}
inline const ::google::protobuf::RepeatedField<int>&
KeyEvent::modifier_keys() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.modifier_keys)
  return modifier_keys_;
}
inline ::google::protobuf::RepeatedField<int>*
KeyEvent::mutable_modifier_keys() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.modifier_keys)
  return &modifier_keys_;
}

// optional string key_string = 5;
inline bool KeyEvent::has_key_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent::set_has_key_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent::clear_has_key_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent::clear_key_string() {
  key_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_string();
}
inline const ::std::string& KeyEvent::key_string() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.key_string)
  return key_string_.GetNoArena();
}
inline void KeyEvent::set_key_string(const ::std::string& value) {
  set_has_key_string();
  key_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.key_string)
}
#if LANG_CXX11
inline void KeyEvent::set_key_string(::std::string&& value) {
  set_has_key_string();
  key_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.KeyEvent.key_string)
}
#endif
inline void KeyEvent::set_key_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key_string();
  key_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.KeyEvent.key_string)
}
inline void KeyEvent::set_key_string(const char* value, size_t size) {
  set_has_key_string();
  key_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.KeyEvent.key_string)
}
inline ::std::string* KeyEvent::mutable_key_string() {
  set_has_key_string();
  // @@protoc_insertion_point(field_mutable:mozc.commands.KeyEvent.key_string)
  return key_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyEvent::release_key_string() {
  // @@protoc_insertion_point(field_release:mozc.commands.KeyEvent.key_string)
  if (!has_key_string()) {
    return NULL;
  }
  clear_has_key_string();
  return key_string_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyEvent::set_allocated_key_string(::std::string* key_string) {
  if (key_string != NULL) {
    set_has_key_string();
  } else {
    clear_has_key_string();
  }
  key_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_string);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.KeyEvent.key_string)
}

// optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
inline bool KeyEvent::has_input_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeyEvent::set_has_input_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeyEvent::clear_has_input_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeyEvent::clear_input_style() {
  input_style_ = 0;
  clear_has_input_style();
}
inline ::mozc::commands::KeyEvent_InputStyle KeyEvent::input_style() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.input_style)
  return static_cast< ::mozc::commands::KeyEvent_InputStyle >(input_style_);
}
inline void KeyEvent::set_input_style(::mozc::commands::KeyEvent_InputStyle value) {
  assert(::mozc::commands::KeyEvent_InputStyle_IsValid(value));
  set_has_input_style();
  input_style_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.input_style)
}

// optional .mozc.commands.CompositionMode mode = 7;
inline bool KeyEvent::has_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeyEvent::set_has_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeyEvent::clear_has_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeyEvent::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode KeyEvent::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.mode)
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void KeyEvent::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.mode)
}

// repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
inline int KeyEvent::probable_key_event_size() const {
  return probable_key_event_.size();
}
inline void KeyEvent::clear_probable_key_event() {
  probable_key_event_.Clear();
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::mutable_probable_key_event(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
KeyEvent::mutable_probable_key_event() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.KeyEvent.probable_key_event)
  return &probable_key_event_;
}
inline const ::mozc::commands::KeyEvent_ProbableKeyEvent& KeyEvent::probable_key_event(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_.Get(index);
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::add_probable_key_event() {
  // @@protoc_insertion_point(field_add:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
KeyEvent::probable_key_event() const {
  // @@protoc_insertion_point(field_list:mozc.commands.KeyEvent.probable_key_event)
  return probable_key_event_;
}

// optional bool activated = 9;
inline bool KeyEvent::has_activated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeyEvent::set_has_activated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeyEvent::clear_has_activated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeyEvent::clear_activated() {
  activated_ = false;
  clear_has_activated();
}
inline bool KeyEvent::activated() const {
  // @@protoc_insertion_point(field_get:mozc.commands.KeyEvent.activated)
  return activated_;
}
inline void KeyEvent::set_activated(bool value) {
  set_has_activated();
  activated_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.KeyEvent.activated)
}

// -------------------------------------------------------------------

// GenericStorageEntry

// optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
inline bool GenericStorageEntry::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenericStorageEntry::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenericStorageEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenericStorageEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::GenericStorageEntry_StorageType GenericStorageEntry::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.type)
  return static_cast< ::mozc::commands::GenericStorageEntry_StorageType >(type_);
}
inline void GenericStorageEntry::set_type(::mozc::commands::GenericStorageEntry_StorageType value) {
  assert(::mozc::commands::GenericStorageEntry_StorageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.type)
}

// optional string key = 2;
inline bool GenericStorageEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericStorageEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericStorageEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericStorageEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& GenericStorageEntry::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.key)
  return key_.GetNoArena();
}
inline void GenericStorageEntry::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.key)
}
#if LANG_CXX11
inline void GenericStorageEntry::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.GenericStorageEntry.key)
}
#endif
inline void GenericStorageEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.GenericStorageEntry.key)
}
inline void GenericStorageEntry::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.GenericStorageEntry.key)
}
inline ::std::string* GenericStorageEntry::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozc.commands.GenericStorageEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenericStorageEntry::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.GenericStorageEntry.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenericStorageEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.GenericStorageEntry.key)
}

// repeated bytes value = 3;
inline int GenericStorageEntry::value_size() const {
  return value_.size();
}
inline void GenericStorageEntry::clear_value() {
  value_.Clear();
}
inline const ::std::string& GenericStorageEntry::value(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.GenericStorageEntry.value)
  return value_.Get(index);
}
inline ::std::string* GenericStorageEntry::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.GenericStorageEntry.value)
  return value_.Mutable(index);
}
inline void GenericStorageEntry::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GenericStorageEntry::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.GenericStorageEntry.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GenericStorageEntry::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.GenericStorageEntry.value)
}
inline ::std::string* GenericStorageEntry::add_value() {
  // @@protoc_insertion_point(field_add_mutable:mozc.commands.GenericStorageEntry.value)
  return value_.Add();
}
inline void GenericStorageEntry::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozc.commands.GenericStorageEntry.value)
}
#if LANG_CXX11
inline void GenericStorageEntry::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozc.commands.GenericStorageEntry.value)
}
#endif
inline void GenericStorageEntry::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozc.commands.GenericStorageEntry.value)
}
inline void GenericStorageEntry::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozc.commands.GenericStorageEntry.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GenericStorageEntry::value() const {
  // @@protoc_insertion_point(field_list:mozc.commands.GenericStorageEntry.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GenericStorageEntry::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.GenericStorageEntry.value)
  return &value_;
}

// -------------------------------------------------------------------

// SessionCommand

// required .mozc.commands.SessionCommand.CommandType type = 1;
inline bool SessionCommand::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionCommand::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionCommand::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mozc::commands::SessionCommand_CommandType SessionCommand::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.type)
  return static_cast< ::mozc::commands::SessionCommand_CommandType >(type_);
}
inline void SessionCommand::set_type(::mozc::commands::SessionCommand_CommandType value) {
  assert(::mozc::commands::SessionCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.type)
}

// optional int32 id = 2;
inline bool SessionCommand::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionCommand::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SessionCommand::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.id)
  return id_;
}
inline void SessionCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.id)
}

// optional .mozc.commands.CompositionMode composition_mode = 3;
inline bool SessionCommand::has_composition_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionCommand::set_has_composition_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionCommand::clear_has_composition_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionCommand::clear_composition_mode() {
  composition_mode_ = 0;
  clear_has_composition_mode();
}
inline ::mozc::commands::CompositionMode SessionCommand::composition_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.composition_mode)
  return static_cast< ::mozc::commands::CompositionMode >(composition_mode_);
}
inline void SessionCommand::set_composition_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_composition_mode();
  composition_mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.composition_mode)
}

// optional string text = 4;
inline bool SessionCommand::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionCommand::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionCommand::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionCommand::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& SessionCommand::text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.text)
  return text_.GetNoArena();
}
inline void SessionCommand::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.text)
}
#if LANG_CXX11
inline void SessionCommand::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.SessionCommand.text)
}
#endif
inline void SessionCommand::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.SessionCommand.text)
}
inline void SessionCommand::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.SessionCommand.text)
}
inline ::std::string* SessionCommand::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:mozc.commands.SessionCommand.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionCommand::release_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.SessionCommand.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionCommand::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.SessionCommand.text)
}

// optional uint32 cursor_position = 5;
inline bool SessionCommand::has_cursor_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionCommand::set_has_cursor_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionCommand::clear_has_cursor_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionCommand::clear_cursor_position() {
  cursor_position_ = 0u;
  clear_has_cursor_position();
}
inline ::google::protobuf::uint32 SessionCommand::cursor_position() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.cursor_position)
  return cursor_position_;
}
inline void SessionCommand::set_cursor_position(::google::protobuf::uint32 value) {
  set_has_cursor_position();
  cursor_position_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.cursor_position)
}

// optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
inline bool SessionCommand::has_usage_stats_event() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SessionCommand::set_has_usage_stats_event() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SessionCommand::clear_has_usage_stats_event() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SessionCommand::clear_usage_stats_event() {
  usage_stats_event_ = 1;
  clear_has_usage_stats_event();
}
inline ::mozc::commands::SessionCommand_UsageStatsEvent SessionCommand::usage_stats_event() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.usage_stats_event)
  return static_cast< ::mozc::commands::SessionCommand_UsageStatsEvent >(usage_stats_event_);
}
inline void SessionCommand::set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value) {
  assert(::mozc::commands::SessionCommand_UsageStatsEvent_IsValid(value));
  set_has_usage_stats_event();
  usage_stats_event_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.usage_stats_event)
}

// optional int32 usage_stats_event_int_value = 9;
inline bool SessionCommand::has_usage_stats_event_int_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionCommand::set_has_usage_stats_event_int_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionCommand::clear_has_usage_stats_event_int_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionCommand::clear_usage_stats_event_int_value() {
  usage_stats_event_int_value_ = 0;
  clear_has_usage_stats_event_int_value();
}
inline ::google::protobuf::int32 SessionCommand::usage_stats_event_int_value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.SessionCommand.usage_stats_event_int_value)
  return usage_stats_event_int_value_;
}
inline void SessionCommand::set_usage_stats_event_int_value(::google::protobuf::int32 value) {
  set_has_usage_stats_event_int_value();
  usage_stats_event_int_value_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.SessionCommand.usage_stats_event_int_value)
}

// -------------------------------------------------------------------

// Context

// optional string preceding_text = 1;
inline bool Context::has_preceding_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Context::set_has_preceding_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Context::clear_has_preceding_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Context::clear_preceding_text() {
  preceding_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_preceding_text();
}
inline const ::std::string& Context::preceding_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.preceding_text)
  return preceding_text_.GetNoArena();
}
inline void Context::set_preceding_text(const ::std::string& value) {
  set_has_preceding_text();
  preceding_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.preceding_text)
}
#if LANG_CXX11
inline void Context::set_preceding_text(::std::string&& value) {
  set_has_preceding_text();
  preceding_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Context.preceding_text)
}
#endif
inline void Context::set_preceding_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_preceding_text();
  preceding_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.preceding_text)
}
inline void Context::set_preceding_text(const char* value, size_t size) {
  set_has_preceding_text();
  preceding_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.preceding_text)
}
inline ::std::string* Context::mutable_preceding_text() {
  set_has_preceding_text();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.preceding_text)
  return preceding_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Context::release_preceding_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.Context.preceding_text)
  if (!has_preceding_text()) {
    return NULL;
  }
  clear_has_preceding_text();
  return preceding_text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_allocated_preceding_text(::std::string* preceding_text) {
  if (preceding_text != NULL) {
    set_has_preceding_text();
  } else {
    clear_has_preceding_text();
  }
  preceding_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preceding_text);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Context.preceding_text)
}

// optional string following_text = 2;
inline bool Context::has_following_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Context::set_has_following_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Context::clear_has_following_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Context::clear_following_text() {
  following_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_following_text();
}
inline const ::std::string& Context::following_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.following_text)
  return following_text_.GetNoArena();
}
inline void Context::set_following_text(const ::std::string& value) {
  set_has_following_text();
  following_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Context.following_text)
}
#if LANG_CXX11
inline void Context::set_following_text(::std::string&& value) {
  set_has_following_text();
  following_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Context.following_text)
}
#endif
inline void Context::set_following_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_following_text();
  following_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.following_text)
}
inline void Context::set_following_text(const char* value, size_t size) {
  set_has_following_text();
  following_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.following_text)
}
inline ::std::string* Context::mutable_following_text() {
  set_has_following_text();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.following_text)
  return following_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Context::release_following_text() {
  // @@protoc_insertion_point(field_release:mozc.commands.Context.following_text)
  if (!has_following_text()) {
    return NULL;
  }
  clear_has_following_text();
  return following_text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Context::set_allocated_following_text(::std::string* following_text) {
  if (following_text != NULL) {
    set_has_following_text();
  } else {
    clear_has_following_text();
  }
  following_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), following_text);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Context.following_text)
}

// optional bool suppress_suggestion = 3 [default = false];
inline bool Context::has_suppress_suggestion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Context::set_has_suppress_suggestion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Context::clear_has_suppress_suggestion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Context::clear_suppress_suggestion() {
  suppress_suggestion_ = false;
  clear_has_suppress_suggestion();
}
inline bool Context::suppress_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.suppress_suggestion)
  return suppress_suggestion_;
}
inline void Context::set_suppress_suggestion(bool value) {
  set_has_suppress_suggestion();
  suppress_suggestion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Context.suppress_suggestion)
}

// optional .mozc.commands.Context.InputFieldType input_field_type = 4;
inline bool Context::has_input_field_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Context::set_has_input_field_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Context::clear_has_input_field_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Context::clear_input_field_type() {
  input_field_type_ = 1;
  clear_has_input_field_type();
}
inline ::mozc::commands::Context_InputFieldType Context::input_field_type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.input_field_type)
  return static_cast< ::mozc::commands::Context_InputFieldType >(input_field_type_);
}
inline void Context::set_input_field_type(::mozc::commands::Context_InputFieldType value) {
  assert(::mozc::commands::Context_InputFieldType_IsValid(value));
  set_has_input_field_type();
  input_field_type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Context.input_field_type)
}

// optional int32 revision = 5 [default = 0];
inline bool Context::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Context::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Context::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Context::clear_revision() {
  revision_ = 0;
  clear_has_revision();
}
inline ::google::protobuf::int32 Context::revision() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.revision)
  return revision_;
}
inline void Context::set_revision(::google::protobuf::int32 value) {
  set_has_revision();
  revision_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Context.revision)
}

// repeated string experimental_features = 100;
inline int Context::experimental_features_size() const {
  return experimental_features_.size();
}
inline void Context::clear_experimental_features() {
  experimental_features_.Clear();
}
inline const ::std::string& Context::experimental_features(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Context.experimental_features)
  return experimental_features_.Get(index);
}
inline ::std::string* Context::mutable_experimental_features(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Context.experimental_features)
  return experimental_features_.Mutable(index);
}
inline void Context::set_experimental_features(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.Context.experimental_features)
  experimental_features_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Context::set_experimental_features(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mozc.commands.Context.experimental_features)
  experimental_features_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Context::set_experimental_features(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  experimental_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozc.commands.Context.experimental_features)
}
inline void Context::set_experimental_features(int index, const char* value, size_t size) {
  experimental_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Context.experimental_features)
}
inline ::std::string* Context::add_experimental_features() {
  // @@protoc_insertion_point(field_add_mutable:mozc.commands.Context.experimental_features)
  return experimental_features_.Add();
}
inline void Context::add_experimental_features(const ::std::string& value) {
  experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozc.commands.Context.experimental_features)
}
#if LANG_CXX11
inline void Context::add_experimental_features(::std::string&& value) {
  experimental_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozc.commands.Context.experimental_features)
}
#endif
inline void Context::add_experimental_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozc.commands.Context.experimental_features)
}
inline void Context::add_experimental_features(const char* value, size_t size) {
  experimental_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozc.commands.Context.experimental_features)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Context::experimental_features() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Context.experimental_features)
  return experimental_features_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Context::mutable_experimental_features() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Context.experimental_features)
  return &experimental_features_;
}

// -------------------------------------------------------------------

// Capability

// optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
inline bool Capability::has_text_deletion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Capability::set_has_text_deletion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Capability::clear_has_text_deletion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Capability::clear_text_deletion() {
  text_deletion_ = 0;
  clear_has_text_deletion();
}
inline ::mozc::commands::Capability_TextDeletionCapabilityType Capability::text_deletion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Capability.text_deletion)
  return static_cast< ::mozc::commands::Capability_TextDeletionCapabilityType >(text_deletion_);
}
inline void Capability::set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value) {
  assert(::mozc::commands::Capability_TextDeletionCapabilityType_IsValid(value));
  set_has_text_deletion();
  text_deletion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Capability.text_deletion)
}

// -------------------------------------------------------------------

// Request

// optional bool zero_query_suggestion = 1 [default = false];
inline bool Request::has_zero_query_suggestion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_zero_query_suggestion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_zero_query_suggestion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_zero_query_suggestion() {
  zero_query_suggestion_ = false;
  clear_has_zero_query_suggestion();
}
inline bool Request::zero_query_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.zero_query_suggestion)
  return zero_query_suggestion_;
}
inline void Request::set_zero_query_suggestion(bool value) {
  set_has_zero_query_suggestion();
  zero_query_suggestion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.zero_query_suggestion)
}

// optional bool mixed_conversion = 2 [default = false];
inline bool Request::has_mixed_conversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_mixed_conversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_mixed_conversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_mixed_conversion() {
  mixed_conversion_ = false;
  clear_has_mixed_conversion();
}
inline bool Request::mixed_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.mixed_conversion)
  return mixed_conversion_;
}
inline void Request::set_mixed_conversion(bool value) {
  set_has_mixed_conversion();
  mixed_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.mixed_conversion)
}

// optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
inline bool Request::has_special_romanji_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_special_romanji_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_special_romanji_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_special_romanji_table() {
  special_romanji_table_ = 0;
  clear_has_special_romanji_table();
}
inline ::mozc::commands::Request_SpecialRomanjiTable Request::special_romanji_table() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.special_romanji_table)
  return static_cast< ::mozc::commands::Request_SpecialRomanjiTable >(special_romanji_table_);
}
inline void Request::set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value) {
  assert(::mozc::commands::Request_SpecialRomanjiTable_IsValid(value));
  set_has_special_romanji_table();
  special_romanji_table_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.special_romanji_table)
}

// optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
inline bool Request::has_space_on_alphanumeric() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_space_on_alphanumeric() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_space_on_alphanumeric() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_space_on_alphanumeric() {
  space_on_alphanumeric_ = 0;
  clear_has_space_on_alphanumeric();
}
inline ::mozc::commands::Request_SpaceOnAlphanumeric Request::space_on_alphanumeric() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.space_on_alphanumeric)
  return static_cast< ::mozc::commands::Request_SpaceOnAlphanumeric >(space_on_alphanumeric_);
}
inline void Request::set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value) {
  assert(::mozc::commands::Request_SpaceOnAlphanumeric_IsValid(value));
  set_has_space_on_alphanumeric();
  space_on_alphanumeric_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.space_on_alphanumeric)
}

// optional string keyboard_name = 7;
inline bool Request::has_keyboard_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_keyboard_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_keyboard_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_keyboard_name() {
  keyboard_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyboard_name();
}
inline const ::std::string& Request::keyboard_name() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.keyboard_name)
  return keyboard_name_.GetNoArena();
}
inline void Request::set_keyboard_name(const ::std::string& value) {
  set_has_keyboard_name();
  keyboard_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Request.keyboard_name)
}
#if LANG_CXX11
inline void Request::set_keyboard_name(::std::string&& value) {
  set_has_keyboard_name();
  keyboard_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Request.keyboard_name)
}
#endif
inline void Request::set_keyboard_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyboard_name();
  keyboard_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Request.keyboard_name)
}
inline void Request::set_keyboard_name(const char* value, size_t size) {
  set_has_keyboard_name();
  keyboard_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Request.keyboard_name)
}
inline ::std::string* Request::mutable_keyboard_name() {
  set_has_keyboard_name();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Request.keyboard_name)
  return keyboard_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_keyboard_name() {
  // @@protoc_insertion_point(field_release:mozc.commands.Request.keyboard_name)
  if (!has_keyboard_name()) {
    return NULL;
  }
  clear_has_keyboard_name();
  return keyboard_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_keyboard_name(::std::string* keyboard_name) {
  if (keyboard_name != NULL) {
    set_has_keyboard_name();
  } else {
    clear_has_keyboard_name();
  }
  keyboard_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyboard_name);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Request.keyboard_name)
}

// optional bool update_input_mode_from_surrounding_text = 8 [default = true];
inline bool Request::has_update_input_mode_from_surrounding_text() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_update_input_mode_from_surrounding_text() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_update_input_mode_from_surrounding_text() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_update_input_mode_from_surrounding_text() {
  update_input_mode_from_surrounding_text_ = true;
  clear_has_update_input_mode_from_surrounding_text();
}
inline bool Request::update_input_mode_from_surrounding_text() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.update_input_mode_from_surrounding_text)
  return update_input_mode_from_surrounding_text_;
}
inline void Request::set_update_input_mode_from_surrounding_text(bool value) {
  set_has_update_input_mode_from_surrounding_text();
  update_input_mode_from_surrounding_text_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.update_input_mode_from_surrounding_text)
}

// optional bool kana_modifier_insensitive_conversion = 9 [default = false];
inline bool Request::has_kana_modifier_insensitive_conversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_kana_modifier_insensitive_conversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_kana_modifier_insensitive_conversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_kana_modifier_insensitive_conversion() {
  kana_modifier_insensitive_conversion_ = false;
  clear_has_kana_modifier_insensitive_conversion();
}
inline bool Request::kana_modifier_insensitive_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.kana_modifier_insensitive_conversion)
  return kana_modifier_insensitive_conversion_;
}
inline void Request::set_kana_modifier_insensitive_conversion(bool value) {
  set_has_kana_modifier_insensitive_conversion();
  kana_modifier_insensitive_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.kana_modifier_insensitive_conversion)
}

// optional bool auto_partial_suggestion = 10 [default = false];
inline bool Request::has_auto_partial_suggestion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_auto_partial_suggestion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_auto_partial_suggestion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_auto_partial_suggestion() {
  auto_partial_suggestion_ = false;
  clear_has_auto_partial_suggestion();
}
inline bool Request::auto_partial_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.auto_partial_suggestion)
  return auto_partial_suggestion_;
}
inline void Request::set_auto_partial_suggestion(bool value) {
  set_has_auto_partial_suggestion();
  auto_partial_suggestion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.auto_partial_suggestion)
}

// optional int32 available_emoji_carrier = 11 [default = 1];
inline bool Request::has_available_emoji_carrier() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_available_emoji_carrier() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_available_emoji_carrier() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_available_emoji_carrier() {
  available_emoji_carrier_ = 1;
  clear_has_available_emoji_carrier();
}
inline ::google::protobuf::int32 Request::available_emoji_carrier() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.available_emoji_carrier)
  return available_emoji_carrier_;
}
inline void Request::set_available_emoji_carrier(::google::protobuf::int32 value) {
  set_has_available_emoji_carrier();
  available_emoji_carrier_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.available_emoji_carrier)
}

// optional int32 emoji_rewriter_capability = 12 [default = 1];
inline bool Request::has_emoji_rewriter_capability() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_emoji_rewriter_capability() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_emoji_rewriter_capability() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_emoji_rewriter_capability() {
  emoji_rewriter_capability_ = 1;
  clear_has_emoji_rewriter_capability();
}
inline ::google::protobuf::int32 Request::emoji_rewriter_capability() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.emoji_rewriter_capability)
  return emoji_rewriter_capability_;
}
inline void Request::set_emoji_rewriter_capability(::google::protobuf::int32 value) {
  set_has_emoji_rewriter_capability();
  emoji_rewriter_capability_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.emoji_rewriter_capability)
}

// optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
inline bool Request::has_crossing_edge_behavior() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_crossing_edge_behavior() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_crossing_edge_behavior() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_crossing_edge_behavior() {
  crossing_edge_behavior_ = 0;
  clear_has_crossing_edge_behavior();
}
inline ::mozc::commands::Request_CrossingEdgeBehavior Request::crossing_edge_behavior() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.crossing_edge_behavior)
  return static_cast< ::mozc::commands::Request_CrossingEdgeBehavior >(crossing_edge_behavior_);
}
inline void Request::set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value) {
  assert(::mozc::commands::Request_CrossingEdgeBehavior_IsValid(value));
  set_has_crossing_edge_behavior();
  crossing_edge_behavior_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.crossing_edge_behavior)
}

// optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
inline bool Request::has_language_aware_input() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_language_aware_input() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_language_aware_input() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_language_aware_input() {
  language_aware_input_ = 0;
  clear_has_language_aware_input();
}
inline ::mozc::commands::Request_LanguageAwareInputBehavior Request::language_aware_input() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.language_aware_input)
  return static_cast< ::mozc::commands::Request_LanguageAwareInputBehavior >(language_aware_input_);
}
inline void Request::set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value) {
  assert(::mozc::commands::Request_LanguageAwareInputBehavior_IsValid(value));
  set_has_language_aware_input();
  language_aware_input_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.language_aware_input)
}

// optional int32 candidate_page_size = 15 [default = 9];
inline bool Request::has_candidate_page_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_candidate_page_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_candidate_page_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_candidate_page_size() {
  candidate_page_size_ = 9;
  clear_has_candidate_page_size();
}
inline ::google::protobuf::int32 Request::candidate_page_size() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.candidate_page_size)
  return candidate_page_size_;
}
inline void Request::set_candidate_page_size(::google::protobuf::int32 value) {
  set_has_candidate_page_size();
  candidate_page_size_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.candidate_page_size)
}

// optional int32 candidates_size_limit = 16;
inline bool Request::has_candidates_size_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_candidates_size_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_candidates_size_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_candidates_size_limit() {
  candidates_size_limit_ = 0;
  clear_has_candidates_size_limit();
}
inline ::google::protobuf::int32 Request::candidates_size_limit() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Request.candidates_size_limit)
  return candidates_size_limit_;
}
inline void Request::set_candidates_size_limit(::google::protobuf::int32 value) {
  set_has_candidates_size_limit();
  candidates_size_limit_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Request.candidates_size_limit)
}

// -------------------------------------------------------------------

// ApplicationInfo

// optional uint32 process_id = 1;
inline bool ApplicationInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplicationInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplicationInfo::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 ApplicationInfo::process_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.process_id)
  return process_id_;
}
inline void ApplicationInfo::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.process_id)
}

// optional uint32 thread_id = 2;
inline bool ApplicationInfo::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationInfo::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplicationInfo::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplicationInfo::clear_thread_id() {
  thread_id_ = 0u;
  clear_has_thread_id();
}
inline ::google::protobuf::uint32 ApplicationInfo::thread_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.thread_id)
  return thread_id_;
}
inline void ApplicationInfo::set_thread_id(::google::protobuf::uint32 value) {
  set_has_thread_id();
  thread_id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.thread_id)
}

// optional int32 timezone_offset = 3;
inline bool ApplicationInfo::has_timezone_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplicationInfo::set_has_timezone_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplicationInfo::clear_has_timezone_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplicationInfo::clear_timezone_offset() {
  timezone_offset_ = 0;
  clear_has_timezone_offset();
}
inline ::google::protobuf::int32 ApplicationInfo::timezone_offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.ApplicationInfo.timezone_offset)
  return timezone_offset_;
}
inline void ApplicationInfo::set_timezone_offset(::google::protobuf::int32 value) {
  set_has_timezone_offset();
  timezone_offset_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.ApplicationInfo.timezone_offset)
}

// -------------------------------------------------------------------

// Input_TouchPosition

// optional .mozc.commands.Input.TouchAction action = 1;
inline bool Input_TouchPosition::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input_TouchPosition::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input_TouchPosition::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input_TouchPosition::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::mozc::commands::Input_TouchAction Input_TouchPosition::action() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.action)
  return static_cast< ::mozc::commands::Input_TouchAction >(action_);
}
inline void Input_TouchPosition::set_action(::mozc::commands::Input_TouchAction value) {
  assert(::mozc::commands::Input_TouchAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.action)
}

// optional float x = 2;
inline bool Input_TouchPosition::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_TouchPosition::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_TouchPosition::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_TouchPosition::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Input_TouchPosition::x() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.x)
  return x_;
}
inline void Input_TouchPosition::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.x)
}

// optional float y = 3;
inline bool Input_TouchPosition::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input_TouchPosition::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input_TouchPosition::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input_TouchPosition::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Input_TouchPosition::y() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.y)
  return y_;
}
inline void Input_TouchPosition::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.y)
}

// optional int64 timestamp = 4;
inline bool Input_TouchPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input_TouchPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input_TouchPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input_TouchPosition::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Input_TouchPosition::timestamp() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchPosition.timestamp)
  return timestamp_;
}
inline void Input_TouchPosition::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchPosition.timestamp)
}

// -------------------------------------------------------------------

// Input_TouchEvent

// optional uint32 source_id = 1;
inline bool Input_TouchEvent::has_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_TouchEvent::set_has_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_TouchEvent::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_TouchEvent::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 Input_TouchEvent::source_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchEvent.source_id)
  return source_id_;
}
inline void Input_TouchEvent::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.TouchEvent.source_id)
}

// repeated .mozc.commands.Input.TouchPosition stroke = 2;
inline int Input_TouchEvent::stroke_size() const {
  return stroke_.size();
}
inline void Input_TouchEvent::clear_stroke() {
  stroke_.Clear();
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::mutable_stroke(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.TouchEvent.stroke)
  return stroke_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
Input_TouchEvent::mutable_stroke() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Input.TouchEvent.stroke)
  return &stroke_;
}
inline const ::mozc::commands::Input_TouchPosition& Input_TouchEvent::stroke(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.TouchEvent.stroke)
  return stroke_.Get(index);
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::add_stroke() {
  // @@protoc_insertion_point(field_add:mozc.commands.Input.TouchEvent.stroke)
  return stroke_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
Input_TouchEvent::stroke() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Input.TouchEvent.stroke)
  return stroke_;
}

// -------------------------------------------------------------------

// Input

// required .mozc.commands.Input.CommandType type = 1;
inline bool Input::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Input::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Input::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Input::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::Input_CommandType Input::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.type)
  return static_cast< ::mozc::commands::Input_CommandType >(type_);
}
inline void Input::set_type(::mozc::commands::Input_CommandType value) {
  assert(::mozc::commands::Input_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.type)
}

// optional uint64 id = 2;
inline bool Input::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Input::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Input::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Input::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Input::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.id)
  return id_;
}
inline void Input::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.id)
}

// optional .mozc.commands.KeyEvent key = 3;
inline bool Input::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_key() {
  if (key_ != NULL) key_->Clear();
  clear_has_key();
}
inline const ::mozc::commands::KeyEvent& Input::_internal_key() const {
  return *key_;
}
inline const ::mozc::commands::KeyEvent& Input::key() const {
  const ::mozc::commands::KeyEvent* p = key_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.key)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::KeyEvent*>(
      &::mozc::commands::_KeyEvent_default_instance_);
}
inline ::mozc::commands::KeyEvent* Input::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.key)
  clear_has_key();
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::mozc::commands::KeyEvent* Input::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::KeyEvent>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.key)
  return key_;
}
inline void Input::set_allocated_key(::mozc::commands::KeyEvent* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.key)
}

// optional .mozc.commands.SessionCommand command = 4;
inline bool Input::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mozc::commands::SessionCommand& Input::_internal_command() const {
  return *command_;
}
inline const ::mozc::commands::SessionCommand& Input::command() const {
  const ::mozc::commands::SessionCommand* p = command_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::SessionCommand*>(
      &::mozc::commands::_SessionCommand_default_instance_);
}
inline ::mozc::commands::SessionCommand* Input::release_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.command)
  clear_has_command();
  ::mozc::commands::SessionCommand* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mozc::commands::SessionCommand* Input::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::SessionCommand>(GetArenaNoVirtual());
    command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.command)
  return command_;
}
inline void Input::set_allocated_command(::mozc::commands::SessionCommand* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.command)
}

// optional .mozc.config.Config config = 5;
inline bool Input::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mozc::config::Config& Input::_internal_config() const {
  return *config_;
}
inline const ::mozc::config::Config& Input::config() const {
  const ::mozc::config::Config* p = config_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.config)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::config::Config*>(
      &::mozc::config::_Config_default_instance_);
}
inline ::mozc::config::Config* Input::release_config() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.config)
  clear_has_config();
  ::mozc::config::Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::mozc::config::Config* Input::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::config::Config>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.config)
  return config_;
}
inline void Input::set_allocated_config(::mozc::config::Config* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.config)
}

// optional .mozc.commands.Context context = 6;
inline bool Input::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input::clear_context() {
  if (context_ != NULL) context_->Clear();
  clear_has_context();
}
inline const ::mozc::commands::Context& Input::_internal_context() const {
  return *context_;
}
inline const ::mozc::commands::Context& Input::context() const {
  const ::mozc::commands::Context* p = context_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.context)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Context*>(
      &::mozc::commands::_Context_default_instance_);
}
inline ::mozc::commands::Context* Input::release_context() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.context)
  clear_has_context();
  ::mozc::commands::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::mozc::commands::Context* Input::mutable_context() {
  set_has_context();
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.context)
  return context_;
}
inline void Input::set_allocated_context(::mozc::commands::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    set_has_context();
  } else {
    clear_has_context();
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.context)
}

// optional .mozc.commands.Capability capability = 7;
inline bool Input::has_capability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Input::set_has_capability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Input::clear_has_capability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Input::clear_capability() {
  if (capability_ != NULL) capability_->Clear();
  clear_has_capability();
}
inline const ::mozc::commands::Capability& Input::_internal_capability() const {
  return *capability_;
}
inline const ::mozc::commands::Capability& Input::capability() const {
  const ::mozc::commands::Capability* p = capability_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.capability)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Capability*>(
      &::mozc::commands::_Capability_default_instance_);
}
inline ::mozc::commands::Capability* Input::release_capability() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.capability)
  clear_has_capability();
  ::mozc::commands::Capability* temp = capability_;
  capability_ = NULL;
  return temp;
}
inline ::mozc::commands::Capability* Input::mutable_capability() {
  set_has_capability();
  if (capability_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Capability>(GetArenaNoVirtual());
    capability_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.capability)
  return capability_;
}
inline void Input::set_allocated_capability(::mozc::commands::Capability* capability) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capability_;
  }
  if (capability) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capability = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capability, submessage_arena);
    }
    set_has_capability();
  } else {
    clear_has_capability();
  }
  capability_ = capability;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.capability)
}

// optional .mozc.commands.ApplicationInfo application_info = 8;
inline bool Input::has_application_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Input::set_has_application_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Input::clear_has_application_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Input::clear_application_info() {
  if (application_info_ != NULL) application_info_->Clear();
  clear_has_application_info();
}
inline const ::mozc::commands::ApplicationInfo& Input::_internal_application_info() const {
  return *application_info_;
}
inline const ::mozc::commands::ApplicationInfo& Input::application_info() const {
  const ::mozc::commands::ApplicationInfo* p = application_info_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.application_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::ApplicationInfo*>(
      &::mozc::commands::_ApplicationInfo_default_instance_);
}
inline ::mozc::commands::ApplicationInfo* Input::release_application_info() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.application_info)
  clear_has_application_info();
  ::mozc::commands::ApplicationInfo* temp = application_info_;
  application_info_ = NULL;
  return temp;
}
inline ::mozc::commands::ApplicationInfo* Input::mutable_application_info() {
  set_has_application_info();
  if (application_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::ApplicationInfo>(GetArenaNoVirtual());
    application_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.application_info)
  return application_info_;
}
inline void Input::set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete application_info_;
  }
  if (application_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      application_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, application_info, submessage_arena);
    }
    set_has_application_info();
  } else {
    clear_has_application_info();
  }
  application_info_ = application_info;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.application_info)
}

// optional .mozc.commands.Request request = 9;
inline bool Input::has_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Input::set_has_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Input::clear_has_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Input::clear_request() {
  if (request_ != NULL) request_->Clear();
  clear_has_request();
}
inline const ::mozc::commands::Request& Input::_internal_request() const {
  return *request_;
}
inline const ::mozc::commands::Request& Input::request() const {
  const ::mozc::commands::Request* p = request_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.request)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Request*>(
      &::mozc::commands::_Request_default_instance_);
}
inline ::mozc::commands::Request* Input::release_request() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.request)
  clear_has_request();
  ::mozc::commands::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::mozc::commands::Request* Input::mutable_request() {
  set_has_request();
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Request>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.request)
  return request_;
}
inline void Input::set_allocated_request(::mozc::commands::Request* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    set_has_request();
  } else {
    clear_has_request();
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.request)
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 10;
inline bool Input::has_storage_entry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Input::set_has_storage_entry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Input::clear_has_storage_entry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Input::clear_storage_entry() {
  if (storage_entry_ != NULL) storage_entry_->Clear();
  clear_has_storage_entry();
}
inline const ::mozc::commands::GenericStorageEntry& Input::_internal_storage_entry() const {
  return *storage_entry_;
}
inline const ::mozc::commands::GenericStorageEntry& Input::storage_entry() const {
  const ::mozc::commands::GenericStorageEntry* p = storage_entry_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.storage_entry)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::GenericStorageEntry*>(
      &::mozc::commands::_GenericStorageEntry_default_instance_);
}
inline ::mozc::commands::GenericStorageEntry* Input::release_storage_entry() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.storage_entry)
  clear_has_storage_entry();
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = NULL;
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Input::mutable_storage_entry() {
  set_has_storage_entry();
  if (storage_entry_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(GetArenaNoVirtual());
    storage_entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.storage_entry)
  return storage_entry_;
}
inline void Input::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_entry_;
  }
  if (storage_entry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage_entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage_entry, submessage_arena);
    }
    set_has_storage_entry();
  } else {
    clear_has_storage_entry();
  }
  storage_entry_ = storage_entry;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.storage_entry)
}

// repeated .mozc.commands.Input.TouchEvent touch_events = 12;
inline int Input::touch_events_size() const {
  return touch_events_.size();
}
inline void Input::clear_touch_events() {
  touch_events_.Clear();
}
inline ::mozc::commands::Input_TouchEvent* Input::mutable_touch_events(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.touch_events)
  return touch_events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
Input::mutable_touch_events() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Input.touch_events)
  return &touch_events_;
}
inline const ::mozc::commands::Input_TouchEvent& Input::touch_events(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.touch_events)
  return touch_events_.Get(index);
}
inline ::mozc::commands::Input_TouchEvent* Input::add_touch_events() {
  // @@protoc_insertion_point(field_add:mozc.commands.Input.touch_events)
  return touch_events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
Input::touch_events() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Input.touch_events)
  return touch_events_;
}

// optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
inline bool Input::has_user_dictionary_command() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Input::set_has_user_dictionary_command() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Input::clear_has_user_dictionary_command() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::mozc::user_dictionary::UserDictionaryCommand& Input::_internal_user_dictionary_command() const {
  return *user_dictionary_command_;
}
inline const ::mozc::user_dictionary::UserDictionaryCommand& Input::user_dictionary_command() const {
  const ::mozc::user_dictionary::UserDictionaryCommand* p = user_dictionary_command_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.user_dictionary_command)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::user_dictionary::UserDictionaryCommand*>(
      &::mozc::user_dictionary::_UserDictionaryCommand_default_instance_);
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::release_user_dictionary_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.user_dictionary_command)
  clear_has_user_dictionary_command();
  ::mozc::user_dictionary::UserDictionaryCommand* temp = user_dictionary_command_;
  user_dictionary_command_ = NULL;
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::mutable_user_dictionary_command() {
  set_has_user_dictionary_command();
  if (user_dictionary_command_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::user_dictionary::UserDictionaryCommand>(GetArenaNoVirtual());
    user_dictionary_command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.user_dictionary_command)
  return user_dictionary_command_;
}
inline void Input::set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_dictionary_command_);
  }
  if (user_dictionary_command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_dictionary_command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_dictionary_command, submessage_arena);
    }
    set_has_user_dictionary_command();
  } else {
    clear_has_user_dictionary_command();
  }
  user_dictionary_command_ = user_dictionary_command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.user_dictionary_command)
}

// optional bool request_suggestion = 14 [default = true];
inline bool Input::has_request_suggestion() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Input::set_has_request_suggestion() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Input::clear_has_request_suggestion() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Input::clear_request_suggestion() {
  request_suggestion_ = true;
  clear_has_request_suggestion();
}
inline bool Input::request_suggestion() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Input.request_suggestion)
  return request_suggestion_;
}
inline void Input::set_request_suggestion(bool value) {
  set_has_request_suggestion();
  request_suggestion_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Input.request_suggestion)
}

// optional .mozc.EngineReloadRequest engine_reload_request = 15;
inline bool Input::has_engine_reload_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Input::set_has_engine_reload_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Input::clear_has_engine_reload_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::mozc::EngineReloadRequest& Input::_internal_engine_reload_request() const {
  return *engine_reload_request_;
}
inline const ::mozc::EngineReloadRequest& Input::engine_reload_request() const {
  const ::mozc::EngineReloadRequest* p = engine_reload_request_;
  // @@protoc_insertion_point(field_get:mozc.commands.Input.engine_reload_request)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::EngineReloadRequest*>(
      &::mozc::_EngineReloadRequest_default_instance_);
}
inline ::mozc::EngineReloadRequest* Input::release_engine_reload_request() {
  // @@protoc_insertion_point(field_release:mozc.commands.Input.engine_reload_request)
  clear_has_engine_reload_request();
  ::mozc::EngineReloadRequest* temp = engine_reload_request_;
  engine_reload_request_ = NULL;
  return temp;
}
inline ::mozc::EngineReloadRequest* Input::mutable_engine_reload_request() {
  set_has_engine_reload_request();
  if (engine_reload_request_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::EngineReloadRequest>(GetArenaNoVirtual());
    engine_reload_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Input.engine_reload_request)
  return engine_reload_request_;
}
inline void Input::set_allocated_engine_reload_request(::mozc::EngineReloadRequest* engine_reload_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(engine_reload_request_);
  }
  if (engine_reload_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      engine_reload_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, engine_reload_request, submessage_arena);
    }
    set_has_engine_reload_request();
  } else {
    clear_has_engine_reload_request();
  }
  engine_reload_request_ = engine_reload_request;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Input.engine_reload_request)
}

// -------------------------------------------------------------------

// Result

// required .mozc.commands.Result.ResultType type = 1;
inline bool Result::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::Result_ResultType Result::type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.type)
  return static_cast< ::mozc::commands::Result_ResultType >(type_);
}
inline void Result::set_type(::mozc::commands::Result_ResultType value) {
  assert(::mozc::commands::Result_ResultType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Result.type)
}

// required string value = 2;
inline bool Result::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Result::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.value)
  return value_.GetNoArena();
}
inline void Result::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.value)
}
#if LANG_CXX11
inline void Result::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Result.value)
}
#endif
inline void Result::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Result.value)
}
inline void Result::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Result.value)
}
inline ::std::string* Result::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Result.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.Result.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Result.value)
}

// optional string key = 3;
inline bool Result::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Result::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.key)
  return key_.GetNoArena();
}
inline void Result::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Result.key)
}
#if LANG_CXX11
inline void Result::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Result.key)
}
#endif
inline void Result::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Result.key)
}
inline void Result::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Result.key)
}
inline ::std::string* Result::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Result.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Result.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Result.key)
}

// optional int32 cursor_offset = 4 [default = 0];
inline bool Result::has_cursor_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_cursor_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_cursor_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_cursor_offset() {
  cursor_offset_ = 0;
  clear_has_cursor_offset();
}
inline ::google::protobuf::int32 Result::cursor_offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Result.cursor_offset)
  return cursor_offset_;
}
inline void Result::set_cursor_offset(::google::protobuf::int32 value) {
  set_has_cursor_offset();
  cursor_offset_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Result.cursor_offset)
}

// -------------------------------------------------------------------

// Preedit_Segment

// required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
inline bool Preedit_Segment::has_annotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Preedit_Segment::set_has_annotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Preedit_Segment::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Preedit_Segment::clear_annotation() {
  annotation_ = 0;
  clear_has_annotation();
}
inline ::mozc::commands::Preedit_Segment_Annotation Preedit_Segment::annotation() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.annotation)
  return static_cast< ::mozc::commands::Preedit_Segment_Annotation >(annotation_);
}
inline void Preedit_Segment::set_annotation(::mozc::commands::Preedit_Segment_Annotation value) {
  assert(::mozc::commands::Preedit_Segment_Annotation_IsValid(value));
  set_has_annotation();
  annotation_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.annotation)
}

// required string value = 4;
inline bool Preedit_Segment::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Preedit_Segment::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Preedit_Segment::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Preedit_Segment::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Preedit_Segment::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.value)
  return value_.GetNoArena();
}
inline void Preedit_Segment::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.value)
}
#if LANG_CXX11
inline void Preedit_Segment::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Preedit.Segment.value)
}
#endif
inline void Preedit_Segment::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Preedit.Segment.value)
}
inline void Preedit_Segment::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Preedit.Segment.value)
}
inline ::std::string* Preedit_Segment::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.Segment.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Preedit_Segment::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.Preedit.Segment.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Preedit_Segment::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Preedit.Segment.value)
}

// required uint32 value_length = 5;
inline bool Preedit_Segment::has_value_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Preedit_Segment::set_has_value_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Preedit_Segment::clear_has_value_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Preedit_Segment::clear_value_length() {
  value_length_ = 0u;
  clear_has_value_length();
}
inline ::google::protobuf::uint32 Preedit_Segment::value_length() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.value_length)
  return value_length_;
}
inline void Preedit_Segment::set_value_length(::google::protobuf::uint32 value) {
  set_has_value_length();
  value_length_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.value_length)
}

// optional string key = 6;
inline bool Preedit_Segment::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Preedit_Segment::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Preedit_Segment::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Preedit_Segment::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Preedit_Segment::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.Segment.key)
  return key_.GetNoArena();
}
inline void Preedit_Segment::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.Segment.key)
}
#if LANG_CXX11
inline void Preedit_Segment::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Preedit.Segment.key)
}
#endif
inline void Preedit_Segment::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Preedit.Segment.key)
}
inline void Preedit_Segment::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Preedit.Segment.key)
}
inline ::std::string* Preedit_Segment::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.Segment.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Preedit_Segment::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Preedit.Segment.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Preedit_Segment::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Preedit.Segment.key)
}

// -------------------------------------------------------------------

// Preedit

// required uint32 cursor = 1;
inline bool Preedit::has_cursor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Preedit::set_has_cursor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Preedit::clear_has_cursor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Preedit::clear_cursor() {
  cursor_ = 0u;
  clear_has_cursor();
}
inline ::google::protobuf::uint32 Preedit::cursor() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.cursor)
  return cursor_;
}
inline void Preedit::set_cursor(::google::protobuf::uint32 value) {
  set_has_cursor();
  cursor_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.cursor)
}

// repeated group Segment = 2 { ... };
inline int Preedit::segment_size() const {
  return segment_.size();
}
inline void Preedit::clear_segment() {
  segment_.Clear();
}
inline ::mozc::commands::Preedit_Segment* Preedit::mutable_segment(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Preedit.segment)
  return segment_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
Preedit::mutable_segment() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Preedit.segment)
  return &segment_;
}
inline const ::mozc::commands::Preedit_Segment& Preedit::segment(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.segment)
  return segment_.Get(index);
}
inline ::mozc::commands::Preedit_Segment* Preedit::add_segment() {
  // @@protoc_insertion_point(field_add:mozc.commands.Preedit.segment)
  return segment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
Preedit::segment() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Preedit.segment)
  return segment_;
}

// optional uint32 highlighted_position = 3;
inline bool Preedit::has_highlighted_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Preedit::set_has_highlighted_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Preedit::clear_has_highlighted_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Preedit::clear_highlighted_position() {
  highlighted_position_ = 0u;
  clear_has_highlighted_position();
}
inline ::google::protobuf::uint32 Preedit::highlighted_position() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Preedit.highlighted_position)
  return highlighted_position_;
}
inline void Preedit::set_highlighted_position(::google::protobuf::uint32 value) {
  set_has_highlighted_position();
  highlighted_position_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Preedit.highlighted_position)
}

// -------------------------------------------------------------------

// Status

// optional bool activated = 1;
inline bool Status::has_activated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_activated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_activated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_activated() {
  activated_ = false;
  clear_has_activated();
}
inline bool Status::activated() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.activated)
  return activated_;
}
inline void Status::set_activated(bool value) {
  set_has_activated();
  activated_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Status.activated)
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Status::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode Status::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.mode)
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void Status::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Status.mode)
}

// optional .mozc.commands.CompositionMode comeback_mode = 3;
inline bool Status::has_comeback_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_comeback_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_comeback_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_comeback_mode() {
  comeback_mode_ = 0;
  clear_has_comeback_mode();
}
inline ::mozc::commands::CompositionMode Status::comeback_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Status.comeback_mode)
  return static_cast< ::mozc::commands::CompositionMode >(comeback_mode_);
}
inline void Status::set_comeback_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_comeback_mode();
  comeback_mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Status.comeback_mode)
}

// -------------------------------------------------------------------

// DeletionRange

// optional int32 offset = 1;
inline bool DeletionRange::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeletionRange::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeletionRange::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeletionRange::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 DeletionRange::offset() const {
  // @@protoc_insertion_point(field_get:mozc.commands.DeletionRange.offset)
  return offset_;
}
inline void DeletionRange::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.DeletionRange.offset)
}

// optional int32 length = 2;
inline bool DeletionRange::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeletionRange::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeletionRange::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeletionRange::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 DeletionRange::length() const {
  // @@protoc_insertion_point(field_get:mozc.commands.DeletionRange.length)
  return length_;
}
inline void DeletionRange::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.DeletionRange.length)
}

// -------------------------------------------------------------------

// Output_Callback

// optional .mozc.commands.SessionCommand session_command = 1;
inline bool Output_Callback::has_session_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output_Callback::set_has_session_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output_Callback::clear_has_session_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output_Callback::clear_session_command() {
  if (session_command_ != NULL) session_command_->Clear();
  clear_has_session_command();
}
inline const ::mozc::commands::SessionCommand& Output_Callback::_internal_session_command() const {
  return *session_command_;
}
inline const ::mozc::commands::SessionCommand& Output_Callback::session_command() const {
  const ::mozc::commands::SessionCommand* p = session_command_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.Callback.session_command)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::SessionCommand*>(
      &::mozc::commands::_SessionCommand_default_instance_);
}
inline ::mozc::commands::SessionCommand* Output_Callback::release_session_command() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.Callback.session_command)
  clear_has_session_command();
  ::mozc::commands::SessionCommand* temp = session_command_;
  session_command_ = NULL;
  return temp;
}
inline ::mozc::commands::SessionCommand* Output_Callback::mutable_session_command() {
  set_has_session_command();
  if (session_command_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::SessionCommand>(GetArenaNoVirtual());
    session_command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.Callback.session_command)
  return session_command_;
}
inline void Output_Callback::set_allocated_session_command(::mozc::commands::SessionCommand* session_command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete session_command_;
  }
  if (session_command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      session_command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, session_command, submessage_arena);
    }
    set_has_session_command();
  } else {
    clear_has_session_command();
  }
  session_command_ = session_command;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.Callback.session_command)
}

// optional uint32 delay_millisec = 2;
inline bool Output_Callback::has_delay_millisec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output_Callback::set_has_delay_millisec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output_Callback::clear_has_delay_millisec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output_Callback::clear_delay_millisec() {
  delay_millisec_ = 0u;
  clear_has_delay_millisec();
}
inline ::google::protobuf::uint32 Output_Callback::delay_millisec() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.Callback.delay_millisec)
  return delay_millisec_;
}
inline void Output_Callback::set_delay_millisec(::google::protobuf::uint32 value) {
  set_has_delay_millisec();
  delay_millisec_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.Callback.delay_millisec)
}

// -------------------------------------------------------------------

// Output

// optional uint64 id = 1;
inline bool Output::has_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Output::set_has_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Output::clear_has_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Output::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Output::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.id)
  return id_;
}
inline void Output::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.id)
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Output::has_mode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Output::set_has_mode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Output::clear_has_mode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Output::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode Output::mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.mode)
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void Output::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.mode)
}

// optional bool consumed = 3;
inline bool Output::has_consumed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Output::set_has_consumed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Output::clear_has_consumed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Output::clear_consumed() {
  consumed_ = false;
  clear_has_consumed();
}
inline bool Output::consumed() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.consumed)
  return consumed_;
}
inline void Output::set_consumed(bool value) {
  set_has_consumed();
  consumed_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.consumed)
}

// optional .mozc.commands.Result result = 4;
inline bool Output::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_result() {
  if (result_ != NULL) result_->Clear();
  clear_has_result();
}
inline const ::mozc::commands::Result& Output::_internal_result() const {
  return *result_;
}
inline const ::mozc::commands::Result& Output::result() const {
  const ::mozc::commands::Result* p = result_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Result*>(
      &::mozc::commands::_Result_default_instance_);
}
inline ::mozc::commands::Result* Output::release_result() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.result)
  clear_has_result();
  ::mozc::commands::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mozc::commands::Result* Output::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Result>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.result)
  return result_;
}
inline void Output::set_allocated_result(::mozc::commands::Result* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.result)
}

// optional .mozc.commands.Preedit preedit = 5;
inline bool Output::has_preedit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Output::set_has_preedit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Output::clear_has_preedit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Output::clear_preedit() {
  if (preedit_ != NULL) preedit_->Clear();
  clear_has_preedit();
}
inline const ::mozc::commands::Preedit& Output::_internal_preedit() const {
  return *preedit_;
}
inline const ::mozc::commands::Preedit& Output::preedit() const {
  const ::mozc::commands::Preedit* p = preedit_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.preedit)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Preedit*>(
      &::mozc::commands::_Preedit_default_instance_);
}
inline ::mozc::commands::Preedit* Output::release_preedit() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.preedit)
  clear_has_preedit();
  ::mozc::commands::Preedit* temp = preedit_;
  preedit_ = NULL;
  return temp;
}
inline ::mozc::commands::Preedit* Output::mutable_preedit() {
  set_has_preedit();
  if (preedit_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Preedit>(GetArenaNoVirtual());
    preedit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.preedit)
  return preedit_;
}
inline void Output::set_allocated_preedit(::mozc::commands::Preedit* preedit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete preedit_;
  }
  if (preedit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      preedit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, preedit, submessage_arena);
    }
    set_has_preedit();
  } else {
    clear_has_preedit();
  }
  preedit_ = preedit;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.preedit)
}

// optional .mozc.commands.Candidates candidates = 6;
inline bool Output::has_candidates() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Output::set_has_candidates() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Output::clear_has_candidates() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mozc::commands::Candidates& Output::_internal_candidates() const {
  return *candidates_;
}
inline const ::mozc::commands::Candidates& Output::candidates() const {
  const ::mozc::commands::Candidates* p = candidates_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.candidates)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Candidates*>(
      &::mozc::commands::_Candidates_default_instance_);
}
inline ::mozc::commands::Candidates* Output::release_candidates() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.candidates)
  clear_has_candidates();
  ::mozc::commands::Candidates* temp = candidates_;
  candidates_ = NULL;
  return temp;
}
inline ::mozc::commands::Candidates* Output::mutable_candidates() {
  set_has_candidates();
  if (candidates_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Candidates>(GetArenaNoVirtual());
    candidates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.candidates)
  return candidates_;
}
inline void Output::set_allocated_candidates(::mozc::commands::Candidates* candidates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(candidates_);
  }
  if (candidates) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      candidates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, candidates, submessage_arena);
    }
    set_has_candidates();
  } else {
    clear_has_candidates();
  }
  candidates_ = candidates;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.candidates)
}

// optional .mozc.commands.KeyEvent key = 7;
inline bool Output::has_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Output::set_has_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Output::clear_has_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Output::clear_key() {
  if (key_ != NULL) key_->Clear();
  clear_has_key();
}
inline const ::mozc::commands::KeyEvent& Output::_internal_key() const {
  return *key_;
}
inline const ::mozc::commands::KeyEvent& Output::key() const {
  const ::mozc::commands::KeyEvent* p = key_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.key)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::KeyEvent*>(
      &::mozc::commands::_KeyEvent_default_instance_);
}
inline ::mozc::commands::KeyEvent* Output::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.key)
  clear_has_key();
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::mozc::commands::KeyEvent* Output::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::KeyEvent>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.key)
  return key_;
}
inline void Output::set_allocated_key(::mozc::commands::KeyEvent* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.key)
}

// optional string url = 8;
inline bool Output::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Output::url() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.url)
  return url_.GetNoArena();
}
inline void Output::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Output.url)
}
#if LANG_CXX11
inline void Output::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Output.url)
}
#endif
inline void Output::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Output.url)
}
inline void Output::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Output.url)
}
inline ::std::string* Output::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_url() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.url)
  if (!has_url()) {
    return NULL;
  }
  clear_has_url();
  return url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.url)
}

// optional .mozc.config.Config config = 9;
inline bool Output::has_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Output::set_has_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Output::clear_has_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mozc::config::Config& Output::_internal_config() const {
  return *config_;
}
inline const ::mozc::config::Config& Output::config() const {
  const ::mozc::config::Config* p = config_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.config)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::config::Config*>(
      &::mozc::config::_Config_default_instance_);
}
inline ::mozc::config::Config* Output::release_config() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.config)
  clear_has_config();
  ::mozc::config::Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::mozc::config::Config* Output::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::config::Config>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.config)
  return config_;
}
inline void Output::set_allocated_config(::mozc::config::Config* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.config)
}

// optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
inline bool Output::has_preedit_method() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Output::set_has_preedit_method() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Output::clear_has_preedit_method() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Output::clear_preedit_method() {
  preedit_method_ = 0;
  clear_has_preedit_method();
}
inline ::mozc::commands::Output_PreeditMethod Output::preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.preedit_method)
  return static_cast< ::mozc::commands::Output_PreeditMethod >(preedit_method_);
}
inline void Output::set_preedit_method(::mozc::commands::Output_PreeditMethod value) {
  assert(::mozc::commands::Output_PreeditMethod_IsValid(value));
  set_has_preedit_method();
  preedit_method_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.preedit_method)
}

// optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
inline bool Output::has_error_code() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Output::set_has_error_code() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Output::clear_has_error_code() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Output::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::mozc::commands::Output_ErrorCode Output::error_code() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.error_code)
  return static_cast< ::mozc::commands::Output_ErrorCode >(error_code_);
}
inline void Output::set_error_code(::mozc::commands::Output_ErrorCode value) {
  assert(::mozc::commands::Output_ErrorCode_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.error_code)
}

// optional .mozc.commands.Status status = 13;
inline bool Output::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Output::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Output::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Output::clear_status() {
  if (status_ != NULL) status_->Clear();
  clear_has_status();
}
inline const ::mozc::commands::Status& Output::_internal_status() const {
  return *status_;
}
inline const ::mozc::commands::Status& Output::status() const {
  const ::mozc::commands::Status* p = status_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Status*>(
      &::mozc::commands::_Status_default_instance_);
}
inline ::mozc::commands::Status* Output::release_status() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.status)
  clear_has_status();
  ::mozc::commands::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mozc::commands::Status* Output::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.status)
  return status_;
}
inline void Output::set_allocated_status(::mozc::commands::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.status)
}

// optional .mozc.commands.CandidateList all_candidate_words = 14;
inline bool Output::has_all_candidate_words() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Output::set_has_all_candidate_words() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Output::clear_has_all_candidate_words() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mozc::commands::CandidateList& Output::_internal_all_candidate_words() const {
  return *all_candidate_words_;
}
inline const ::mozc::commands::CandidateList& Output::all_candidate_words() const {
  const ::mozc::commands::CandidateList* p = all_candidate_words_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.all_candidate_words)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::CandidateList*>(
      &::mozc::commands::_CandidateList_default_instance_);
}
inline ::mozc::commands::CandidateList* Output::release_all_candidate_words() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.all_candidate_words)
  clear_has_all_candidate_words();
  ::mozc::commands::CandidateList* temp = all_candidate_words_;
  all_candidate_words_ = NULL;
  return temp;
}
inline ::mozc::commands::CandidateList* Output::mutable_all_candidate_words() {
  set_has_all_candidate_words();
  if (all_candidate_words_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::CandidateList>(GetArenaNoVirtual());
    all_candidate_words_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.all_candidate_words)
  return all_candidate_words_;
}
inline void Output::set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(all_candidate_words_);
  }
  if (all_candidate_words) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      all_candidate_words = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, all_candidate_words, submessage_arena);
    }
    set_has_all_candidate_words();
  } else {
    clear_has_all_candidate_words();
  }
  all_candidate_words_ = all_candidate_words;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.all_candidate_words)
}

// optional .mozc.commands.DeletionRange deletion_range = 16;
inline bool Output::has_deletion_range() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Output::set_has_deletion_range() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Output::clear_has_deletion_range() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Output::clear_deletion_range() {
  if (deletion_range_ != NULL) deletion_range_->Clear();
  clear_has_deletion_range();
}
inline const ::mozc::commands::DeletionRange& Output::_internal_deletion_range() const {
  return *deletion_range_;
}
inline const ::mozc::commands::DeletionRange& Output::deletion_range() const {
  const ::mozc::commands::DeletionRange* p = deletion_range_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.deletion_range)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::DeletionRange*>(
      &::mozc::commands::_DeletionRange_default_instance_);
}
inline ::mozc::commands::DeletionRange* Output::release_deletion_range() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.deletion_range)
  clear_has_deletion_range();
  ::mozc::commands::DeletionRange* temp = deletion_range_;
  deletion_range_ = NULL;
  return temp;
}
inline ::mozc::commands::DeletionRange* Output::mutable_deletion_range() {
  set_has_deletion_range();
  if (deletion_range_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::DeletionRange>(GetArenaNoVirtual());
    deletion_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.deletion_range)
  return deletion_range_;
}
inline void Output::set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete deletion_range_;
  }
  if (deletion_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deletion_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deletion_range, submessage_arena);
    }
    set_has_deletion_range();
  } else {
    clear_has_deletion_range();
  }
  deletion_range_ = deletion_range;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.deletion_range)
}

// optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
inline bool Output::has_launch_tool_mode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Output::set_has_launch_tool_mode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Output::clear_has_launch_tool_mode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Output::clear_launch_tool_mode() {
  launch_tool_mode_ = 0;
  clear_has_launch_tool_mode();
}
inline ::mozc::commands::Output_ToolMode Output::launch_tool_mode() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Output.launch_tool_mode)
  return static_cast< ::mozc::commands::Output_ToolMode >(launch_tool_mode_);
}
inline void Output::set_launch_tool_mode(::mozc::commands::Output_ToolMode value) {
  assert(::mozc::commands::Output_ToolMode_IsValid(value));
  set_has_launch_tool_mode();
  launch_tool_mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Output.launch_tool_mode)
}

// optional .mozc.commands.Output.Callback callback = 18;
inline bool Output::has_callback() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Output::set_has_callback() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Output::clear_has_callback() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Output::clear_callback() {
  if (callback_ != NULL) callback_->Clear();
  clear_has_callback();
}
inline const ::mozc::commands::Output_Callback& Output::_internal_callback() const {
  return *callback_;
}
inline const ::mozc::commands::Output_Callback& Output::callback() const {
  const ::mozc::commands::Output_Callback* p = callback_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.callback)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Output_Callback*>(
      &::mozc::commands::_Output_Callback_default_instance_);
}
inline ::mozc::commands::Output_Callback* Output::release_callback() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.callback)
  clear_has_callback();
  ::mozc::commands::Output_Callback* temp = callback_;
  callback_ = NULL;
  return temp;
}
inline ::mozc::commands::Output_Callback* Output::mutable_callback() {
  set_has_callback();
  if (callback_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Output_Callback>(GetArenaNoVirtual());
    callback_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.callback)
  return callback_;
}
inline void Output::set_allocated_callback(::mozc::commands::Output_Callback* callback) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete callback_;
  }
  if (callback) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      callback = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, callback, submessage_arena);
    }
    set_has_callback();
  } else {
    clear_has_callback();
  }
  callback_ = callback;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.callback)
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 19;
inline bool Output::has_storage_entry() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Output::set_has_storage_entry() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Output::clear_has_storage_entry() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Output::clear_storage_entry() {
  if (storage_entry_ != NULL) storage_entry_->Clear();
  clear_has_storage_entry();
}
inline const ::mozc::commands::GenericStorageEntry& Output::_internal_storage_entry() const {
  return *storage_entry_;
}
inline const ::mozc::commands::GenericStorageEntry& Output::storage_entry() const {
  const ::mozc::commands::GenericStorageEntry* p = storage_entry_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.storage_entry)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::GenericStorageEntry*>(
      &::mozc::commands::_GenericStorageEntry_default_instance_);
}
inline ::mozc::commands::GenericStorageEntry* Output::release_storage_entry() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.storage_entry)
  clear_has_storage_entry();
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = NULL;
  return temp;
}
inline ::mozc::commands::GenericStorageEntry* Output::mutable_storage_entry() {
  set_has_storage_entry();
  if (storage_entry_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::GenericStorageEntry>(GetArenaNoVirtual());
    storage_entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.storage_entry)
  return storage_entry_;
}
inline void Output::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_entry_;
  }
  if (storage_entry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage_entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage_entry, submessage_arena);
    }
    set_has_storage_entry();
  } else {
    clear_has_storage_entry();
  }
  storage_entry_ = storage_entry;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.storage_entry)
}

// optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
inline bool Output::has_user_dictionary_command_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Output::set_has_user_dictionary_command_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Output::clear_has_user_dictionary_command_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& Output::_internal_user_dictionary_command_status() const {
  return *user_dictionary_command_status_;
}
inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& Output::user_dictionary_command_status() const {
  const ::mozc::user_dictionary::UserDictionaryCommandStatus* p = user_dictionary_command_status_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.user_dictionary_command_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::user_dictionary::UserDictionaryCommandStatus*>(
      &::mozc::user_dictionary::_UserDictionaryCommandStatus_default_instance_);
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::release_user_dictionary_command_status() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.user_dictionary_command_status)
  clear_has_user_dictionary_command_status();
  ::mozc::user_dictionary::UserDictionaryCommandStatus* temp = user_dictionary_command_status_;
  user_dictionary_command_status_ = NULL;
  return temp;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::mutable_user_dictionary_command_status() {
  set_has_user_dictionary_command_status();
  if (user_dictionary_command_status_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::user_dictionary::UserDictionaryCommandStatus>(GetArenaNoVirtual());
    user_dictionary_command_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.user_dictionary_command_status)
  return user_dictionary_command_status_;
}
inline void Output::set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_dictionary_command_status_);
  }
  if (user_dictionary_command_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_dictionary_command_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_dictionary_command_status, submessage_arena);
    }
    set_has_user_dictionary_command_status();
  } else {
    clear_has_user_dictionary_command_status();
  }
  user_dictionary_command_status_ = user_dictionary_command_status;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.user_dictionary_command_status)
}

// optional .mozc.EngineReloadResponse engine_reload_response = 22;
inline bool Output::has_engine_reload_response() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Output::set_has_engine_reload_response() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Output::clear_has_engine_reload_response() {
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::mozc::EngineReloadResponse& Output::_internal_engine_reload_response() const {
  return *engine_reload_response_;
}
inline const ::mozc::EngineReloadResponse& Output::engine_reload_response() const {
  const ::mozc::EngineReloadResponse* p = engine_reload_response_;
  // @@protoc_insertion_point(field_get:mozc.commands.Output.engine_reload_response)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::EngineReloadResponse*>(
      &::mozc::_EngineReloadResponse_default_instance_);
}
inline ::mozc::EngineReloadResponse* Output::release_engine_reload_response() {
  // @@protoc_insertion_point(field_release:mozc.commands.Output.engine_reload_response)
  clear_has_engine_reload_response();
  ::mozc::EngineReloadResponse* temp = engine_reload_response_;
  engine_reload_response_ = NULL;
  return temp;
}
inline ::mozc::EngineReloadResponse* Output::mutable_engine_reload_response() {
  set_has_engine_reload_response();
  if (engine_reload_response_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::EngineReloadResponse>(GetArenaNoVirtual());
    engine_reload_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Output.engine_reload_response)
  return engine_reload_response_;
}
inline void Output::set_allocated_engine_reload_response(::mozc::EngineReloadResponse* engine_reload_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(engine_reload_response_);
  }
  if (engine_reload_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      engine_reload_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, engine_reload_response, submessage_arena);
    }
    set_has_engine_reload_response();
  } else {
    clear_has_engine_reload_response();
  }
  engine_reload_response_ = engine_reload_response;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Output.engine_reload_response)
}

// -------------------------------------------------------------------

// Command

// required .mozc.commands.Input input = 1;
inline bool Command::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_input() {
  if (input_ != NULL) input_->Clear();
  clear_has_input();
}
inline const ::mozc::commands::Input& Command::_internal_input() const {
  return *input_;
}
inline const ::mozc::commands::Input& Command::input() const {
  const ::mozc::commands::Input* p = input_;
  // @@protoc_insertion_point(field_get:mozc.commands.Command.input)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Input*>(
      &::mozc::commands::_Input_default_instance_);
}
inline ::mozc::commands::Input* Command::release_input() {
  // @@protoc_insertion_point(field_release:mozc.commands.Command.input)
  clear_has_input();
  ::mozc::commands::Input* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::mozc::commands::Input* Command::mutable_input() {
  set_has_input();
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Input>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Command.input)
  return input_;
}
inline void Command::set_allocated_input(::mozc::commands::Input* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    set_has_input();
  } else {
    clear_has_input();
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Command.input)
}

// required .mozc.commands.Output output = 2;
inline bool Command::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_output() {
  if (output_ != NULL) output_->Clear();
  clear_has_output();
}
inline const ::mozc::commands::Output& Command::_internal_output() const {
  return *output_;
}
inline const ::mozc::commands::Output& Command::output() const {
  const ::mozc::commands::Output* p = output_;
  // @@protoc_insertion_point(field_get:mozc.commands.Command.output)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Output*>(
      &::mozc::commands::_Output_default_instance_);
}
inline ::mozc::commands::Output* Command::release_output() {
  // @@protoc_insertion_point(field_release:mozc.commands.Command.output)
  clear_has_output();
  ::mozc::commands::Output* temp = output_;
  output_ = NULL;
  return temp;
}
inline ::mozc::commands::Output* Command::mutable_output() {
  set_has_output();
  if (output_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Output>(GetArenaNoVirtual());
    output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Command.output)
  return output_;
}
inline void Command::set_allocated_output(::mozc::commands::Output* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    set_has_output();
  } else {
    clear_has_output();
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Command.output)
}

// -------------------------------------------------------------------

// CommandList

// repeated .mozc.commands.Command commands = 1;
inline int CommandList::commands_size() const {
  return commands_.size();
}
inline void CommandList::clear_commands() {
  commands_.Clear();
}
inline ::mozc::commands::Command* CommandList::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.CommandList.commands)
  return commands_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >*
CommandList::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.CommandList.commands)
  return &commands_;
}
inline const ::mozc::commands::Command& CommandList::commands(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.CommandList.commands)
  return commands_.Get(index);
}
inline ::mozc::commands::Command* CommandList::add_commands() {
  // @@protoc_insertion_point(field_add:mozc.commands.CommandList.commands)
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >&
CommandList::commands() const {
  // @@protoc_insertion_point(field_list:mozc.commands.CommandList.commands)
  return commands_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace mozc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mozc::commands::KeyEvent_SpecialKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_SpecialKey>() {
  return ::mozc::commands::KeyEvent_SpecialKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::KeyEvent_ModifierKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_ModifierKey>() {
  return ::mozc::commands::KeyEvent_ModifierKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::KeyEvent_InputStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_InputStyle>() {
  return ::mozc::commands::KeyEvent_InputStyle_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::GenericStorageEntry_StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::GenericStorageEntry_StorageType>() {
  return ::mozc::commands::GenericStorageEntry_StorageType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::SessionCommand_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_CommandType>() {
  return ::mozc::commands::SessionCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::SessionCommand_UsageStatsEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_UsageStatsEvent>() {
  return ::mozc::commands::SessionCommand_UsageStatsEvent_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Context_InputFieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Context_InputFieldType>() {
  return ::mozc::commands::Context_InputFieldType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Capability_TextDeletionCapabilityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Capability_TextDeletionCapabilityType>() {
  return ::mozc::commands::Capability_TextDeletionCapabilityType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_SpecialRomanjiTable> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpecialRomanjiTable>() {
  return ::mozc::commands::Request_SpecialRomanjiTable_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_SpaceOnAlphanumeric> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpaceOnAlphanumeric>() {
  return ::mozc::commands::Request_SpaceOnAlphanumeric_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_EmojiCarrierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_EmojiCarrierType>() {
  return ::mozc::commands::Request_EmojiCarrierType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_RewriterCapability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_RewriterCapability>() {
  return ::mozc::commands::Request_RewriterCapability_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_CrossingEdgeBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_CrossingEdgeBehavior>() {
  return ::mozc::commands::Request_CrossingEdgeBehavior_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Request_LanguageAwareInputBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_LanguageAwareInputBehavior>() {
  return ::mozc::commands::Request_LanguageAwareInputBehavior_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Input_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_CommandType>() {
  return ::mozc::commands::Input_CommandType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Input_TouchAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_TouchAction>() {
  return ::mozc::commands::Input_TouchAction_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Result_ResultType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Result_ResultType>() {
  return ::mozc::commands::Result_ResultType_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Preedit_Segment_Annotation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Preedit_Segment_Annotation>() {
  return ::mozc::commands::Preedit_Segment_Annotation_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_PreeditMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_PreeditMethod>() {
  return ::mozc::commands::Output_PreeditMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ErrorCode>() {
  return ::mozc::commands::Output_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Output_ToolMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ToolMode>() {
  return ::mozc::commands::Output_ToolMode_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::CompositionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::CompositionMode>() {
  return ::mozc::commands::CompositionMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2fcommands_2eproto
