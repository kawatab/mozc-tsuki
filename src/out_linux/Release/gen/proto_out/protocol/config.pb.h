// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

#ifndef PROTOBUF_INCLUDED_protocol_2fconfig_2eproto
#define PROTOBUF_INCLUDED_protocol_2fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2fconfig_2eproto 

namespace protobuf_protocol_2fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2fconfig_2eproto
namespace mozc {
namespace config {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Config_CharacterFormRule;
class Config_CharacterFormRuleDefaultTypeInternal;
extern Config_CharacterFormRuleDefaultTypeInternal _Config_CharacterFormRule_default_instance_;
class Config_InformationListConfig;
class Config_InformationListConfigDefaultTypeInternal;
extern Config_InformationListConfigDefaultTypeInternal _Config_InformationListConfig_default_instance_;
class GeneralConfig;
class GeneralConfigDefaultTypeInternal;
extern GeneralConfigDefaultTypeInternal _GeneralConfig_default_instance_;
}  // namespace config
}  // namespace mozc
namespace google {
namespace protobuf {
template<> ::mozc::config::Config* Arena::CreateMaybeMessage<::mozc::config::Config>(Arena*);
template<> ::mozc::config::Config_CharacterFormRule* Arena::CreateMaybeMessage<::mozc::config::Config_CharacterFormRule>(Arena*);
template<> ::mozc::config::Config_InformationListConfig* Arena::CreateMaybeMessage<::mozc::config::Config_InformationListConfig>(Arena*);
template<> ::mozc::config::GeneralConfig* Arena::CreateMaybeMessage<::mozc::config::GeneralConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mozc {
namespace config {

enum Config_PreeditMethod {
  Config_PreeditMethod_ROMAN = 0,
  Config_PreeditMethod_KANA = 1
};
bool Config_PreeditMethod_IsValid(int value);
const Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MIN = Config_PreeditMethod_ROMAN;
const Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MAX = Config_PreeditMethod_KANA;
const int Config_PreeditMethod_PreeditMethod_ARRAYSIZE = Config_PreeditMethod_PreeditMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_PreeditMethod_descriptor();
inline const ::std::string& Config_PreeditMethod_Name(Config_PreeditMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_PreeditMethod_descriptor(), value);
}
inline bool Config_PreeditMethod_Parse(
    const ::std::string& name, Config_PreeditMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PreeditMethod>(
    Config_PreeditMethod_descriptor(), name, value);
}
enum Config_SessionKeymap {
  Config_SessionKeymap_NONE = -1,
  Config_SessionKeymap_CUSTOM = 0,
  Config_SessionKeymap_ATOK = 1,
  Config_SessionKeymap_MSIME = 2,
  Config_SessionKeymap_KOTOERI = 3,
  Config_SessionKeymap_MOBILE = 4,
  Config_SessionKeymap_CHROMEOS = 5
};
bool Config_SessionKeymap_IsValid(int value);
const Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MIN = Config_SessionKeymap_NONE;
const Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MAX = Config_SessionKeymap_CHROMEOS;
const int Config_SessionKeymap_SessionKeymap_ARRAYSIZE = Config_SessionKeymap_SessionKeymap_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SessionKeymap_descriptor();
inline const ::std::string& Config_SessionKeymap_Name(Config_SessionKeymap value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SessionKeymap_descriptor(), value);
}
inline bool Config_SessionKeymap_Parse(
    const ::std::string& name, Config_SessionKeymap* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SessionKeymap>(
    Config_SessionKeymap_descriptor(), name, value);
}
enum Config_PunctuationMethod {
  Config_PunctuationMethod_KUTEN_TOUTEN = 0,
  Config_PunctuationMethod_COMMA_PERIOD = 1,
  Config_PunctuationMethod_KUTEN_PERIOD = 2,
  Config_PunctuationMethod_COMMA_TOUTEN = 3
};
bool Config_PunctuationMethod_IsValid(int value);
const Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MIN = Config_PunctuationMethod_KUTEN_TOUTEN;
const Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MAX = Config_PunctuationMethod_COMMA_TOUTEN;
const int Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE = Config_PunctuationMethod_PunctuationMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_PunctuationMethod_descriptor();
inline const ::std::string& Config_PunctuationMethod_Name(Config_PunctuationMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_PunctuationMethod_descriptor(), value);
}
inline bool Config_PunctuationMethod_Parse(
    const ::std::string& name, Config_PunctuationMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PunctuationMethod>(
    Config_PunctuationMethod_descriptor(), name, value);
}
enum Config_SymbolMethod {
  Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT = 0,
  Config_SymbolMethod_SQUARE_BRACKET_SLASH = 1,
  Config_SymbolMethod_CORNER_BRACKET_SLASH = 2,
  Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT = 3
};
bool Config_SymbolMethod_IsValid(int value);
const Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MIN = Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
const Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MAX = Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
const int Config_SymbolMethod_SymbolMethod_ARRAYSIZE = Config_SymbolMethod_SymbolMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SymbolMethod_descriptor();
inline const ::std::string& Config_SymbolMethod_Name(Config_SymbolMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SymbolMethod_descriptor(), value);
}
inline bool Config_SymbolMethod_Parse(
    const ::std::string& name, Config_SymbolMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SymbolMethod>(
    Config_SymbolMethod_descriptor(), name, value);
}
enum Config_FundamentalCharacterForm {
  Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE = 0,
  Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH = 1,
  Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH = 2
};
bool Config_FundamentalCharacterForm_IsValid(int value);
const Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN = Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
const Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX = Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
const int Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE = Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_FundamentalCharacterForm_descriptor();
inline const ::std::string& Config_FundamentalCharacterForm_Name(Config_FundamentalCharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_FundamentalCharacterForm_descriptor(), value);
}
inline bool Config_FundamentalCharacterForm_Parse(
    const ::std::string& name, Config_FundamentalCharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_FundamentalCharacterForm>(
    Config_FundamentalCharacterForm_descriptor(), name, value);
}
enum Config_HistoryLearningLevel {
  Config_HistoryLearningLevel_DEFAULT_HISTORY = 0,
  Config_HistoryLearningLevel_READ_ONLY = 1,
  Config_HistoryLearningLevel_NO_HISTORY = 2
};
bool Config_HistoryLearningLevel_IsValid(int value);
const Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MIN = Config_HistoryLearningLevel_DEFAULT_HISTORY;
const Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MAX = Config_HistoryLearningLevel_NO_HISTORY;
const int Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE = Config_HistoryLearningLevel_HistoryLearningLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_HistoryLearningLevel_descriptor();
inline const ::std::string& Config_HistoryLearningLevel_Name(Config_HistoryLearningLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_HistoryLearningLevel_descriptor(), value);
}
inline bool Config_HistoryLearningLevel_Parse(
    const ::std::string& name, Config_HistoryLearningLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_HistoryLearningLevel>(
    Config_HistoryLearningLevel_descriptor(), name, value);
}
enum Config_SelectionShortcut {
  Config_SelectionShortcut_NO_SHORTCUT = 0,
  Config_SelectionShortcut_SHORTCUT_123456789 = 1,
  Config_SelectionShortcut_SHORTCUT_ASDFGHJKL = 2
};
bool Config_SelectionShortcut_IsValid(int value);
const Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MIN = Config_SelectionShortcut_NO_SHORTCUT;
const Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MAX = Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
const int Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE = Config_SelectionShortcut_SelectionShortcut_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SelectionShortcut_descriptor();
inline const ::std::string& Config_SelectionShortcut_Name(Config_SelectionShortcut value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SelectionShortcut_descriptor(), value);
}
inline bool Config_SelectionShortcut_Parse(
    const ::std::string& name, Config_SelectionShortcut* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SelectionShortcut>(
    Config_SelectionShortcut_descriptor(), name, value);
}
enum Config_CharacterForm {
  Config_CharacterForm_HALF_WIDTH = 0,
  Config_CharacterForm_FULL_WIDTH = 1,
  Config_CharacterForm_LAST_FORM = 2,
  Config_CharacterForm_NO_CONVERSION = 3
};
bool Config_CharacterForm_IsValid(int value);
const Config_CharacterForm Config_CharacterForm_CharacterForm_MIN = Config_CharacterForm_HALF_WIDTH;
const Config_CharacterForm Config_CharacterForm_CharacterForm_MAX = Config_CharacterForm_NO_CONVERSION;
const int Config_CharacterForm_CharacterForm_ARRAYSIZE = Config_CharacterForm_CharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_CharacterForm_descriptor();
inline const ::std::string& Config_CharacterForm_Name(Config_CharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_CharacterForm_descriptor(), value);
}
inline bool Config_CharacterForm_Parse(
    const ::std::string& name, Config_CharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_CharacterForm>(
    Config_CharacterForm_descriptor(), name, value);
}
enum Config_ShiftKeyModeSwitch {
  Config_ShiftKeyModeSwitch_OFF = 0,
  Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE = 1,
  Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE = 2
};
bool Config_ShiftKeyModeSwitch_IsValid(int value);
const Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN = Config_ShiftKeyModeSwitch_OFF;
const Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX = Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
const int Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE = Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_ShiftKeyModeSwitch_descriptor();
inline const ::std::string& Config_ShiftKeyModeSwitch_Name(Config_ShiftKeyModeSwitch value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_ShiftKeyModeSwitch_descriptor(), value);
}
inline bool Config_ShiftKeyModeSwitch_Parse(
    const ::std::string& name, Config_ShiftKeyModeSwitch* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_ShiftKeyModeSwitch>(
    Config_ShiftKeyModeSwitch_descriptor(), name, value);
}
enum Config_NumpadCharacterForm {
  Config_NumpadCharacterForm_NUMPAD_INPUT_MODE = 0,
  Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH = 1,
  Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH = 2,
  Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT = 3
};
bool Config_NumpadCharacterForm_IsValid(int value);
const Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MIN = Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
const Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MAX = Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
const int Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE = Config_NumpadCharacterForm_NumpadCharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_NumpadCharacterForm_descriptor();
inline const ::std::string& Config_NumpadCharacterForm_Name(Config_NumpadCharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_NumpadCharacterForm_descriptor(), value);
}
inline bool Config_NumpadCharacterForm_Parse(
    const ::std::string& name, Config_NumpadCharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_NumpadCharacterForm>(
    Config_NumpadCharacterForm_descriptor(), name, value);
}
enum Config_AutoConversionKey {
  Config_AutoConversionKey_AUTO_CONVERSION_OFF = 0,
  Config_AutoConversionKey_AUTO_CONVERSION_KUTEN = 1,
  Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN = 2,
  Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK = 4,
  Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK = 8
};
bool Config_AutoConversionKey_IsValid(int value);
const Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MIN = Config_AutoConversionKey_AUTO_CONVERSION_OFF;
const Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MAX = Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
const int Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE = Config_AutoConversionKey_AutoConversionKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_AutoConversionKey_descriptor();
inline const ::std::string& Config_AutoConversionKey_Name(Config_AutoConversionKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_AutoConversionKey_descriptor(), value);
}
inline bool Config_AutoConversionKey_Parse(
    const ::std::string& name, Config_AutoConversionKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_AutoConversionKey>(
    Config_AutoConversionKey_descriptor(), name, value);
}
enum Config_YenSignCharacter {
  Config_YenSignCharacter_YEN_SIGN = 0,
  Config_YenSignCharacter_BACKSLASH = 1
};
bool Config_YenSignCharacter_IsValid(int value);
const Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MIN = Config_YenSignCharacter_YEN_SIGN;
const Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MAX = Config_YenSignCharacter_BACKSLASH;
const int Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE = Config_YenSignCharacter_YenSignCharacter_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_YenSignCharacter_descriptor();
inline const ::std::string& Config_YenSignCharacter_Name(Config_YenSignCharacter value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_YenSignCharacter_descriptor(), value);
}
inline bool Config_YenSignCharacter_Parse(
    const ::std::string& name, Config_YenSignCharacter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_YenSignCharacter>(
    Config_YenSignCharacter_descriptor(), name, value);
}
// ===================================================================

class GeneralConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.config.GeneralConfig) */ {
 public:
  GeneralConfig();
  virtual ~GeneralConfig();

  GeneralConfig(const GeneralConfig& from);

  inline GeneralConfig& operator=(const GeneralConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralConfig(GeneralConfig&& from) noexcept
    : GeneralConfig() {
    *this = ::std::move(from);
  }

  inline GeneralConfig& operator=(GeneralConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralConfig* internal_default_instance() {
    return reinterpret_cast<const GeneralConfig*>(
               &_GeneralConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GeneralConfig* other);
  friend void swap(GeneralConfig& a, GeneralConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralConfig* New() const final {
    return CreateMaybeMessage<GeneralConfig>(NULL);
  }

  GeneralConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeneralConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeneralConfig& from);
  void MergeFrom(const GeneralConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
  bool has_last_modified_product_version() const;
  void clear_last_modified_product_version();
  static const int kLastModifiedProductVersionFieldNumber = 2;
  const ::std::string& last_modified_product_version() const;
  void set_last_modified_product_version(const ::std::string& value);
  #if LANG_CXX11
  void set_last_modified_product_version(::std::string&& value);
  #endif
  void set_last_modified_product_version(const char* value);
  void set_last_modified_product_version(const char* value, size_t size);
  ::std::string* mutable_last_modified_product_version();
  ::std::string* release_last_modified_product_version();
  void set_allocated_last_modified_product_version(::std::string* last_modified_product_version);

  // optional string platform = 4 [default = ""];
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 4;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // optional string ui_locale = 5 [default = ""];
  bool has_ui_locale() const;
  void clear_ui_locale();
  static const int kUiLocaleFieldNumber = 5;
  const ::std::string& ui_locale() const;
  void set_ui_locale(const ::std::string& value);
  #if LANG_CXX11
  void set_ui_locale(::std::string&& value);
  #endif
  void set_ui_locale(const char* value);
  void set_ui_locale(const char* value, size_t size);
  ::std::string* mutable_ui_locale();
  ::std::string* release_ui_locale();
  void set_allocated_ui_locale(::std::string* ui_locale);

  // optional uint64 last_modified_time = 3 [default = 0];
  bool has_last_modified_time() const;
  void clear_last_modified_time();
  static const int kLastModifiedTimeFieldNumber = 3;
  ::google::protobuf::uint64 last_modified_time() const;
  void set_last_modified_time(::google::protobuf::uint64 value);

  // optional uint32 config_version = 1 [default = 0];
  bool has_config_version() const;
  void clear_config_version();
  static const int kConfigVersionFieldNumber = 1;
  ::google::protobuf::uint32 config_version() const;
  void set_config_version(::google::protobuf::uint32 value);

  // optional bool upload_usage_stats = 6 [default = false];
  bool has_upload_usage_stats() const;
  void clear_upload_usage_stats();
  static const int kUploadUsageStatsFieldNumber = 6;
  bool upload_usage_stats() const;
  void set_upload_usage_stats(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
 private:
  void set_has_config_version();
  void clear_has_config_version();
  void set_has_last_modified_product_version();
  void clear_has_last_modified_product_version();
  void set_has_last_modified_time();
  void clear_has_last_modified_time();
  void set_has_platform();
  void clear_has_platform();
  void set_has_ui_locale();
  void clear_has_ui_locale();
  void set_has_upload_usage_stats();
  void clear_has_upload_usage_stats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_last_modified_product_version_;
  private:
  ::google::protobuf::internal::ArenaStringPtr last_modified_product_version_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr ui_locale_;
  ::google::protobuf::uint64 last_modified_time_;
  ::google::protobuf::uint32 config_version_;
  bool upload_usage_stats_;
  friend struct ::protobuf_protocol_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config_CharacterFormRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config.CharacterFormRule) */ {
 public:
  Config_CharacterFormRule();
  virtual ~Config_CharacterFormRule();

  Config_CharacterFormRule(const Config_CharacterFormRule& from);

  inline Config_CharacterFormRule& operator=(const Config_CharacterFormRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config_CharacterFormRule(Config_CharacterFormRule&& from) noexcept
    : Config_CharacterFormRule() {
    *this = ::std::move(from);
  }

  inline Config_CharacterFormRule& operator=(Config_CharacterFormRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config_CharacterFormRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config_CharacterFormRule* internal_default_instance() {
    return reinterpret_cast<const Config_CharacterFormRule*>(
               &_Config_CharacterFormRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Config_CharacterFormRule* other);
  friend void swap(Config_CharacterFormRule& a, Config_CharacterFormRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config_CharacterFormRule* New() const final {
    return CreateMaybeMessage<Config_CharacterFormRule>(NULL);
  }

  Config_CharacterFormRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config_CharacterFormRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config_CharacterFormRule& from);
  void MergeFrom(const Config_CharacterFormRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_CharacterFormRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group = 1;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 1;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
  bool has_preedit_character_form() const;
  void clear_preedit_character_form();
  static const int kPreeditCharacterFormFieldNumber = 2;
  ::mozc::config::Config_CharacterForm preedit_character_form() const;
  void set_preedit_character_form(::mozc::config::Config_CharacterForm value);

  // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
  bool has_conversion_character_form() const;
  void clear_conversion_character_form();
  static const int kConversionCharacterFormFieldNumber = 3;
  ::mozc::config::Config_CharacterForm conversion_character_form() const;
  void set_conversion_character_form(::mozc::config::Config_CharacterForm value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
 private:
  void set_has_group();
  void clear_has_group();
  void set_has_preedit_character_form();
  void clear_has_preedit_character_form();
  void set_has_conversion_character_form();
  void clear_has_conversion_character_form();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  int preedit_character_form_;
  int conversion_character_form_;
  friend struct ::protobuf_protocol_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config_InformationListConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config.InformationListConfig) */ {
 public:
  Config_InformationListConfig();
  virtual ~Config_InformationListConfig();

  Config_InformationListConfig(const Config_InformationListConfig& from);

  inline Config_InformationListConfig& operator=(const Config_InformationListConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config_InformationListConfig(Config_InformationListConfig&& from) noexcept
    : Config_InformationListConfig() {
    *this = ::std::move(from);
  }

  inline Config_InformationListConfig& operator=(Config_InformationListConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config_InformationListConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config_InformationListConfig* internal_default_instance() {
    return reinterpret_cast<const Config_InformationListConfig*>(
               &_Config_InformationListConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Config_InformationListConfig* other);
  friend void swap(Config_InformationListConfig& a, Config_InformationListConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config_InformationListConfig* New() const final {
    return CreateMaybeMessage<Config_InformationListConfig>(NULL);
  }

  Config_InformationListConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config_InformationListConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config_InformationListConfig& from);
  void MergeFrom(const Config_InformationListConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_InformationListConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_local_usage_dictionary = 1 [default = true];
  bool has_use_local_usage_dictionary() const;
  void clear_use_local_usage_dictionary();
  static const int kUseLocalUsageDictionaryFieldNumber = 1;
  bool use_local_usage_dictionary() const;
  void set_use_local_usage_dictionary(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
 private:
  void set_has_use_local_usage_dictionary();
  void clear_has_use_local_usage_dictionary();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_local_usage_dictionary_;
  friend struct ::protobuf_protocol_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.config.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_CharacterFormRule CharacterFormRule;
  typedef Config_InformationListConfig InformationListConfig;

  typedef Config_PreeditMethod PreeditMethod;
  static const PreeditMethod ROMAN =
    Config_PreeditMethod_ROMAN;
  static const PreeditMethod KANA =
    Config_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Config_PreeditMethod_IsValid(value);
  }
  static const PreeditMethod PreeditMethod_MIN =
    Config_PreeditMethod_PreeditMethod_MIN;
  static const PreeditMethod PreeditMethod_MAX =
    Config_PreeditMethod_PreeditMethod_MAX;
  static const int PreeditMethod_ARRAYSIZE =
    Config_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Config_PreeditMethod_descriptor();
  }
  static inline const ::std::string& PreeditMethod_Name(PreeditMethod value) {
    return Config_PreeditMethod_Name(value);
  }
  static inline bool PreeditMethod_Parse(const ::std::string& name,
      PreeditMethod* value) {
    return Config_PreeditMethod_Parse(name, value);
  }

  typedef Config_SessionKeymap SessionKeymap;
  static const SessionKeymap NONE =
    Config_SessionKeymap_NONE;
  static const SessionKeymap CUSTOM =
    Config_SessionKeymap_CUSTOM;
  static const SessionKeymap ATOK =
    Config_SessionKeymap_ATOK;
  static const SessionKeymap MSIME =
    Config_SessionKeymap_MSIME;
  static const SessionKeymap KOTOERI =
    Config_SessionKeymap_KOTOERI;
  static const SessionKeymap MOBILE =
    Config_SessionKeymap_MOBILE;
  static const SessionKeymap CHROMEOS =
    Config_SessionKeymap_CHROMEOS;
  static inline bool SessionKeymap_IsValid(int value) {
    return Config_SessionKeymap_IsValid(value);
  }
  static const SessionKeymap SessionKeymap_MIN =
    Config_SessionKeymap_SessionKeymap_MIN;
  static const SessionKeymap SessionKeymap_MAX =
    Config_SessionKeymap_SessionKeymap_MAX;
  static const int SessionKeymap_ARRAYSIZE =
    Config_SessionKeymap_SessionKeymap_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SessionKeymap_descriptor() {
    return Config_SessionKeymap_descriptor();
  }
  static inline const ::std::string& SessionKeymap_Name(SessionKeymap value) {
    return Config_SessionKeymap_Name(value);
  }
  static inline bool SessionKeymap_Parse(const ::std::string& name,
      SessionKeymap* value) {
    return Config_SessionKeymap_Parse(name, value);
  }

  typedef Config_PunctuationMethod PunctuationMethod;
  static const PunctuationMethod KUTEN_TOUTEN =
    Config_PunctuationMethod_KUTEN_TOUTEN;
  static const PunctuationMethod COMMA_PERIOD =
    Config_PunctuationMethod_COMMA_PERIOD;
  static const PunctuationMethod KUTEN_PERIOD =
    Config_PunctuationMethod_KUTEN_PERIOD;
  static const PunctuationMethod COMMA_TOUTEN =
    Config_PunctuationMethod_COMMA_TOUTEN;
  static inline bool PunctuationMethod_IsValid(int value) {
    return Config_PunctuationMethod_IsValid(value);
  }
  static const PunctuationMethod PunctuationMethod_MIN =
    Config_PunctuationMethod_PunctuationMethod_MIN;
  static const PunctuationMethod PunctuationMethod_MAX =
    Config_PunctuationMethod_PunctuationMethod_MAX;
  static const int PunctuationMethod_ARRAYSIZE =
    Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PunctuationMethod_descriptor() {
    return Config_PunctuationMethod_descriptor();
  }
  static inline const ::std::string& PunctuationMethod_Name(PunctuationMethod value) {
    return Config_PunctuationMethod_Name(value);
  }
  static inline bool PunctuationMethod_Parse(const ::std::string& name,
      PunctuationMethod* value) {
    return Config_PunctuationMethod_Parse(name, value);
  }

  typedef Config_SymbolMethod SymbolMethod;
  static const SymbolMethod CORNER_BRACKET_MIDDLE_DOT =
    Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
  static const SymbolMethod SQUARE_BRACKET_SLASH =
    Config_SymbolMethod_SQUARE_BRACKET_SLASH;
  static const SymbolMethod CORNER_BRACKET_SLASH =
    Config_SymbolMethod_CORNER_BRACKET_SLASH;
  static const SymbolMethod SQUARE_BRACKET_MIDDLE_DOT =
    Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
  static inline bool SymbolMethod_IsValid(int value) {
    return Config_SymbolMethod_IsValid(value);
  }
  static const SymbolMethod SymbolMethod_MIN =
    Config_SymbolMethod_SymbolMethod_MIN;
  static const SymbolMethod SymbolMethod_MAX =
    Config_SymbolMethod_SymbolMethod_MAX;
  static const int SymbolMethod_ARRAYSIZE =
    Config_SymbolMethod_SymbolMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SymbolMethod_descriptor() {
    return Config_SymbolMethod_descriptor();
  }
  static inline const ::std::string& SymbolMethod_Name(SymbolMethod value) {
    return Config_SymbolMethod_Name(value);
  }
  static inline bool SymbolMethod_Parse(const ::std::string& name,
      SymbolMethod* value) {
    return Config_SymbolMethod_Parse(name, value);
  }

  typedef Config_FundamentalCharacterForm FundamentalCharacterForm;
  static const FundamentalCharacterForm FUNDAMENTAL_INPUT_MODE =
    Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
  static const FundamentalCharacterForm FUNDAMENTAL_FULL_WIDTH =
    Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH;
  static const FundamentalCharacterForm FUNDAMENTAL_HALF_WIDTH =
    Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
  static inline bool FundamentalCharacterForm_IsValid(int value) {
    return Config_FundamentalCharacterForm_IsValid(value);
  }
  static const FundamentalCharacterForm FundamentalCharacterForm_MIN =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN;
  static const FundamentalCharacterForm FundamentalCharacterForm_MAX =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX;
  static const int FundamentalCharacterForm_ARRAYSIZE =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FundamentalCharacterForm_descriptor() {
    return Config_FundamentalCharacterForm_descriptor();
  }
  static inline const ::std::string& FundamentalCharacterForm_Name(FundamentalCharacterForm value) {
    return Config_FundamentalCharacterForm_Name(value);
  }
  static inline bool FundamentalCharacterForm_Parse(const ::std::string& name,
      FundamentalCharacterForm* value) {
    return Config_FundamentalCharacterForm_Parse(name, value);
  }

  typedef Config_HistoryLearningLevel HistoryLearningLevel;
  static const HistoryLearningLevel DEFAULT_HISTORY =
    Config_HistoryLearningLevel_DEFAULT_HISTORY;
  static const HistoryLearningLevel READ_ONLY =
    Config_HistoryLearningLevel_READ_ONLY;
  static const HistoryLearningLevel NO_HISTORY =
    Config_HistoryLearningLevel_NO_HISTORY;
  static inline bool HistoryLearningLevel_IsValid(int value) {
    return Config_HistoryLearningLevel_IsValid(value);
  }
  static const HistoryLearningLevel HistoryLearningLevel_MIN =
    Config_HistoryLearningLevel_HistoryLearningLevel_MIN;
  static const HistoryLearningLevel HistoryLearningLevel_MAX =
    Config_HistoryLearningLevel_HistoryLearningLevel_MAX;
  static const int HistoryLearningLevel_ARRAYSIZE =
    Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HistoryLearningLevel_descriptor() {
    return Config_HistoryLearningLevel_descriptor();
  }
  static inline const ::std::string& HistoryLearningLevel_Name(HistoryLearningLevel value) {
    return Config_HistoryLearningLevel_Name(value);
  }
  static inline bool HistoryLearningLevel_Parse(const ::std::string& name,
      HistoryLearningLevel* value) {
    return Config_HistoryLearningLevel_Parse(name, value);
  }

  typedef Config_SelectionShortcut SelectionShortcut;
  static const SelectionShortcut NO_SHORTCUT =
    Config_SelectionShortcut_NO_SHORTCUT;
  static const SelectionShortcut SHORTCUT_123456789 =
    Config_SelectionShortcut_SHORTCUT_123456789;
  static const SelectionShortcut SHORTCUT_ASDFGHJKL =
    Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
  static inline bool SelectionShortcut_IsValid(int value) {
    return Config_SelectionShortcut_IsValid(value);
  }
  static const SelectionShortcut SelectionShortcut_MIN =
    Config_SelectionShortcut_SelectionShortcut_MIN;
  static const SelectionShortcut SelectionShortcut_MAX =
    Config_SelectionShortcut_SelectionShortcut_MAX;
  static const int SelectionShortcut_ARRAYSIZE =
    Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SelectionShortcut_descriptor() {
    return Config_SelectionShortcut_descriptor();
  }
  static inline const ::std::string& SelectionShortcut_Name(SelectionShortcut value) {
    return Config_SelectionShortcut_Name(value);
  }
  static inline bool SelectionShortcut_Parse(const ::std::string& name,
      SelectionShortcut* value) {
    return Config_SelectionShortcut_Parse(name, value);
  }

  typedef Config_CharacterForm CharacterForm;
  static const CharacterForm HALF_WIDTH =
    Config_CharacterForm_HALF_WIDTH;
  static const CharacterForm FULL_WIDTH =
    Config_CharacterForm_FULL_WIDTH;
  static const CharacterForm LAST_FORM =
    Config_CharacterForm_LAST_FORM;
  static const CharacterForm NO_CONVERSION =
    Config_CharacterForm_NO_CONVERSION;
  static inline bool CharacterForm_IsValid(int value) {
    return Config_CharacterForm_IsValid(value);
  }
  static const CharacterForm CharacterForm_MIN =
    Config_CharacterForm_CharacterForm_MIN;
  static const CharacterForm CharacterForm_MAX =
    Config_CharacterForm_CharacterForm_MAX;
  static const int CharacterForm_ARRAYSIZE =
    Config_CharacterForm_CharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CharacterForm_descriptor() {
    return Config_CharacterForm_descriptor();
  }
  static inline const ::std::string& CharacterForm_Name(CharacterForm value) {
    return Config_CharacterForm_Name(value);
  }
  static inline bool CharacterForm_Parse(const ::std::string& name,
      CharacterForm* value) {
    return Config_CharacterForm_Parse(name, value);
  }

  typedef Config_ShiftKeyModeSwitch ShiftKeyModeSwitch;
  static const ShiftKeyModeSwitch OFF =
    Config_ShiftKeyModeSwitch_OFF;
  static const ShiftKeyModeSwitch ASCII_INPUT_MODE =
    Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE;
  static const ShiftKeyModeSwitch KATAKANA_INPUT_MODE =
    Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
  static inline bool ShiftKeyModeSwitch_IsValid(int value) {
    return Config_ShiftKeyModeSwitch_IsValid(value);
  }
  static const ShiftKeyModeSwitch ShiftKeyModeSwitch_MIN =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN;
  static const ShiftKeyModeSwitch ShiftKeyModeSwitch_MAX =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX;
  static const int ShiftKeyModeSwitch_ARRAYSIZE =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShiftKeyModeSwitch_descriptor() {
    return Config_ShiftKeyModeSwitch_descriptor();
  }
  static inline const ::std::string& ShiftKeyModeSwitch_Name(ShiftKeyModeSwitch value) {
    return Config_ShiftKeyModeSwitch_Name(value);
  }
  static inline bool ShiftKeyModeSwitch_Parse(const ::std::string& name,
      ShiftKeyModeSwitch* value) {
    return Config_ShiftKeyModeSwitch_Parse(name, value);
  }

  typedef Config_NumpadCharacterForm NumpadCharacterForm;
  static const NumpadCharacterForm NUMPAD_INPUT_MODE =
    Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
  static const NumpadCharacterForm NUMPAD_FULL_WIDTH =
    Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH;
  static const NumpadCharacterForm NUMPAD_HALF_WIDTH =
    Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH;
  static const NumpadCharacterForm NUMPAD_DIRECT_INPUT =
    Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
  static inline bool NumpadCharacterForm_IsValid(int value) {
    return Config_NumpadCharacterForm_IsValid(value);
  }
  static const NumpadCharacterForm NumpadCharacterForm_MIN =
    Config_NumpadCharacterForm_NumpadCharacterForm_MIN;
  static const NumpadCharacterForm NumpadCharacterForm_MAX =
    Config_NumpadCharacterForm_NumpadCharacterForm_MAX;
  static const int NumpadCharacterForm_ARRAYSIZE =
    Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NumpadCharacterForm_descriptor() {
    return Config_NumpadCharacterForm_descriptor();
  }
  static inline const ::std::string& NumpadCharacterForm_Name(NumpadCharacterForm value) {
    return Config_NumpadCharacterForm_Name(value);
  }
  static inline bool NumpadCharacterForm_Parse(const ::std::string& name,
      NumpadCharacterForm* value) {
    return Config_NumpadCharacterForm_Parse(name, value);
  }

  typedef Config_AutoConversionKey AutoConversionKey;
  static const AutoConversionKey AUTO_CONVERSION_OFF =
    Config_AutoConversionKey_AUTO_CONVERSION_OFF;
  static const AutoConversionKey AUTO_CONVERSION_KUTEN =
    Config_AutoConversionKey_AUTO_CONVERSION_KUTEN;
  static const AutoConversionKey AUTO_CONVERSION_TOUTEN =
    Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN;
  static const AutoConversionKey AUTO_CONVERSION_QUESTION_MARK =
    Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK;
  static const AutoConversionKey AUTO_CONVERSION_EXCLAMATION_MARK =
    Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
  static inline bool AutoConversionKey_IsValid(int value) {
    return Config_AutoConversionKey_IsValid(value);
  }
  static const AutoConversionKey AutoConversionKey_MIN =
    Config_AutoConversionKey_AutoConversionKey_MIN;
  static const AutoConversionKey AutoConversionKey_MAX =
    Config_AutoConversionKey_AutoConversionKey_MAX;
  static const int AutoConversionKey_ARRAYSIZE =
    Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AutoConversionKey_descriptor() {
    return Config_AutoConversionKey_descriptor();
  }
  static inline const ::std::string& AutoConversionKey_Name(AutoConversionKey value) {
    return Config_AutoConversionKey_Name(value);
  }
  static inline bool AutoConversionKey_Parse(const ::std::string& name,
      AutoConversionKey* value) {
    return Config_AutoConversionKey_Parse(name, value);
  }

  typedef Config_YenSignCharacter YenSignCharacter;
  static const YenSignCharacter YEN_SIGN =
    Config_YenSignCharacter_YEN_SIGN;
  static const YenSignCharacter BACKSLASH =
    Config_YenSignCharacter_BACKSLASH;
  static inline bool YenSignCharacter_IsValid(int value) {
    return Config_YenSignCharacter_IsValid(value);
  }
  static const YenSignCharacter YenSignCharacter_MIN =
    Config_YenSignCharacter_YenSignCharacter_MIN;
  static const YenSignCharacter YenSignCharacter_MAX =
    Config_YenSignCharacter_YenSignCharacter_MAX;
  static const int YenSignCharacter_ARRAYSIZE =
    Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  YenSignCharacter_descriptor() {
    return Config_YenSignCharacter_descriptor();
  }
  static inline const ::std::string& YenSignCharacter_Name(YenSignCharacter value) {
    return Config_YenSignCharacter_Name(value);
  }
  static inline bool YenSignCharacter_Parse(const ::std::string& name,
      YenSignCharacter* value) {
    return Config_YenSignCharacter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
  int character_form_rules_size() const;
  void clear_character_form_rules();
  static const int kCharacterFormRulesFieldNumber = 54;
  ::mozc::config::Config_CharacterFormRule* mutable_character_form_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
      mutable_character_form_rules();
  const ::mozc::config::Config_CharacterFormRule& character_form_rules(int index) const;
  ::mozc::config::Config_CharacterFormRule* add_character_form_rules();
  const ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
      character_form_rules() const;

  // optional bytes custom_keymap_table = 42;
  bool has_custom_keymap_table() const;
  void clear_custom_keymap_table();
  static const int kCustomKeymapTableFieldNumber = 42;
  const ::std::string& custom_keymap_table() const;
  void set_custom_keymap_table(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_keymap_table(::std::string&& value);
  #endif
  void set_custom_keymap_table(const char* value);
  void set_custom_keymap_table(const void* value, size_t size);
  ::std::string* mutable_custom_keymap_table();
  ::std::string* release_custom_keymap_table();
  void set_allocated_custom_keymap_table(::std::string* custom_keymap_table);

  // optional bytes custom_roman_table = 43;
  bool has_custom_roman_table() const;
  void clear_custom_roman_table();
  static const int kCustomRomanTableFieldNumber = 43;
  const ::std::string& custom_roman_table() const;
  void set_custom_roman_table(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_roman_table(::std::string&& value);
  #endif
  void set_custom_roman_table(const char* value);
  void set_custom_roman_table(const void* value, size_t size);
  ::std::string* mutable_custom_roman_table();
  ::std::string* release_custom_roman_table();
  void set_allocated_custom_roman_table(::std::string* custom_roman_table);

  // optional .mozc.config.GeneralConfig general_config = 1;
  bool has_general_config() const;
  void clear_general_config();
  static const int kGeneralConfigFieldNumber = 1;
  private:
  const ::mozc::config::GeneralConfig& _internal_general_config() const;
  public:
  const ::mozc::config::GeneralConfig& general_config() const;
  ::mozc::config::GeneralConfig* release_general_config();
  ::mozc::config::GeneralConfig* mutable_general_config();
  void set_allocated_general_config(::mozc::config::GeneralConfig* general_config);

  // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
  bool has_information_list_config() const;
  void clear_information_list_config();
  static const int kInformationListConfigFieldNumber = 90;
  private:
  const ::mozc::config::Config_InformationListConfig& _internal_information_list_config() const;
  public:
  const ::mozc::config::Config_InformationListConfig& information_list_config() const;
  ::mozc::config::Config_InformationListConfig* release_information_list_config();
  ::mozc::config::Config_InformationListConfig* mutable_information_list_config();
  void set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config);

  // optional int32 verbose_level = 10 [default = 0];
  bool has_verbose_level() const;
  void clear_verbose_level();
  static const int kVerboseLevelFieldNumber = 10;
  ::google::protobuf::int32 verbose_level() const;
  void set_verbose_level(::google::protobuf::int32 value);

  // optional bool incognito_mode = 20 [default = false];
  bool has_incognito_mode() const;
  void clear_incognito_mode();
  static const int kIncognitoModeFieldNumber = 20;
  bool incognito_mode() const;
  void set_incognito_mode(bool value);

  // optional bool presentation_mode = 23 [default = false];
  bool has_presentation_mode() const;
  void clear_presentation_mode();
  static const int kPresentationModeFieldNumber = 23;
  bool presentation_mode() const;
  void set_presentation_mode(bool value);

  // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
  bool has_use_keyboard_to_change_preedit_method() const;
  void clear_use_keyboard_to_change_preedit_method();
  static const int kUseKeyboardToChangePreeditMethodFieldNumber = 48;
  bool use_keyboard_to_change_preedit_method() const;
  void set_use_keyboard_to_change_preedit_method(bool value);

  // optional bool use_auto_conversion = 61 [default = false];
  bool has_use_auto_conversion() const;
  void clear_use_auto_conversion();
  static const int kUseAutoConversionFieldNumber = 61;
  bool use_auto_conversion() const;
  void set_use_auto_conversion(bool value);

  // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
  bool has_preedit_method() const;
  void clear_preedit_method();
  static const int kPreeditMethodFieldNumber = 40;
  ::mozc::config::Config_PreeditMethod preedit_method() const;
  void set_preedit_method(::mozc::config::Config_PreeditMethod value);

  // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
  bool has_punctuation_method() const;
  void clear_punctuation_method();
  static const int kPunctuationMethodFieldNumber = 45;
  ::mozc::config::Config_PunctuationMethod punctuation_method() const;
  void set_punctuation_method(::mozc::config::Config_PunctuationMethod value);

  // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
  bool has_symbol_method() const;
  void clear_symbol_method();
  static const int kSymbolMethodFieldNumber = 46;
  ::mozc::config::Config_SymbolMethod symbol_method() const;
  void set_symbol_method(::mozc::config::Config_SymbolMethod value);

  // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
  bool has_space_character_form() const;
  void clear_space_character_form();
  static const int kSpaceCharacterFormFieldNumber = 47;
  ::mozc::config::Config_FundamentalCharacterForm space_character_form() const;
  void set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value);

  // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
  bool has_history_learning_level() const;
  void clear_history_learning_level();
  static const int kHistoryLearningLevelFieldNumber = 50;
  ::mozc::config::Config_HistoryLearningLevel history_learning_level() const;
  void set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value);

  // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
  bool has_yen_sign_character() const;
  void clear_yen_sign_character();
  static const int kYenSignCharacterFieldNumber = 63;
  ::mozc::config::Config_YenSignCharacter yen_sign_character() const;
  void set_yen_sign_character(::mozc::config::Config_YenSignCharacter value);

  // optional bool use_japanese_layout = 64 [default = false];
  bool has_use_japanese_layout() const;
  void clear_use_japanese_layout();
  static const int kUseJapaneseLayoutFieldNumber = 64;
  bool use_japanese_layout() const;
  void set_use_japanese_layout(bool value);

  // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
  bool has_use_kana_modifier_insensitive_conversion() const;
  void clear_use_kana_modifier_insensitive_conversion();
  static const int kUseKanaModifierInsensitiveConversionFieldNumber = 65;
  bool use_kana_modifier_insensitive_conversion() const;
  void set_use_kana_modifier_insensitive_conversion(bool value);

  // optional bool use_typing_correction = 66 [default = false];
  bool has_use_typing_correction() const;
  void clear_use_typing_correction();
  static const int kUseTypingCorrectionFieldNumber = 66;
  bool use_typing_correction() const;
  void set_use_typing_correction(bool value);

  // optional bool use_emoji_conversion = 89 [default = false];
  bool has_use_emoji_conversion() const;
  void clear_use_emoji_conversion();
  static const int kUseEmojiConversionFieldNumber = 89;
  bool use_emoji_conversion() const;
  void set_use_emoji_conversion(bool value);

  // optional bool allow_cloud_handwriting = 301 [default = false];
  bool has_allow_cloud_handwriting() const;
  void clear_allow_cloud_handwriting();
  static const int kAllowCloudHandwritingFieldNumber = 301;
  bool allow_cloud_handwriting() const;
  void set_allow_cloud_handwriting(bool value);

  // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
  bool has_session_keymap() const;
  void clear_session_keymap();
  static const int kSessionKeymapFieldNumber = 41;
  ::mozc::config::Config_SessionKeymap session_keymap() const;
  void set_session_keymap(::mozc::config::Config_SessionKeymap value);

  // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
  bool has_selection_shortcut() const;
  void clear_selection_shortcut();
  static const int kSelectionShortcutFieldNumber = 52;
  ::mozc::config::Config_SelectionShortcut selection_shortcut() const;
  void set_selection_shortcut(::mozc::config::Config_SelectionShortcut value);

  // optional bool check_default = 22 [default = true];
  bool has_check_default() const;
  void clear_check_default();
  static const int kCheckDefaultFieldNumber = 22;
  bool check_default() const;
  void set_check_default(bool value);

  // optional bool use_auto_ime_turn_off = 56 [default = true];
  bool has_use_auto_ime_turn_off() const;
  void clear_use_auto_ime_turn_off();
  static const int kUseAutoImeTurnOffFieldNumber = 56;
  bool use_auto_ime_turn_off() const;
  void set_use_auto_ime_turn_off(bool value);

  // optional bool use_cascading_window = 58 [default = true];
  bool has_use_cascading_window() const;
  void clear_use_cascading_window();
  static const int kUseCascadingWindowFieldNumber = 58;
  bool use_cascading_window() const;
  void set_use_cascading_window(bool value);

  // optional bool use_date_conversion = 80 [default = true];
  bool has_use_date_conversion() const;
  void clear_use_date_conversion();
  static const int kUseDateConversionFieldNumber = 80;
  bool use_date_conversion() const;
  void set_use_date_conversion(bool value);

  // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
  bool has_shift_key_mode_switch() const;
  void clear_shift_key_mode_switch();
  static const int kShiftKeyModeSwitchFieldNumber = 59;
  ::mozc::config::Config_ShiftKeyModeSwitch shift_key_mode_switch() const;
  void set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value);

  // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
  bool has_numpad_character_form() const;
  void clear_numpad_character_form();
  static const int kNumpadCharacterFormFieldNumber = 60;
  ::mozc::config::Config_NumpadCharacterForm numpad_character_form() const;
  void set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value);

  // optional uint32 auto_conversion_key = 62 [default = 13];
  bool has_auto_conversion_key() const;
  void clear_auto_conversion_key();
  static const int kAutoConversionKeyFieldNumber = 62;
  ::google::protobuf::uint32 auto_conversion_key() const;
  void set_auto_conversion_key(::google::protobuf::uint32 value);

  // optional bool use_single_kanji_conversion = 81 [default = true];
  bool has_use_single_kanji_conversion() const;
  void clear_use_single_kanji_conversion();
  static const int kUseSingleKanjiConversionFieldNumber = 81;
  bool use_single_kanji_conversion() const;
  void set_use_single_kanji_conversion(bool value);

  // optional bool use_symbol_conversion = 82 [default = true];
  bool has_use_symbol_conversion() const;
  void clear_use_symbol_conversion();
  static const int kUseSymbolConversionFieldNumber = 82;
  bool use_symbol_conversion() const;
  void set_use_symbol_conversion(bool value);

  // optional bool use_number_conversion = 83 [default = true];
  bool has_use_number_conversion() const;
  void clear_use_number_conversion();
  static const int kUseNumberConversionFieldNumber = 83;
  bool use_number_conversion() const;
  void set_use_number_conversion(bool value);

  // optional bool use_emoticon_conversion = 84 [default = true];
  bool has_use_emoticon_conversion() const;
  void clear_use_emoticon_conversion();
  static const int kUseEmoticonConversionFieldNumber = 84;
  bool use_emoticon_conversion() const;
  void set_use_emoticon_conversion(bool value);

  // optional bool use_calculator = 85 [default = true];
  bool has_use_calculator() const;
  void clear_use_calculator();
  static const int kUseCalculatorFieldNumber = 85;
  bool use_calculator() const;
  void set_use_calculator(bool value);

  // optional bool use_t13n_conversion = 86 [default = true];
  bool has_use_t13n_conversion() const;
  void clear_use_t13n_conversion();
  static const int kUseT13NConversionFieldNumber = 86;
  bool use_t13n_conversion() const;
  void set_use_t13n_conversion(bool value);

  // optional bool use_zip_code_conversion = 87 [default = true];
  bool has_use_zip_code_conversion() const;
  void clear_use_zip_code_conversion();
  static const int kUseZipCodeConversionFieldNumber = 87;
  bool use_zip_code_conversion() const;
  void set_use_zip_code_conversion(bool value);

  // optional bool use_spelling_correction = 88 [default = true];
  bool has_use_spelling_correction() const;
  void clear_use_spelling_correction();
  static const int kUseSpellingCorrectionFieldNumber = 88;
  bool use_spelling_correction() const;
  void set_use_spelling_correction(bool value);

  // optional bool use_history_suggest = 100 [default = true];
  bool has_use_history_suggest() const;
  void clear_use_history_suggest();
  static const int kUseHistorySuggestFieldNumber = 100;
  bool use_history_suggest() const;
  void set_use_history_suggest(bool value);

  // optional bool use_dictionary_suggest = 101 [default = true];
  bool has_use_dictionary_suggest() const;
  void clear_use_dictionary_suggest();
  static const int kUseDictionarySuggestFieldNumber = 101;
  bool use_dictionary_suggest() const;
  void set_use_dictionary_suggest(bool value);

  // optional bool use_realtime_conversion = 102 [default = true];
  bool has_use_realtime_conversion() const;
  void clear_use_realtime_conversion();
  static const int kUseRealtimeConversionFieldNumber = 102;
  bool use_realtime_conversion() const;
  void set_use_realtime_conversion(bool value);

  // optional bool use_mode_indicator = 120 [default = true];
  bool has_use_mode_indicator() const;
  void clear_use_mode_indicator();
  static const int kUseModeIndicatorFieldNumber = 120;
  bool use_mode_indicator() const;
  void set_use_mode_indicator(bool value);

  // optional uint32 suggestions_size = 110 [default = 3];
  bool has_suggestions_size() const;
  void clear_suggestions_size();
  static const int kSuggestionsSizeFieldNumber = 110;
  ::google::protobuf::uint32 suggestions_size() const;
  void set_suggestions_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config)
 private:
  void set_has_general_config();
  void clear_has_general_config();
  void set_has_verbose_level();
  void clear_has_verbose_level();
  void set_has_incognito_mode();
  void clear_has_incognito_mode();
  void set_has_check_default();
  void clear_has_check_default();
  void set_has_presentation_mode();
  void clear_has_presentation_mode();
  void set_has_preedit_method();
  void clear_has_preedit_method();
  void set_has_session_keymap();
  void clear_has_session_keymap();
  void set_has_custom_keymap_table();
  void clear_has_custom_keymap_table();
  void set_has_custom_roman_table();
  void clear_has_custom_roman_table();
  void set_has_punctuation_method();
  void clear_has_punctuation_method();
  void set_has_symbol_method();
  void clear_has_symbol_method();
  void set_has_space_character_form();
  void clear_has_space_character_form();
  void set_has_use_keyboard_to_change_preedit_method();
  void clear_has_use_keyboard_to_change_preedit_method();
  void set_has_history_learning_level();
  void clear_has_history_learning_level();
  void set_has_selection_shortcut();
  void clear_has_selection_shortcut();
  void set_has_use_auto_ime_turn_off();
  void clear_has_use_auto_ime_turn_off();
  void set_has_use_cascading_window();
  void clear_has_use_cascading_window();
  void set_has_shift_key_mode_switch();
  void clear_has_shift_key_mode_switch();
  void set_has_numpad_character_form();
  void clear_has_numpad_character_form();
  void set_has_use_auto_conversion();
  void clear_has_use_auto_conversion();
  void set_has_auto_conversion_key();
  void clear_has_auto_conversion_key();
  void set_has_yen_sign_character();
  void clear_has_yen_sign_character();
  void set_has_use_japanese_layout();
  void clear_has_use_japanese_layout();
  void set_has_use_kana_modifier_insensitive_conversion();
  void clear_has_use_kana_modifier_insensitive_conversion();
  void set_has_use_typing_correction();
  void clear_has_use_typing_correction();
  void set_has_use_date_conversion();
  void clear_has_use_date_conversion();
  void set_has_use_single_kanji_conversion();
  void clear_has_use_single_kanji_conversion();
  void set_has_use_symbol_conversion();
  void clear_has_use_symbol_conversion();
  void set_has_use_number_conversion();
  void clear_has_use_number_conversion();
  void set_has_use_emoticon_conversion();
  void clear_has_use_emoticon_conversion();
  void set_has_use_calculator();
  void clear_has_use_calculator();
  void set_has_use_t13n_conversion();
  void clear_has_use_t13n_conversion();
  void set_has_use_zip_code_conversion();
  void clear_has_use_zip_code_conversion();
  void set_has_use_spelling_correction();
  void clear_has_use_spelling_correction();
  void set_has_use_emoji_conversion();
  void clear_has_use_emoji_conversion();
  void set_has_information_list_config();
  void clear_has_information_list_config();
  void set_has_use_history_suggest();
  void clear_has_use_history_suggest();
  void set_has_use_dictionary_suggest();
  void clear_has_use_dictionary_suggest();
  void set_has_use_realtime_conversion();
  void clear_has_use_realtime_conversion();
  void set_has_suggestions_size();
  void clear_has_suggestions_size();
  void set_has_use_mode_indicator();
  void clear_has_use_mode_indicator();
  void set_has_allow_cloud_handwriting();
  void clear_has_allow_cloud_handwriting();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule > character_form_rules_;
  ::google::protobuf::internal::ArenaStringPtr custom_keymap_table_;
  ::google::protobuf::internal::ArenaStringPtr custom_roman_table_;
  ::mozc::config::GeneralConfig* general_config_;
  ::mozc::config::Config_InformationListConfig* information_list_config_;
  ::google::protobuf::int32 verbose_level_;
  bool incognito_mode_;
  bool presentation_mode_;
  bool use_keyboard_to_change_preedit_method_;
  bool use_auto_conversion_;
  int preedit_method_;
  int punctuation_method_;
  int symbol_method_;
  int space_character_form_;
  int history_learning_level_;
  int yen_sign_character_;
  bool use_japanese_layout_;
  bool use_kana_modifier_insensitive_conversion_;
  bool use_typing_correction_;
  bool use_emoji_conversion_;
  bool allow_cloud_handwriting_;
  int session_keymap_;
  int selection_shortcut_;
  bool check_default_;
  bool use_auto_ime_turn_off_;
  bool use_cascading_window_;
  bool use_date_conversion_;
  int shift_key_mode_switch_;
  int numpad_character_form_;
  ::google::protobuf::uint32 auto_conversion_key_;
  bool use_single_kanji_conversion_;
  bool use_symbol_conversion_;
  bool use_number_conversion_;
  bool use_emoticon_conversion_;
  bool use_calculator_;
  bool use_t13n_conversion_;
  bool use_zip_code_conversion_;
  bool use_spelling_correction_;
  bool use_history_suggest_;
  bool use_dictionary_suggest_;
  bool use_realtime_conversion_;
  bool use_mode_indicator_;
  ::google::protobuf::uint32 suggestions_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GeneralConfig

// optional uint32 config_version = 1 [default = 0];
inline bool GeneralConfig::has_config_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeneralConfig::set_has_config_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeneralConfig::clear_has_config_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeneralConfig::clear_config_version() {
  config_version_ = 0u;
  clear_has_config_version();
}
inline ::google::protobuf::uint32 GeneralConfig::config_version() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.config_version)
  return config_version_;
}
inline void GeneralConfig::set_config_version(::google::protobuf::uint32 value) {
  set_has_config_version();
  config_version_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.config_version)
}

// optional string last_modified_product_version = 2 [default = "0.0.0.0"];
inline bool GeneralConfig::has_last_modified_product_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralConfig::set_has_last_modified_product_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralConfig::clear_has_last_modified_product_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralConfig::clear_last_modified_product_version() {
  last_modified_product_version_.ClearToDefaultNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get());
  clear_has_last_modified_product_version();
}
inline const ::std::string& GeneralConfig::last_modified_product_version() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.last_modified_product_version)
  return last_modified_product_version_.GetNoArena();
}
inline void GeneralConfig::set_last_modified_product_version(const ::std::string& value) {
  set_has_last_modified_product_version();
  last_modified_product_version_.SetNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.last_modified_product_version)
}
#if LANG_CXX11
inline void GeneralConfig::set_last_modified_product_version(::std::string&& value) {
  set_has_last_modified_product_version();
  last_modified_product_version_.SetNoArena(
    &::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.last_modified_product_version)
}
#endif
inline void GeneralConfig::set_last_modified_product_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_last_modified_product_version();
  last_modified_product_version_.SetNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.last_modified_product_version)
}
inline void GeneralConfig::set_last_modified_product_version(const char* value, size_t size) {
  set_has_last_modified_product_version();
  last_modified_product_version_.SetNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.last_modified_product_version)
}
inline ::std::string* GeneralConfig::mutable_last_modified_product_version() {
  set_has_last_modified_product_version();
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.last_modified_product_version)
  return last_modified_product_version_.MutableNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get());
}
inline ::std::string* GeneralConfig::release_last_modified_product_version() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.last_modified_product_version)
  if (!has_last_modified_product_version()) {
    return NULL;
  }
  clear_has_last_modified_product_version();
  return last_modified_product_version_.ReleaseNonDefaultNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get());
}
inline void GeneralConfig::set_allocated_last_modified_product_version(::std::string* last_modified_product_version) {
  if (last_modified_product_version != NULL) {
    set_has_last_modified_product_version();
  } else {
    clear_has_last_modified_product_version();
  }
  last_modified_product_version_.SetAllocatedNoArena(&::mozc::config::GeneralConfig::_i_give_permission_to_break_this_code_default_last_modified_product_version_.get(), last_modified_product_version);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.last_modified_product_version)
}

// optional uint64 last_modified_time = 3 [default = 0];
inline bool GeneralConfig::has_last_modified_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeneralConfig::set_has_last_modified_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeneralConfig::clear_has_last_modified_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeneralConfig::clear_last_modified_time() {
  last_modified_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_modified_time();
}
inline ::google::protobuf::uint64 GeneralConfig::last_modified_time() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.last_modified_time)
  return last_modified_time_;
}
inline void GeneralConfig::set_last_modified_time(::google::protobuf::uint64 value) {
  set_has_last_modified_time();
  last_modified_time_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.last_modified_time)
}

// optional string platform = 4 [default = ""];
inline bool GeneralConfig::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeneralConfig::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeneralConfig::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeneralConfig::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& GeneralConfig::platform() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.platform)
  return platform_.GetNoArena();
}
inline void GeneralConfig::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.platform)
}
#if LANG_CXX11
inline void GeneralConfig::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.platform)
}
#endif
inline void GeneralConfig::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.platform)
}
inline void GeneralConfig::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.platform)
}
inline ::std::string* GeneralConfig::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralConfig::release_platform() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.platform)
  if (!has_platform()) {
    return NULL;
  }
  clear_has_platform();
  return platform_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralConfig::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.platform)
}

// optional string ui_locale = 5 [default = ""];
inline bool GeneralConfig::has_ui_locale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeneralConfig::set_has_ui_locale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeneralConfig::clear_has_ui_locale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeneralConfig::clear_ui_locale() {
  ui_locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ui_locale();
}
inline const ::std::string& GeneralConfig::ui_locale() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.ui_locale)
  return ui_locale_.GetNoArena();
}
inline void GeneralConfig::set_ui_locale(const ::std::string& value) {
  set_has_ui_locale();
  ui_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.ui_locale)
}
#if LANG_CXX11
inline void GeneralConfig::set_ui_locale(::std::string&& value) {
  set_has_ui_locale();
  ui_locale_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.GeneralConfig.ui_locale)
}
#endif
inline void GeneralConfig::set_ui_locale(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ui_locale();
  ui_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.GeneralConfig.ui_locale)
}
inline void GeneralConfig::set_ui_locale(const char* value, size_t size) {
  set_has_ui_locale();
  ui_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.GeneralConfig.ui_locale)
}
inline ::std::string* GeneralConfig::mutable_ui_locale() {
  set_has_ui_locale();
  // @@protoc_insertion_point(field_mutable:mozc.config.GeneralConfig.ui_locale)
  return ui_locale_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeneralConfig::release_ui_locale() {
  // @@protoc_insertion_point(field_release:mozc.config.GeneralConfig.ui_locale)
  if (!has_ui_locale()) {
    return NULL;
  }
  clear_has_ui_locale();
  return ui_locale_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeneralConfig::set_allocated_ui_locale(::std::string* ui_locale) {
  if (ui_locale != NULL) {
    set_has_ui_locale();
  } else {
    clear_has_ui_locale();
  }
  ui_locale_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ui_locale);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.GeneralConfig.ui_locale)
}

// optional bool upload_usage_stats = 6 [default = false];
inline bool GeneralConfig::has_upload_usage_stats() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeneralConfig::set_has_upload_usage_stats() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeneralConfig::clear_has_upload_usage_stats() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeneralConfig::clear_upload_usage_stats() {
  upload_usage_stats_ = false;
  clear_has_upload_usage_stats();
}
inline bool GeneralConfig::upload_usage_stats() const {
  // @@protoc_insertion_point(field_get:mozc.config.GeneralConfig.upload_usage_stats)
  return upload_usage_stats_;
}
inline void GeneralConfig::set_upload_usage_stats(bool value) {
  set_has_upload_usage_stats();
  upload_usage_stats_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.GeneralConfig.upload_usage_stats)
}

// -------------------------------------------------------------------

// Config_CharacterFormRule

// optional string group = 1;
inline bool Config_CharacterFormRule::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config_CharacterFormRule::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config_CharacterFormRule::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config_CharacterFormRule::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group();
}
inline const ::std::string& Config_CharacterFormRule::group() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.group)
  return group_.GetNoArena();
}
inline void Config_CharacterFormRule::set_group(const ::std::string& value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.group)
}
#if LANG_CXX11
inline void Config_CharacterFormRule::set_group(::std::string&& value) {
  set_has_group();
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.CharacterFormRule.group)
}
#endif
inline void Config_CharacterFormRule::set_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.CharacterFormRule.group)
}
inline void Config_CharacterFormRule::set_group(const char* value, size_t size) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.CharacterFormRule.group)
}
inline ::std::string* Config_CharacterFormRule::mutable_group() {
  set_has_group();
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.CharacterFormRule.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config_CharacterFormRule::release_group() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.CharacterFormRule.group)
  if (!has_group()) {
    return NULL;
  }
  clear_has_group();
  return group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config_CharacterFormRule::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    set_has_group();
  } else {
    clear_has_group();
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.CharacterFormRule.group)
}

// optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::has_preedit_character_form() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config_CharacterFormRule::set_has_preedit_character_form() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config_CharacterFormRule::clear_has_preedit_character_form() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config_CharacterFormRule::clear_preedit_character_form() {
  preedit_character_form_ = 1;
  clear_has_preedit_character_form();
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::preedit_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.preedit_character_form)
  return static_cast< ::mozc::config::Config_CharacterForm >(preedit_character_form_);
}
inline void Config_CharacterFormRule::set_preedit_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  set_has_preedit_character_form();
  preedit_character_form_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.preedit_character_form)
}

// optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::has_conversion_character_form() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config_CharacterFormRule::set_has_conversion_character_form() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config_CharacterFormRule::clear_has_conversion_character_form() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config_CharacterFormRule::clear_conversion_character_form() {
  conversion_character_form_ = 1;
  clear_has_conversion_character_form();
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::conversion_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.CharacterFormRule.conversion_character_form)
  return static_cast< ::mozc::config::Config_CharacterForm >(conversion_character_form_);
}
inline void Config_CharacterFormRule::set_conversion_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  set_has_conversion_character_form();
  conversion_character_form_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.CharacterFormRule.conversion_character_form)
}

// -------------------------------------------------------------------

// Config_InformationListConfig

// optional bool use_local_usage_dictionary = 1 [default = true];
inline bool Config_InformationListConfig::has_use_local_usage_dictionary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config_InformationListConfig::set_has_use_local_usage_dictionary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config_InformationListConfig::clear_has_use_local_usage_dictionary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config_InformationListConfig::clear_use_local_usage_dictionary() {
  use_local_usage_dictionary_ = true;
  clear_has_use_local_usage_dictionary();
}
inline bool Config_InformationListConfig::use_local_usage_dictionary() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.InformationListConfig.use_local_usage_dictionary)
  return use_local_usage_dictionary_;
}
inline void Config_InformationListConfig::set_use_local_usage_dictionary(bool value) {
  set_has_use_local_usage_dictionary();
  use_local_usage_dictionary_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.InformationListConfig.use_local_usage_dictionary)
}

// -------------------------------------------------------------------

// Config

// optional .mozc.config.GeneralConfig general_config = 1;
inline bool Config::has_general_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_general_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_general_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_general_config() {
  if (general_config_ != NULL) general_config_->Clear();
  clear_has_general_config();
}
inline const ::mozc::config::GeneralConfig& Config::_internal_general_config() const {
  return *general_config_;
}
inline const ::mozc::config::GeneralConfig& Config::general_config() const {
  const ::mozc::config::GeneralConfig* p = general_config_;
  // @@protoc_insertion_point(field_get:mozc.config.Config.general_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::config::GeneralConfig*>(
      &::mozc::config::_GeneralConfig_default_instance_);
}
inline ::mozc::config::GeneralConfig* Config::release_general_config() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.general_config)
  clear_has_general_config();
  ::mozc::config::GeneralConfig* temp = general_config_;
  general_config_ = NULL;
  return temp;
}
inline ::mozc::config::GeneralConfig* Config::mutable_general_config() {
  set_has_general_config();
  if (general_config_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::config::GeneralConfig>(GetArenaNoVirtual());
    general_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.general_config)
  return general_config_;
}
inline void Config::set_allocated_general_config(::mozc::config::GeneralConfig* general_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete general_config_;
  }
  if (general_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      general_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, general_config, submessage_arena);
    }
    set_has_general_config();
  } else {
    clear_has_general_config();
  }
  general_config_ = general_config;
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.general_config)
}

// optional int32 verbose_level = 10 [default = 0];
inline bool Config::has_verbose_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_verbose_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_verbose_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_verbose_level() {
  verbose_level_ = 0;
  clear_has_verbose_level();
}
inline ::google::protobuf::int32 Config::verbose_level() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.verbose_level)
  return verbose_level_;
}
inline void Config::set_verbose_level(::google::protobuf::int32 value) {
  set_has_verbose_level();
  verbose_level_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.verbose_level)
}

// optional bool incognito_mode = 20 [default = false];
inline bool Config::has_incognito_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_incognito_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_incognito_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_incognito_mode() {
  incognito_mode_ = false;
  clear_has_incognito_mode();
}
inline bool Config::incognito_mode() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.incognito_mode)
  return incognito_mode_;
}
inline void Config::set_incognito_mode(bool value) {
  set_has_incognito_mode();
  incognito_mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.incognito_mode)
}

// optional bool check_default = 22 [default = true];
inline bool Config::has_check_default() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Config::set_has_check_default() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Config::clear_has_check_default() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Config::clear_check_default() {
  check_default_ = true;
  clear_has_check_default();
}
inline bool Config::check_default() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.check_default)
  return check_default_;
}
inline void Config::set_check_default(bool value) {
  set_has_check_default();
  check_default_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.check_default)
}

// optional bool presentation_mode = 23 [default = false];
inline bool Config::has_presentation_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_presentation_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_presentation_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_presentation_mode() {
  presentation_mode_ = false;
  clear_has_presentation_mode();
}
inline bool Config::presentation_mode() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.presentation_mode)
  return presentation_mode_;
}
inline void Config::set_presentation_mode(bool value) {
  set_has_presentation_mode();
  presentation_mode_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.presentation_mode)
}

// optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
inline bool Config::has_preedit_method() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Config::set_has_preedit_method() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Config::clear_has_preedit_method() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Config::clear_preedit_method() {
  preedit_method_ = 0;
  clear_has_preedit_method();
}
inline ::mozc::config::Config_PreeditMethod Config::preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.preedit_method)
  return static_cast< ::mozc::config::Config_PreeditMethod >(preedit_method_);
}
inline void Config::set_preedit_method(::mozc::config::Config_PreeditMethod value) {
  assert(::mozc::config::Config_PreeditMethod_IsValid(value));
  set_has_preedit_method();
  preedit_method_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.preedit_method)
}

// optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
inline bool Config::has_session_keymap() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Config::set_has_session_keymap() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Config::clear_has_session_keymap() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Config::clear_session_keymap() {
  session_keymap_ = -1;
  clear_has_session_keymap();
}
inline ::mozc::config::Config_SessionKeymap Config::session_keymap() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.session_keymap)
  return static_cast< ::mozc::config::Config_SessionKeymap >(session_keymap_);
}
inline void Config::set_session_keymap(::mozc::config::Config_SessionKeymap value) {
  assert(::mozc::config::Config_SessionKeymap_IsValid(value));
  set_has_session_keymap();
  session_keymap_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.session_keymap)
}

// optional bytes custom_keymap_table = 42;
inline bool Config::has_custom_keymap_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_custom_keymap_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_custom_keymap_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_custom_keymap_table() {
  custom_keymap_table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_custom_keymap_table();
}
inline const ::std::string& Config::custom_keymap_table() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.custom_keymap_table)
  return custom_keymap_table_.GetNoArena();
}
inline void Config::set_custom_keymap_table(const ::std::string& value) {
  set_has_custom_keymap_table();
  custom_keymap_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.custom_keymap_table)
}
#if LANG_CXX11
inline void Config::set_custom_keymap_table(::std::string&& value) {
  set_has_custom_keymap_table();
  custom_keymap_table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.custom_keymap_table)
}
#endif
inline void Config::set_custom_keymap_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_custom_keymap_table();
  custom_keymap_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.custom_keymap_table)
}
inline void Config::set_custom_keymap_table(const void* value, size_t size) {
  set_has_custom_keymap_table();
  custom_keymap_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.custom_keymap_table)
}
inline ::std::string* Config::mutable_custom_keymap_table() {
  set_has_custom_keymap_table();
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.custom_keymap_table)
  return custom_keymap_table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_custom_keymap_table() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.custom_keymap_table)
  if (!has_custom_keymap_table()) {
    return NULL;
  }
  clear_has_custom_keymap_table();
  return custom_keymap_table_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_custom_keymap_table(::std::string* custom_keymap_table) {
  if (custom_keymap_table != NULL) {
    set_has_custom_keymap_table();
  } else {
    clear_has_custom_keymap_table();
  }
  custom_keymap_table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_keymap_table);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.custom_keymap_table)
}

// optional bytes custom_roman_table = 43;
inline bool Config::has_custom_roman_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_custom_roman_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_custom_roman_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_custom_roman_table() {
  custom_roman_table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_custom_roman_table();
}
inline const ::std::string& Config::custom_roman_table() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.custom_roman_table)
  return custom_roman_table_.GetNoArena();
}
inline void Config::set_custom_roman_table(const ::std::string& value) {
  set_has_custom_roman_table();
  custom_roman_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.config.Config.custom_roman_table)
}
#if LANG_CXX11
inline void Config::set_custom_roman_table(::std::string&& value) {
  set_has_custom_roman_table();
  custom_roman_table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.config.Config.custom_roman_table)
}
#endif
inline void Config::set_custom_roman_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_custom_roman_table();
  custom_roman_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.config.Config.custom_roman_table)
}
inline void Config::set_custom_roman_table(const void* value, size_t size) {
  set_has_custom_roman_table();
  custom_roman_table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.config.Config.custom_roman_table)
}
inline ::std::string* Config::mutable_custom_roman_table() {
  set_has_custom_roman_table();
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.custom_roman_table)
  return custom_roman_table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_custom_roman_table() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.custom_roman_table)
  if (!has_custom_roman_table()) {
    return NULL;
  }
  clear_has_custom_roman_table();
  return custom_roman_table_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_custom_roman_table(::std::string* custom_roman_table) {
  if (custom_roman_table != NULL) {
    set_has_custom_roman_table();
  } else {
    clear_has_custom_roman_table();
  }
  custom_roman_table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_roman_table);
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.custom_roman_table)
}

// optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
inline bool Config::has_punctuation_method() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Config::set_has_punctuation_method() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Config::clear_has_punctuation_method() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Config::clear_punctuation_method() {
  punctuation_method_ = 0;
  clear_has_punctuation_method();
}
inline ::mozc::config::Config_PunctuationMethod Config::punctuation_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.punctuation_method)
  return static_cast< ::mozc::config::Config_PunctuationMethod >(punctuation_method_);
}
inline void Config::set_punctuation_method(::mozc::config::Config_PunctuationMethod value) {
  assert(::mozc::config::Config_PunctuationMethod_IsValid(value));
  set_has_punctuation_method();
  punctuation_method_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.punctuation_method)
}

// optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
inline bool Config::has_symbol_method() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Config::set_has_symbol_method() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Config::clear_has_symbol_method() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Config::clear_symbol_method() {
  symbol_method_ = 0;
  clear_has_symbol_method();
}
inline ::mozc::config::Config_SymbolMethod Config::symbol_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.symbol_method)
  return static_cast< ::mozc::config::Config_SymbolMethod >(symbol_method_);
}
inline void Config::set_symbol_method(::mozc::config::Config_SymbolMethod value) {
  assert(::mozc::config::Config_SymbolMethod_IsValid(value));
  set_has_symbol_method();
  symbol_method_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.symbol_method)
}

// optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
inline bool Config::has_space_character_form() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Config::set_has_space_character_form() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Config::clear_has_space_character_form() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Config::clear_space_character_form() {
  space_character_form_ = 0;
  clear_has_space_character_form();
}
inline ::mozc::config::Config_FundamentalCharacterForm Config::space_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.space_character_form)
  return static_cast< ::mozc::config::Config_FundamentalCharacterForm >(space_character_form_);
}
inline void Config::set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value) {
  assert(::mozc::config::Config_FundamentalCharacterForm_IsValid(value));
  set_has_space_character_form();
  space_character_form_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.space_character_form)
}

// optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
inline bool Config::has_use_keyboard_to_change_preedit_method() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Config::set_has_use_keyboard_to_change_preedit_method() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Config::clear_has_use_keyboard_to_change_preedit_method() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Config::clear_use_keyboard_to_change_preedit_method() {
  use_keyboard_to_change_preedit_method_ = false;
  clear_has_use_keyboard_to_change_preedit_method();
}
inline bool Config::use_keyboard_to_change_preedit_method() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_keyboard_to_change_preedit_method)
  return use_keyboard_to_change_preedit_method_;
}
inline void Config::set_use_keyboard_to_change_preedit_method(bool value) {
  set_has_use_keyboard_to_change_preedit_method();
  use_keyboard_to_change_preedit_method_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_keyboard_to_change_preedit_method)
}

// optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
inline bool Config::has_history_learning_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Config::set_has_history_learning_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Config::clear_has_history_learning_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Config::clear_history_learning_level() {
  history_learning_level_ = 0;
  clear_has_history_learning_level();
}
inline ::mozc::config::Config_HistoryLearningLevel Config::history_learning_level() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.history_learning_level)
  return static_cast< ::mozc::config::Config_HistoryLearningLevel >(history_learning_level_);
}
inline void Config::set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value) {
  assert(::mozc::config::Config_HistoryLearningLevel_IsValid(value));
  set_has_history_learning_level();
  history_learning_level_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.history_learning_level)
}

// optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
inline bool Config::has_selection_shortcut() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Config::set_has_selection_shortcut() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Config::clear_has_selection_shortcut() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Config::clear_selection_shortcut() {
  selection_shortcut_ = 1;
  clear_has_selection_shortcut();
}
inline ::mozc::config::Config_SelectionShortcut Config::selection_shortcut() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.selection_shortcut)
  return static_cast< ::mozc::config::Config_SelectionShortcut >(selection_shortcut_);
}
inline void Config::set_selection_shortcut(::mozc::config::Config_SelectionShortcut value) {
  assert(::mozc::config::Config_SelectionShortcut_IsValid(value));
  set_has_selection_shortcut();
  selection_shortcut_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.selection_shortcut)
}

// repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
inline int Config::character_form_rules_size() const {
  return character_form_rules_.size();
}
inline void Config::clear_character_form_rules() {
  character_form_rules_.Clear();
}
inline ::mozc::config::Config_CharacterFormRule* Config::mutable_character_form_rules(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.character_form_rules)
  return character_form_rules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
Config::mutable_character_form_rules() {
  // @@protoc_insertion_point(field_mutable_list:mozc.config.Config.character_form_rules)
  return &character_form_rules_;
}
inline const ::mozc::config::Config_CharacterFormRule& Config::character_form_rules(int index) const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.character_form_rules)
  return character_form_rules_.Get(index);
}
inline ::mozc::config::Config_CharacterFormRule* Config::add_character_form_rules() {
  // @@protoc_insertion_point(field_add:mozc.config.Config.character_form_rules)
  return character_form_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
Config::character_form_rules() const {
  // @@protoc_insertion_point(field_list:mozc.config.Config.character_form_rules)
  return character_form_rules_;
}

// optional bool use_auto_ime_turn_off = 56 [default = true];
inline bool Config::has_use_auto_ime_turn_off() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Config::set_has_use_auto_ime_turn_off() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Config::clear_has_use_auto_ime_turn_off() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Config::clear_use_auto_ime_turn_off() {
  use_auto_ime_turn_off_ = true;
  clear_has_use_auto_ime_turn_off();
}
inline bool Config::use_auto_ime_turn_off() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_auto_ime_turn_off)
  return use_auto_ime_turn_off_;
}
inline void Config::set_use_auto_ime_turn_off(bool value) {
  set_has_use_auto_ime_turn_off();
  use_auto_ime_turn_off_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_auto_ime_turn_off)
}

// optional bool use_cascading_window = 58 [default = true];
inline bool Config::has_use_cascading_window() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Config::set_has_use_cascading_window() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Config::clear_has_use_cascading_window() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Config::clear_use_cascading_window() {
  use_cascading_window_ = true;
  clear_has_use_cascading_window();
}
inline bool Config::use_cascading_window() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_cascading_window)
  return use_cascading_window_;
}
inline void Config::set_use_cascading_window(bool value) {
  set_has_use_cascading_window();
  use_cascading_window_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_cascading_window)
}

// optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
inline bool Config::has_shift_key_mode_switch() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Config::set_has_shift_key_mode_switch() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Config::clear_has_shift_key_mode_switch() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Config::clear_shift_key_mode_switch() {
  shift_key_mode_switch_ = 1;
  clear_has_shift_key_mode_switch();
}
inline ::mozc::config::Config_ShiftKeyModeSwitch Config::shift_key_mode_switch() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.shift_key_mode_switch)
  return static_cast< ::mozc::config::Config_ShiftKeyModeSwitch >(shift_key_mode_switch_);
}
inline void Config::set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value) {
  assert(::mozc::config::Config_ShiftKeyModeSwitch_IsValid(value));
  set_has_shift_key_mode_switch();
  shift_key_mode_switch_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.shift_key_mode_switch)
}

// optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
inline bool Config::has_numpad_character_form() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Config::set_has_numpad_character_form() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Config::clear_has_numpad_character_form() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Config::clear_numpad_character_form() {
  numpad_character_form_ = 2;
  clear_has_numpad_character_form();
}
inline ::mozc::config::Config_NumpadCharacterForm Config::numpad_character_form() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.numpad_character_form)
  return static_cast< ::mozc::config::Config_NumpadCharacterForm >(numpad_character_form_);
}
inline void Config::set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value) {
  assert(::mozc::config::Config_NumpadCharacterForm_IsValid(value));
  set_has_numpad_character_form();
  numpad_character_form_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.numpad_character_form)
}

// optional bool use_auto_conversion = 61 [default = false];
inline bool Config::has_use_auto_conversion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Config::set_has_use_auto_conversion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Config::clear_has_use_auto_conversion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Config::clear_use_auto_conversion() {
  use_auto_conversion_ = false;
  clear_has_use_auto_conversion();
}
inline bool Config::use_auto_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_auto_conversion)
  return use_auto_conversion_;
}
inline void Config::set_use_auto_conversion(bool value) {
  set_has_use_auto_conversion();
  use_auto_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_auto_conversion)
}

// optional uint32 auto_conversion_key = 62 [default = 13];
inline bool Config::has_auto_conversion_key() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Config::set_has_auto_conversion_key() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Config::clear_has_auto_conversion_key() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Config::clear_auto_conversion_key() {
  auto_conversion_key_ = 13u;
  clear_has_auto_conversion_key();
}
inline ::google::protobuf::uint32 Config::auto_conversion_key() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.auto_conversion_key)
  return auto_conversion_key_;
}
inline void Config::set_auto_conversion_key(::google::protobuf::uint32 value) {
  set_has_auto_conversion_key();
  auto_conversion_key_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.auto_conversion_key)
}

// optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
inline bool Config::has_yen_sign_character() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Config::set_has_yen_sign_character() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Config::clear_has_yen_sign_character() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Config::clear_yen_sign_character() {
  yen_sign_character_ = 0;
  clear_has_yen_sign_character();
}
inline ::mozc::config::Config_YenSignCharacter Config::yen_sign_character() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.yen_sign_character)
  return static_cast< ::mozc::config::Config_YenSignCharacter >(yen_sign_character_);
}
inline void Config::set_yen_sign_character(::mozc::config::Config_YenSignCharacter value) {
  assert(::mozc::config::Config_YenSignCharacter_IsValid(value));
  set_has_yen_sign_character();
  yen_sign_character_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.yen_sign_character)
}

// optional bool use_japanese_layout = 64 [default = false];
inline bool Config::has_use_japanese_layout() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Config::set_has_use_japanese_layout() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Config::clear_has_use_japanese_layout() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Config::clear_use_japanese_layout() {
  use_japanese_layout_ = false;
  clear_has_use_japanese_layout();
}
inline bool Config::use_japanese_layout() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_japanese_layout)
  return use_japanese_layout_;
}
inline void Config::set_use_japanese_layout(bool value) {
  set_has_use_japanese_layout();
  use_japanese_layout_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_japanese_layout)
}

// optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
inline bool Config::has_use_kana_modifier_insensitive_conversion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Config::set_has_use_kana_modifier_insensitive_conversion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Config::clear_has_use_kana_modifier_insensitive_conversion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Config::clear_use_kana_modifier_insensitive_conversion() {
  use_kana_modifier_insensitive_conversion_ = false;
  clear_has_use_kana_modifier_insensitive_conversion();
}
inline bool Config::use_kana_modifier_insensitive_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_kana_modifier_insensitive_conversion)
  return use_kana_modifier_insensitive_conversion_;
}
inline void Config::set_use_kana_modifier_insensitive_conversion(bool value) {
  set_has_use_kana_modifier_insensitive_conversion();
  use_kana_modifier_insensitive_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_kana_modifier_insensitive_conversion)
}

// optional bool use_typing_correction = 66 [default = false];
inline bool Config::has_use_typing_correction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Config::set_has_use_typing_correction() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Config::clear_has_use_typing_correction() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Config::clear_use_typing_correction() {
  use_typing_correction_ = false;
  clear_has_use_typing_correction();
}
inline bool Config::use_typing_correction() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_typing_correction)
  return use_typing_correction_;
}
inline void Config::set_use_typing_correction(bool value) {
  set_has_use_typing_correction();
  use_typing_correction_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_typing_correction)
}

// optional bool use_date_conversion = 80 [default = true];
inline bool Config::has_use_date_conversion() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Config::set_has_use_date_conversion() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Config::clear_has_use_date_conversion() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Config::clear_use_date_conversion() {
  use_date_conversion_ = true;
  clear_has_use_date_conversion();
}
inline bool Config::use_date_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_date_conversion)
  return use_date_conversion_;
}
inline void Config::set_use_date_conversion(bool value) {
  set_has_use_date_conversion();
  use_date_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_date_conversion)
}

// optional bool use_single_kanji_conversion = 81 [default = true];
inline bool Config::has_use_single_kanji_conversion() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Config::set_has_use_single_kanji_conversion() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Config::clear_has_use_single_kanji_conversion() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Config::clear_use_single_kanji_conversion() {
  use_single_kanji_conversion_ = true;
  clear_has_use_single_kanji_conversion();
}
inline bool Config::use_single_kanji_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_single_kanji_conversion)
  return use_single_kanji_conversion_;
}
inline void Config::set_use_single_kanji_conversion(bool value) {
  set_has_use_single_kanji_conversion();
  use_single_kanji_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_single_kanji_conversion)
}

// optional bool use_symbol_conversion = 82 [default = true];
inline bool Config::has_use_symbol_conversion() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Config::set_has_use_symbol_conversion() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Config::clear_has_use_symbol_conversion() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Config::clear_use_symbol_conversion() {
  use_symbol_conversion_ = true;
  clear_has_use_symbol_conversion();
}
inline bool Config::use_symbol_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_symbol_conversion)
  return use_symbol_conversion_;
}
inline void Config::set_use_symbol_conversion(bool value) {
  set_has_use_symbol_conversion();
  use_symbol_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_symbol_conversion)
}

// optional bool use_number_conversion = 83 [default = true];
inline bool Config::has_use_number_conversion() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Config::set_has_use_number_conversion() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Config::clear_has_use_number_conversion() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Config::clear_use_number_conversion() {
  use_number_conversion_ = true;
  clear_has_use_number_conversion();
}
inline bool Config::use_number_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_number_conversion)
  return use_number_conversion_;
}
inline void Config::set_use_number_conversion(bool value) {
  set_has_use_number_conversion();
  use_number_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_number_conversion)
}

// optional bool use_emoticon_conversion = 84 [default = true];
inline bool Config::has_use_emoticon_conversion() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Config::set_has_use_emoticon_conversion() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Config::clear_has_use_emoticon_conversion() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Config::clear_use_emoticon_conversion() {
  use_emoticon_conversion_ = true;
  clear_has_use_emoticon_conversion();
}
inline bool Config::use_emoticon_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_emoticon_conversion)
  return use_emoticon_conversion_;
}
inline void Config::set_use_emoticon_conversion(bool value) {
  set_has_use_emoticon_conversion();
  use_emoticon_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_emoticon_conversion)
}

// optional bool use_calculator = 85 [default = true];
inline bool Config::has_use_calculator() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Config::set_has_use_calculator() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Config::clear_has_use_calculator() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Config::clear_use_calculator() {
  use_calculator_ = true;
  clear_has_use_calculator();
}
inline bool Config::use_calculator() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_calculator)
  return use_calculator_;
}
inline void Config::set_use_calculator(bool value) {
  set_has_use_calculator();
  use_calculator_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_calculator)
}

// optional bool use_t13n_conversion = 86 [default = true];
inline bool Config::has_use_t13n_conversion() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Config::set_has_use_t13n_conversion() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Config::clear_has_use_t13n_conversion() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Config::clear_use_t13n_conversion() {
  use_t13n_conversion_ = true;
  clear_has_use_t13n_conversion();
}
inline bool Config::use_t13n_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_t13n_conversion)
  return use_t13n_conversion_;
}
inline void Config::set_use_t13n_conversion(bool value) {
  set_has_use_t13n_conversion();
  use_t13n_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_t13n_conversion)
}

// optional bool use_zip_code_conversion = 87 [default = true];
inline bool Config::has_use_zip_code_conversion() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Config::set_has_use_zip_code_conversion() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Config::clear_has_use_zip_code_conversion() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Config::clear_use_zip_code_conversion() {
  use_zip_code_conversion_ = true;
  clear_has_use_zip_code_conversion();
}
inline bool Config::use_zip_code_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_zip_code_conversion)
  return use_zip_code_conversion_;
}
inline void Config::set_use_zip_code_conversion(bool value) {
  set_has_use_zip_code_conversion();
  use_zip_code_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_zip_code_conversion)
}

// optional bool use_spelling_correction = 88 [default = true];
inline bool Config::has_use_spelling_correction() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Config::set_has_use_spelling_correction() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Config::clear_has_use_spelling_correction() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Config::clear_use_spelling_correction() {
  use_spelling_correction_ = true;
  clear_has_use_spelling_correction();
}
inline bool Config::use_spelling_correction() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_spelling_correction)
  return use_spelling_correction_;
}
inline void Config::set_use_spelling_correction(bool value) {
  set_has_use_spelling_correction();
  use_spelling_correction_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_spelling_correction)
}

// optional bool use_emoji_conversion = 89 [default = false];
inline bool Config::has_use_emoji_conversion() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Config::set_has_use_emoji_conversion() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Config::clear_has_use_emoji_conversion() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Config::clear_use_emoji_conversion() {
  use_emoji_conversion_ = false;
  clear_has_use_emoji_conversion();
}
inline bool Config::use_emoji_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_emoji_conversion)
  return use_emoji_conversion_;
}
inline void Config::set_use_emoji_conversion(bool value) {
  set_has_use_emoji_conversion();
  use_emoji_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_emoji_conversion)
}

// optional .mozc.config.Config.InformationListConfig information_list_config = 90;
inline bool Config::has_information_list_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_information_list_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_information_list_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_information_list_config() {
  if (information_list_config_ != NULL) information_list_config_->Clear();
  clear_has_information_list_config();
}
inline const ::mozc::config::Config_InformationListConfig& Config::_internal_information_list_config() const {
  return *information_list_config_;
}
inline const ::mozc::config::Config_InformationListConfig& Config::information_list_config() const {
  const ::mozc::config::Config_InformationListConfig* p = information_list_config_;
  // @@protoc_insertion_point(field_get:mozc.config.Config.information_list_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::config::Config_InformationListConfig*>(
      &::mozc::config::_Config_InformationListConfig_default_instance_);
}
inline ::mozc::config::Config_InformationListConfig* Config::release_information_list_config() {
  // @@protoc_insertion_point(field_release:mozc.config.Config.information_list_config)
  clear_has_information_list_config();
  ::mozc::config::Config_InformationListConfig* temp = information_list_config_;
  information_list_config_ = NULL;
  return temp;
}
inline ::mozc::config::Config_InformationListConfig* Config::mutable_information_list_config() {
  set_has_information_list_config();
  if (information_list_config_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::config::Config_InformationListConfig>(GetArenaNoVirtual());
    information_list_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.config.Config.information_list_config)
  return information_list_config_;
}
inline void Config::set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete information_list_config_;
  }
  if (information_list_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      information_list_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, information_list_config, submessage_arena);
    }
    set_has_information_list_config();
  } else {
    clear_has_information_list_config();
  }
  information_list_config_ = information_list_config;
  // @@protoc_insertion_point(field_set_allocated:mozc.config.Config.information_list_config)
}

// optional bool use_history_suggest = 100 [default = true];
inline bool Config::has_use_history_suggest() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Config::set_has_use_history_suggest() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Config::clear_has_use_history_suggest() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Config::clear_use_history_suggest() {
  use_history_suggest_ = true;
  clear_has_use_history_suggest();
}
inline bool Config::use_history_suggest() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_history_suggest)
  return use_history_suggest_;
}
inline void Config::set_use_history_suggest(bool value) {
  set_has_use_history_suggest();
  use_history_suggest_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_history_suggest)
}

// optional bool use_dictionary_suggest = 101 [default = true];
inline bool Config::has_use_dictionary_suggest() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Config::set_has_use_dictionary_suggest() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Config::clear_has_use_dictionary_suggest() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Config::clear_use_dictionary_suggest() {
  use_dictionary_suggest_ = true;
  clear_has_use_dictionary_suggest();
}
inline bool Config::use_dictionary_suggest() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_dictionary_suggest)
  return use_dictionary_suggest_;
}
inline void Config::set_use_dictionary_suggest(bool value) {
  set_has_use_dictionary_suggest();
  use_dictionary_suggest_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_dictionary_suggest)
}

// optional bool use_realtime_conversion = 102 [default = true];
inline bool Config::has_use_realtime_conversion() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Config::set_has_use_realtime_conversion() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Config::clear_has_use_realtime_conversion() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Config::clear_use_realtime_conversion() {
  use_realtime_conversion_ = true;
  clear_has_use_realtime_conversion();
}
inline bool Config::use_realtime_conversion() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_realtime_conversion)
  return use_realtime_conversion_;
}
inline void Config::set_use_realtime_conversion(bool value) {
  set_has_use_realtime_conversion();
  use_realtime_conversion_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_realtime_conversion)
}

// optional uint32 suggestions_size = 110 [default = 3];
inline bool Config::has_suggestions_size() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Config::set_has_suggestions_size() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Config::clear_has_suggestions_size() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Config::clear_suggestions_size() {
  suggestions_size_ = 3u;
  clear_has_suggestions_size();
}
inline ::google::protobuf::uint32 Config::suggestions_size() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.suggestions_size)
  return suggestions_size_;
}
inline void Config::set_suggestions_size(::google::protobuf::uint32 value) {
  set_has_suggestions_size();
  suggestions_size_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.suggestions_size)
}

// optional bool use_mode_indicator = 120 [default = true];
inline bool Config::has_use_mode_indicator() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Config::set_has_use_mode_indicator() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Config::clear_has_use_mode_indicator() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Config::clear_use_mode_indicator() {
  use_mode_indicator_ = true;
  clear_has_use_mode_indicator();
}
inline bool Config::use_mode_indicator() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.use_mode_indicator)
  return use_mode_indicator_;
}
inline void Config::set_use_mode_indicator(bool value) {
  set_has_use_mode_indicator();
  use_mode_indicator_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.use_mode_indicator)
}

// optional bool allow_cloud_handwriting = 301 [default = false];
inline bool Config::has_allow_cloud_handwriting() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Config::set_has_allow_cloud_handwriting() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Config::clear_has_allow_cloud_handwriting() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Config::clear_allow_cloud_handwriting() {
  allow_cloud_handwriting_ = false;
  clear_has_allow_cloud_handwriting();
}
inline bool Config::allow_cloud_handwriting() const {
  // @@protoc_insertion_point(field_get:mozc.config.Config.allow_cloud_handwriting)
  return allow_cloud_handwriting_;
}
inline void Config::set_allow_cloud_handwriting(bool value) {
  set_has_allow_cloud_handwriting();
  allow_cloud_handwriting_ = value;
  // @@protoc_insertion_point(field_set:mozc.config.Config.allow_cloud_handwriting)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace mozc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mozc::config::Config_PreeditMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PreeditMethod>() {
  return ::mozc::config::Config_PreeditMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SessionKeymap> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SessionKeymap>() {
  return ::mozc::config::Config_SessionKeymap_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_PunctuationMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PunctuationMethod>() {
  return ::mozc::config::Config_PunctuationMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SymbolMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SymbolMethod>() {
  return ::mozc::config::Config_SymbolMethod_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_FundamentalCharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_FundamentalCharacterForm>() {
  return ::mozc::config::Config_FundamentalCharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_HistoryLearningLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_HistoryLearningLevel>() {
  return ::mozc::config::Config_HistoryLearningLevel_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_SelectionShortcut> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SelectionShortcut>() {
  return ::mozc::config::Config_SelectionShortcut_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_CharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_CharacterForm>() {
  return ::mozc::config::Config_CharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_ShiftKeyModeSwitch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_ShiftKeyModeSwitch>() {
  return ::mozc::config::Config_ShiftKeyModeSwitch_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_NumpadCharacterForm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_NumpadCharacterForm>() {
  return ::mozc::config::Config_NumpadCharacterForm_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_AutoConversionKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_AutoConversionKey>() {
  return ::mozc::config::Config_AutoConversionKey_descriptor();
}
template <> struct is_proto_enum< ::mozc::config::Config_YenSignCharacter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_YenSignCharacter>() {
  return ::mozc::config::Config_YenSignCharacter_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2fconfig_2eproto
