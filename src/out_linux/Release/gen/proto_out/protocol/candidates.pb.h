// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/candidates.proto

#ifndef PROTOBUF_INCLUDED_protocol_2fcandidates_2eproto
#define PROTOBUF_INCLUDED_protocol_2fcandidates_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2fcandidates_2eproto 

namespace protobuf_protocol_2fcandidates_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2fcandidates_2eproto
namespace mozc {
namespace commands {
class Annotation;
class AnnotationDefaultTypeInternal;
extern AnnotationDefaultTypeInternal _Annotation_default_instance_;
class CandidateList;
class CandidateListDefaultTypeInternal;
extern CandidateListDefaultTypeInternal _CandidateList_default_instance_;
class CandidateWord;
class CandidateWordDefaultTypeInternal;
extern CandidateWordDefaultTypeInternal _CandidateWord_default_instance_;
class Candidates;
class CandidatesDefaultTypeInternal;
extern CandidatesDefaultTypeInternal _Candidates_default_instance_;
class Candidates_Candidate;
class Candidates_CandidateDefaultTypeInternal;
extern Candidates_CandidateDefaultTypeInternal _Candidates_Candidate_default_instance_;
class Footer;
class FooterDefaultTypeInternal;
extern FooterDefaultTypeInternal _Footer_default_instance_;
class Information;
class InformationDefaultTypeInternal;
extern InformationDefaultTypeInternal _Information_default_instance_;
class InformationList;
class InformationListDefaultTypeInternal;
extern InformationListDefaultTypeInternal _InformationList_default_instance_;
}  // namespace commands
}  // namespace mozc
namespace google {
namespace protobuf {
template<> ::mozc::commands::Annotation* Arena::CreateMaybeMessage<::mozc::commands::Annotation>(Arena*);
template<> ::mozc::commands::CandidateList* Arena::CreateMaybeMessage<::mozc::commands::CandidateList>(Arena*);
template<> ::mozc::commands::CandidateWord* Arena::CreateMaybeMessage<::mozc::commands::CandidateWord>(Arena*);
template<> ::mozc::commands::Candidates* Arena::CreateMaybeMessage<::mozc::commands::Candidates>(Arena*);
template<> ::mozc::commands::Candidates_Candidate* Arena::CreateMaybeMessage<::mozc::commands::Candidates_Candidate>(Arena*);
template<> ::mozc::commands::Footer* Arena::CreateMaybeMessage<::mozc::commands::Footer>(Arena*);
template<> ::mozc::commands::Information* Arena::CreateMaybeMessage<::mozc::commands::Information>(Arena*);
template<> ::mozc::commands::InformationList* Arena::CreateMaybeMessage<::mozc::commands::InformationList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mozc {
namespace commands {

enum Candidates_Direction {
  Candidates_Direction_VERTICAL = 0,
  Candidates_Direction_HORIZONTAL = 1
};
bool Candidates_Direction_IsValid(int value);
const Candidates_Direction Candidates_Direction_Direction_MIN = Candidates_Direction_VERTICAL;
const Candidates_Direction Candidates_Direction_Direction_MAX = Candidates_Direction_HORIZONTAL;
const int Candidates_Direction_Direction_ARRAYSIZE = Candidates_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Candidates_Direction_descriptor();
inline const ::std::string& Candidates_Direction_Name(Candidates_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Candidates_Direction_descriptor(), value);
}
inline bool Candidates_Direction_Parse(
    const ::std::string& name, Candidates_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Candidates_Direction>(
    Candidates_Direction_descriptor(), name, value);
}
enum Category {
  CONVERSION = 0,
  PREDICTION = 1,
  SUGGESTION = 2,
  TRANSLITERATION = 3,
  USAGE = 4
};
bool Category_IsValid(int value);
const Category Category_MIN = CONVERSION;
const Category Category_MAX = USAGE;
const int Category_ARRAYSIZE = Category_MAX + 1;

const ::google::protobuf::EnumDescriptor* Category_descriptor();
inline const ::std::string& Category_Name(Category value) {
  return ::google::protobuf::internal::NameOfEnum(
    Category_descriptor(), value);
}
inline bool Category_Parse(
    const ::std::string& name, Category* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Category>(
    Category_descriptor(), name, value);
}
enum DisplayType {
  MAIN = 0,
  CASCADE = 1
};
bool DisplayType_IsValid(int value);
const DisplayType DisplayType_MIN = MAIN;
const DisplayType DisplayType_MAX = CASCADE;
const int DisplayType_ARRAYSIZE = DisplayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayType_descriptor();
inline const ::std::string& DisplayType_Name(DisplayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayType_descriptor(), value);
}
inline bool DisplayType_Parse(
    const ::std::string& name, DisplayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayType>(
    DisplayType_descriptor(), name, value);
}
// ===================================================================

class Annotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Annotation) */ {
 public:
  Annotation();
  virtual ~Annotation();

  Annotation(const Annotation& from);

  inline Annotation& operator=(const Annotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Annotation(Annotation&& from) noexcept
    : Annotation() {
    *this = ::std::move(from);
  }

  inline Annotation& operator=(Annotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Annotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Annotation* internal_default_instance() {
    return reinterpret_cast<const Annotation*>(
               &_Annotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Annotation* other);
  friend void swap(Annotation& a, Annotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Annotation* New() const final {
    return CreateMaybeMessage<Annotation>(NULL);
  }

  Annotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Annotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Annotation& from);
  void MergeFrom(const Annotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 2;
  bool has_suffix() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 2;
  const ::std::string& suffix() const;
  void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  void set_suffix(::std::string&& value);
  #endif
  void set_suffix(const char* value);
  void set_suffix(const char* value, size_t size);
  ::std::string* mutable_suffix();
  ::std::string* release_suffix();
  void set_allocated_suffix(::std::string* suffix);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string shortcut = 4;
  bool has_shortcut() const;
  void clear_shortcut();
  static const int kShortcutFieldNumber = 4;
  const ::std::string& shortcut() const;
  void set_shortcut(const ::std::string& value);
  #if LANG_CXX11
  void set_shortcut(::std::string&& value);
  #endif
  void set_shortcut(const char* value);
  void set_shortcut(const char* value, size_t size);
  ::std::string* mutable_shortcut();
  ::std::string* release_shortcut();
  void set_allocated_shortcut(::std::string* shortcut);

  // optional bool deletable = 5 [default = false];
  bool has_deletable() const;
  void clear_deletable();
  static const int kDeletableFieldNumber = 5;
  bool deletable() const;
  void set_deletable(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Annotation)
 private:
  void set_has_prefix();
  void clear_has_prefix();
  void set_has_suffix();
  void clear_has_suffix();
  void set_has_description();
  void clear_has_description();
  void set_has_shortcut();
  void clear_has_shortcut();
  void set_has_deletable();
  void clear_has_deletable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr shortcut_;
  bool deletable_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Information : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Information) */ {
 public:
  Information();
  virtual ~Information();

  Information(const Information& from);

  inline Information& operator=(const Information& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Information(Information&& from) noexcept
    : Information() {
    *this = ::std::move(from);
  }

  inline Information& operator=(Information&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Information& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Information* internal_default_instance() {
    return reinterpret_cast<const Information*>(
               &_Information_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Information* other);
  friend void swap(Information& a, Information& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Information* New() const final {
    return CreateMaybeMessage<Information>(NULL);
  }

  Information* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Information>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Information& from);
  void MergeFrom(const Information& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Information* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 candidate_id = 4;
  int candidate_id_size() const;
  void clear_candidate_id();
  static const int kCandidateIdFieldNumber = 4;
  ::google::protobuf::int32 candidate_id(int index) const;
  void set_candidate_id(int index, ::google::protobuf::int32 value);
  void add_candidate_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      candidate_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_candidate_id();

  // optional string title = 2;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Information)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_title();
  void clear_has_title();
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > candidate_id_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InformationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.InformationList) */ {
 public:
  InformationList();
  virtual ~InformationList();

  InformationList(const InformationList& from);

  inline InformationList& operator=(const InformationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InformationList(InformationList&& from) noexcept
    : InformationList() {
    *this = ::std::move(from);
  }

  inline InformationList& operator=(InformationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InformationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InformationList* internal_default_instance() {
    return reinterpret_cast<const InformationList*>(
               &_InformationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(InformationList* other);
  friend void swap(InformationList& a, InformationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InformationList* New() const final {
    return CreateMaybeMessage<InformationList>(NULL);
  }

  InformationList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InformationList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InformationList& from);
  void MergeFrom(const InformationList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InformationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.Information information = 2;
  int information_size() const;
  void clear_information();
  static const int kInformationFieldNumber = 2;
  ::mozc::commands::Information* mutable_information(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >*
      mutable_information();
  const ::mozc::commands::Information& information(int index) const;
  ::mozc::commands::Information* add_information();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >&
      information() const;

  // optional uint32 focused_index = 1;
  bool has_focused_index() const;
  void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  ::google::protobuf::uint32 focused_index() const;
  void set_focused_index(::google::protobuf::uint32 value);

  // optional .mozc.commands.Category category = 3 [default = CONVERSION];
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 3;
  ::mozc::commands::Category category() const;
  void set_category(::mozc::commands::Category value);

  // optional .mozc.commands.DisplayType display_type = 4 [default = CASCADE];
  bool has_display_type() const;
  void clear_display_type();
  static const int kDisplayTypeFieldNumber = 4;
  ::mozc::commands::DisplayType display_type() const;
  void set_display_type(::mozc::commands::DisplayType value);

  // optional uint32 delay = 5 [default = 500];
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 5;
  ::google::protobuf::uint32 delay() const;
  void set_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.InformationList)
 private:
  void set_has_focused_index();
  void clear_has_focused_index();
  void set_has_category();
  void clear_has_category();
  void set_has_display_type();
  void clear_has_display_type();
  void set_has_delay();
  void clear_has_delay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information > information_;
  ::google::protobuf::uint32 focused_index_;
  int category_;
  int display_type_;
  ::google::protobuf::uint32 delay_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Footer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Footer) */ {
 public:
  Footer();
  virtual ~Footer();

  Footer(const Footer& from);

  inline Footer& operator=(const Footer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Footer(Footer&& from) noexcept
    : Footer() {
    *this = ::std::move(from);
  }

  inline Footer& operator=(Footer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Footer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Footer* internal_default_instance() {
    return reinterpret_cast<const Footer*>(
               &_Footer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Footer* other);
  friend void swap(Footer& a, Footer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Footer* New() const final {
    return CreateMaybeMessage<Footer>(NULL);
  }

  Footer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Footer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Footer& from);
  void MergeFrom(const Footer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Footer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string label = 1;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional string sub_label = 4;
  bool has_sub_label() const;
  void clear_sub_label();
  static const int kSubLabelFieldNumber = 4;
  const ::std::string& sub_label() const;
  void set_sub_label(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_label(::std::string&& value);
  #endif
  void set_sub_label(const char* value);
  void set_sub_label(const char* value, size_t size);
  ::std::string* mutable_sub_label();
  ::std::string* release_sub_label();
  void set_allocated_sub_label(::std::string* sub_label);

  // optional bool index_visible = 2 [default = false];
  bool has_index_visible() const;
  void clear_index_visible();
  static const int kIndexVisibleFieldNumber = 2;
  bool index_visible() const;
  void set_index_visible(bool value);

  // optional bool logo_visible = 3 [default = false];
  bool has_logo_visible() const;
  void clear_logo_visible();
  static const int kLogoVisibleFieldNumber = 3;
  bool logo_visible() const;
  void set_logo_visible(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Footer)
 private:
  void set_has_label();
  void clear_has_label();
  void set_has_index_visible();
  void clear_has_index_visible();
  void set_has_logo_visible();
  void clear_has_logo_visible();
  void set_has_sub_label();
  void clear_has_sub_label();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr sub_label_;
  bool index_visible_;
  bool logo_visible_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CandidateWord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.CandidateWord) */ {
 public:
  CandidateWord();
  virtual ~CandidateWord();

  CandidateWord(const CandidateWord& from);

  inline CandidateWord& operator=(const CandidateWord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CandidateWord(CandidateWord&& from) noexcept
    : CandidateWord() {
    *this = ::std::move(from);
  }

  inline CandidateWord& operator=(CandidateWord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CandidateWord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CandidateWord* internal_default_instance() {
    return reinterpret_cast<const CandidateWord*>(
               &_CandidateWord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CandidateWord* other);
  friend void swap(CandidateWord& a, CandidateWord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CandidateWord* New() const final {
    return CreateMaybeMessage<CandidateWord>(NULL);
  }

  CandidateWord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CandidateWord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CandidateWord& from);
  void MergeFrom(const CandidateWord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandidateWord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .mozc.commands.Annotation annotation = 5;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 5;
  private:
  const ::mozc::commands::Annotation& _internal_annotation() const;
  public:
  const ::mozc::commands::Annotation& annotation() const;
  ::mozc::commands::Annotation* release_annotation();
  ::mozc::commands::Annotation* mutable_annotation();
  void set_allocated_annotation(::mozc::commands::Annotation* annotation);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional uint32 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.CandidateWord)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_index();
  void clear_has_index();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_annotation();
  void clear_has_annotation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::mozc::commands::Annotation* annotation_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 index_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CandidateList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.CandidateList) */ {
 public:
  CandidateList();
  virtual ~CandidateList();

  CandidateList(const CandidateList& from);

  inline CandidateList& operator=(const CandidateList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CandidateList(CandidateList&& from) noexcept
    : CandidateList() {
    *this = ::std::move(from);
  }

  inline CandidateList& operator=(CandidateList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CandidateList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CandidateList* internal_default_instance() {
    return reinterpret_cast<const CandidateList*>(
               &_CandidateList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CandidateList* other);
  friend void swap(CandidateList& a, CandidateList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CandidateList* New() const final {
    return CreateMaybeMessage<CandidateList>(NULL);
  }

  CandidateList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CandidateList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CandidateList& from);
  void MergeFrom(const CandidateList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandidateList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.CandidateWord candidates = 2;
  int candidates_size() const;
  void clear_candidates();
  static const int kCandidatesFieldNumber = 2;
  ::mozc::commands::CandidateWord* mutable_candidates(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >*
      mutable_candidates();
  const ::mozc::commands::CandidateWord& candidates(int index) const;
  ::mozc::commands::CandidateWord* add_candidates();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >&
      candidates() const;

  // optional uint32 focused_index = 1;
  bool has_focused_index() const;
  void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  ::google::protobuf::uint32 focused_index() const;
  void set_focused_index(::google::protobuf::uint32 value);

  // optional .mozc.commands.Category category = 3 [default = CONVERSION];
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 3;
  ::mozc::commands::Category category() const;
  void set_category(::mozc::commands::Category value);

  // @@protoc_insertion_point(class_scope:mozc.commands.CandidateList)
 private:
  void set_has_focused_index();
  void clear_has_focused_index();
  void set_has_category();
  void clear_has_category();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord > candidates_;
  ::google::protobuf::uint32 focused_index_;
  int category_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Candidates_Candidate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Candidates.Candidate) */ {
 public:
  Candidates_Candidate();
  virtual ~Candidates_Candidate();

  Candidates_Candidate(const Candidates_Candidate& from);

  inline Candidates_Candidate& operator=(const Candidates_Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Candidates_Candidate(Candidates_Candidate&& from) noexcept
    : Candidates_Candidate() {
    *this = ::std::move(from);
  }

  inline Candidates_Candidate& operator=(Candidates_Candidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Candidates_Candidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Candidates_Candidate* internal_default_instance() {
    return reinterpret_cast<const Candidates_Candidate*>(
               &_Candidates_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Candidates_Candidate* other);
  friend void swap(Candidates_Candidate& a, Candidates_Candidate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Candidates_Candidate* New() const final {
    return CreateMaybeMessage<Candidates_Candidate>(NULL);
  }

  Candidates_Candidate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Candidates_Candidate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Candidates_Candidate& from);
  void MergeFrom(const Candidates_Candidate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Candidates_Candidate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .mozc.commands.Annotation annotation = 7;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 7;
  private:
  const ::mozc::commands::Annotation& _internal_annotation() const;
  public:
  const ::mozc::commands::Annotation& annotation() const;
  ::mozc::commands::Annotation* release_annotation();
  ::mozc::commands::Annotation* mutable_annotation();
  void set_allocated_annotation(::mozc::commands::Annotation* annotation);

  // optional int32 information_id = 10;
  bool has_information_id() const;
  void clear_information_id();
  static const int kInformationIdFieldNumber = 10;
  ::google::protobuf::int32 information_id() const;
  void set_information_id(::google::protobuf::int32 value);

  // required uint32 index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional int32 id = 9;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 9;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Candidates.Candidate)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_value();
  void clear_has_value();
  void set_has_id();
  void clear_has_id();
  void set_has_annotation();
  void clear_has_annotation();
  void set_has_information_id();
  void clear_has_information_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::mozc::commands::Annotation* annotation_;
  ::google::protobuf::int32 information_id_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Candidates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mozc.commands.Candidates) */ {
 public:
  Candidates();
  virtual ~Candidates();

  Candidates(const Candidates& from);

  inline Candidates& operator=(const Candidates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Candidates(Candidates&& from) noexcept
    : Candidates() {
    *this = ::std::move(from);
  }

  inline Candidates& operator=(Candidates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Candidates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Candidates* internal_default_instance() {
    return reinterpret_cast<const Candidates*>(
               &_Candidates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Candidates* other);
  friend void swap(Candidates& a, Candidates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Candidates* New() const final {
    return CreateMaybeMessage<Candidates>(NULL);
  }

  Candidates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Candidates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Candidates& from);
  void MergeFrom(const Candidates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Candidates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Candidates_Candidate Candidate;

  typedef Candidates_Direction Direction;
  static const Direction VERTICAL =
    Candidates_Direction_VERTICAL;
  static const Direction HORIZONTAL =
    Candidates_Direction_HORIZONTAL;
  static inline bool Direction_IsValid(int value) {
    return Candidates_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Candidates_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Candidates_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Candidates_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Candidates_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Candidates_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Candidates_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated group Candidate = 3 { ... };
  int candidate_size() const;
  void clear_candidate();
  static const int kCandidateFieldNumber = 3;
  ::mozc::commands::Candidates_Candidate* mutable_candidate(int index);
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >*
      mutable_candidate();
  const ::mozc::commands::Candidates_Candidate& candidate(int index) const;
  ::mozc::commands::Candidates_Candidate* add_candidate();
  const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >&
      candidate() const;

  // optional .mozc.commands.Candidates subcandidates = 8;
  bool has_subcandidates() const;
  void clear_subcandidates();
  static const int kSubcandidatesFieldNumber = 8;
  private:
  const ::mozc::commands::Candidates& _internal_subcandidates() const;
  public:
  const ::mozc::commands::Candidates& subcandidates() const;
  ::mozc::commands::Candidates* release_subcandidates();
  ::mozc::commands::Candidates* mutable_subcandidates();
  void set_allocated_subcandidates(::mozc::commands::Candidates* subcandidates);

  // optional .mozc.commands.InformationList usages = 10;
  bool has_usages() const;
  void clear_usages();
  static const int kUsagesFieldNumber = 10;
  private:
  const ::mozc::commands::InformationList& _internal_usages() const;
  public:
  const ::mozc::commands::InformationList& usages() const;
  ::mozc::commands::InformationList* release_usages();
  ::mozc::commands::InformationList* mutable_usages();
  void set_allocated_usages(::mozc::commands::InformationList* usages);

  // optional .mozc.commands.Footer footer = 13;
  bool has_footer() const;
  void clear_footer();
  static const int kFooterFieldNumber = 13;
  private:
  const ::mozc::commands::Footer& _internal_footer() const;
  public:
  const ::mozc::commands::Footer& footer() const;
  ::mozc::commands::Footer* release_footer();
  ::mozc::commands::Footer* mutable_footer();
  void set_allocated_footer(::mozc::commands::Footer* footer);

  // optional uint32 focused_index = 1;
  bool has_focused_index() const;
  void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  ::google::protobuf::uint32 focused_index() const;
  void set_focused_index(::google::protobuf::uint32 value);

  // required uint32 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // required uint32 position = 6;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 6;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // optional .mozc.commands.Category category = 11 [default = CONVERSION];
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 11;
  ::mozc::commands::Category category() const;
  void set_category(::mozc::commands::Category value);

  // optional .mozc.commands.DisplayType display_type = 12 [default = MAIN];
  bool has_display_type() const;
  void clear_display_type();
  static const int kDisplayTypeFieldNumber = 12;
  ::mozc::commands::DisplayType display_type() const;
  void set_display_type(::mozc::commands::DisplayType value);

  // optional .mozc.commands.Candidates.Direction direction = 14 [default = VERTICAL];
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 14;
  ::mozc::commands::Candidates_Direction direction() const;
  void set_direction(::mozc::commands::Candidates_Direction value);

  // optional uint32 page_size = 18 [default = 9];
  bool has_page_size() const;
  void clear_page_size();
  static const int kPageSizeFieldNumber = 18;
  ::google::protobuf::uint32 page_size() const;
  void set_page_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Candidates)
 private:
  void set_has_focused_index();
  void clear_has_focused_index();
  void set_has_size();
  void clear_has_size();
  void set_has_position();
  void clear_has_position();
  void set_has_subcandidates();
  void clear_has_subcandidates();
  void set_has_usages();
  void clear_has_usages();
  void set_has_category();
  void clear_has_category();
  void set_has_display_type();
  void clear_has_display_type();
  void set_has_footer();
  void clear_has_footer();
  void set_has_direction();
  void clear_has_direction();
  void set_has_page_size();
  void clear_has_page_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate > candidate_;
  ::mozc::commands::Candidates* subcandidates_;
  ::mozc::commands::InformationList* usages_;
  ::mozc::commands::Footer* footer_;
  ::google::protobuf::uint32 focused_index_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 position_;
  int category_;
  int display_type_;
  int direction_;
  ::google::protobuf::uint32 page_size_;
  friend struct ::protobuf_protocol_2fcandidates_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Annotation

// optional string prefix = 1;
inline bool Annotation::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Annotation::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Annotation::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Annotation::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix();
}
inline const ::std::string& Annotation::prefix() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Annotation.prefix)
  return prefix_.GetNoArena();
}
inline void Annotation::set_prefix(const ::std::string& value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Annotation.prefix)
}
#if LANG_CXX11
inline void Annotation::set_prefix(::std::string&& value) {
  set_has_prefix();
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Annotation.prefix)
}
#endif
inline void Annotation::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Annotation.prefix)
}
inline void Annotation::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Annotation.prefix)
}
inline ::std::string* Annotation::mutable_prefix() {
  set_has_prefix();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Annotation.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_prefix() {
  // @@protoc_insertion_point(field_release:mozc.commands.Annotation.prefix)
  if (!has_prefix()) {
    return NULL;
  }
  clear_has_prefix();
  return prefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Annotation.prefix)
}

// optional string suffix = 2;
inline bool Annotation::has_suffix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Annotation::set_has_suffix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Annotation::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Annotation::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_suffix();
}
inline const ::std::string& Annotation::suffix() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Annotation.suffix)
  return suffix_.GetNoArena();
}
inline void Annotation::set_suffix(const ::std::string& value) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Annotation.suffix)
}
#if LANG_CXX11
inline void Annotation::set_suffix(::std::string&& value) {
  set_has_suffix();
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Annotation.suffix)
}
#endif
inline void Annotation::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Annotation.suffix)
}
inline void Annotation::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Annotation.suffix)
}
inline ::std::string* Annotation::mutable_suffix() {
  set_has_suffix();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Annotation.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_suffix() {
  // @@protoc_insertion_point(field_release:mozc.commands.Annotation.suffix)
  if (!has_suffix()) {
    return NULL;
  }
  clear_has_suffix();
  return suffix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_suffix(::std::string* suffix) {
  if (suffix != NULL) {
    set_has_suffix();
  } else {
    clear_has_suffix();
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Annotation.suffix)
}

// optional string description = 3;
inline bool Annotation::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Annotation::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Annotation::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Annotation::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& Annotation::description() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Annotation.description)
  return description_.GetNoArena();
}
inline void Annotation::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Annotation.description)
}
#if LANG_CXX11
inline void Annotation::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Annotation.description)
}
#endif
inline void Annotation::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Annotation.description)
}
inline void Annotation::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Annotation.description)
}
inline ::std::string* Annotation::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Annotation.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_description() {
  // @@protoc_insertion_point(field_release:mozc.commands.Annotation.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Annotation.description)
}

// optional string shortcut = 4;
inline bool Annotation::has_shortcut() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Annotation::set_has_shortcut() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Annotation::clear_has_shortcut() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Annotation::clear_shortcut() {
  shortcut_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_shortcut();
}
inline const ::std::string& Annotation::shortcut() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Annotation.shortcut)
  return shortcut_.GetNoArena();
}
inline void Annotation::set_shortcut(const ::std::string& value) {
  set_has_shortcut();
  shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Annotation.shortcut)
}
#if LANG_CXX11
inline void Annotation::set_shortcut(::std::string&& value) {
  set_has_shortcut();
  shortcut_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Annotation.shortcut)
}
#endif
inline void Annotation::set_shortcut(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_shortcut();
  shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Annotation.shortcut)
}
inline void Annotation::set_shortcut(const char* value, size_t size) {
  set_has_shortcut();
  shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Annotation.shortcut)
}
inline ::std::string* Annotation::mutable_shortcut() {
  set_has_shortcut();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Annotation.shortcut)
  return shortcut_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_shortcut() {
  // @@protoc_insertion_point(field_release:mozc.commands.Annotation.shortcut)
  if (!has_shortcut()) {
    return NULL;
  }
  clear_has_shortcut();
  return shortcut_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_shortcut(::std::string* shortcut) {
  if (shortcut != NULL) {
    set_has_shortcut();
  } else {
    clear_has_shortcut();
  }
  shortcut_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shortcut);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Annotation.shortcut)
}

// optional bool deletable = 5 [default = false];
inline bool Annotation::has_deletable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Annotation::set_has_deletable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Annotation::clear_has_deletable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Annotation::clear_deletable() {
  deletable_ = false;
  clear_has_deletable();
}
inline bool Annotation::deletable() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Annotation.deletable)
  return deletable_;
}
inline void Annotation::set_deletable(bool value) {
  set_has_deletable();
  deletable_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Annotation.deletable)
}

// -------------------------------------------------------------------

// Information

// optional int32 id = 1;
inline bool Information::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Information::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Information::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Information::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Information::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Information.id)
  return id_;
}
inline void Information::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Information.id)
}

// optional string title = 2;
inline bool Information::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Information::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Information::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Information::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& Information::title() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Information.title)
  return title_.GetNoArena();
}
inline void Information::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Information.title)
}
#if LANG_CXX11
inline void Information::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Information.title)
}
#endif
inline void Information::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Information.title)
}
inline void Information::set_title(const char* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Information.title)
}
inline ::std::string* Information::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Information.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Information::release_title() {
  // @@protoc_insertion_point(field_release:mozc.commands.Information.title)
  if (!has_title()) {
    return NULL;
  }
  clear_has_title();
  return title_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Information::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Information.title)
}

// optional string description = 3;
inline bool Information::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Information::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Information::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Information::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& Information::description() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Information.description)
  return description_.GetNoArena();
}
inline void Information::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Information.description)
}
#if LANG_CXX11
inline void Information::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Information.description)
}
#endif
inline void Information::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Information.description)
}
inline void Information::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Information.description)
}
inline ::std::string* Information::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Information.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Information::release_description() {
  // @@protoc_insertion_point(field_release:mozc.commands.Information.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Information::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Information.description)
}

// repeated int32 candidate_id = 4;
inline int Information::candidate_id_size() const {
  return candidate_id_.size();
}
inline void Information::clear_candidate_id() {
  candidate_id_.Clear();
}
inline ::google::protobuf::int32 Information::candidate_id(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Information.candidate_id)
  return candidate_id_.Get(index);
}
inline void Information::set_candidate_id(int index, ::google::protobuf::int32 value) {
  candidate_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozc.commands.Information.candidate_id)
}
inline void Information::add_candidate_id(::google::protobuf::int32 value) {
  candidate_id_.Add(value);
  // @@protoc_insertion_point(field_add:mozc.commands.Information.candidate_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Information::candidate_id() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Information.candidate_id)
  return candidate_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Information::mutable_candidate_id() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Information.candidate_id)
  return &candidate_id_;
}

// -------------------------------------------------------------------

// InformationList

// optional uint32 focused_index = 1;
inline bool InformationList::has_focused_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InformationList::set_has_focused_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InformationList::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InformationList::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 InformationList::focused_index() const {
  // @@protoc_insertion_point(field_get:mozc.commands.InformationList.focused_index)
  return focused_index_;
}
inline void InformationList::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.InformationList.focused_index)
}

// repeated .mozc.commands.Information information = 2;
inline int InformationList::information_size() const {
  return information_.size();
}
inline void InformationList::clear_information() {
  information_.Clear();
}
inline ::mozc::commands::Information* InformationList::mutable_information(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.InformationList.information)
  return information_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >*
InformationList::mutable_information() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.InformationList.information)
  return &information_;
}
inline const ::mozc::commands::Information& InformationList::information(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.InformationList.information)
  return information_.Get(index);
}
inline ::mozc::commands::Information* InformationList::add_information() {
  // @@protoc_insertion_point(field_add:mozc.commands.InformationList.information)
  return information_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >&
InformationList::information() const {
  // @@protoc_insertion_point(field_list:mozc.commands.InformationList.information)
  return information_;
}

// optional .mozc.commands.Category category = 3 [default = CONVERSION];
inline bool InformationList::has_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InformationList::set_has_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InformationList::clear_has_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InformationList::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category InformationList::category() const {
  // @@protoc_insertion_point(field_get:mozc.commands.InformationList.category)
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void InformationList::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.InformationList.category)
}

// optional .mozc.commands.DisplayType display_type = 4 [default = CASCADE];
inline bool InformationList::has_display_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InformationList::set_has_display_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InformationList::clear_has_display_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InformationList::clear_display_type() {
  display_type_ = 1;
  clear_has_display_type();
}
inline ::mozc::commands::DisplayType InformationList::display_type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.InformationList.display_type)
  return static_cast< ::mozc::commands::DisplayType >(display_type_);
}
inline void InformationList::set_display_type(::mozc::commands::DisplayType value) {
  assert(::mozc::commands::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.InformationList.display_type)
}

// optional uint32 delay = 5 [default = 500];
inline bool InformationList::has_delay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InformationList::set_has_delay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InformationList::clear_has_delay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InformationList::clear_delay() {
  delay_ = 500u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 InformationList::delay() const {
  // @@protoc_insertion_point(field_get:mozc.commands.InformationList.delay)
  return delay_;
}
inline void InformationList::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.InformationList.delay)
}

// -------------------------------------------------------------------

// Footer

// optional string label = 1;
inline bool Footer::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Footer::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Footer::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Footer::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& Footer::label() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Footer.label)
  return label_.GetNoArena();
}
inline void Footer::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Footer.label)
}
#if LANG_CXX11
inline void Footer::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Footer.label)
}
#endif
inline void Footer::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Footer.label)
}
inline void Footer::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Footer.label)
}
inline ::std::string* Footer::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Footer.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Footer::release_label() {
  // @@protoc_insertion_point(field_release:mozc.commands.Footer.label)
  if (!has_label()) {
    return NULL;
  }
  clear_has_label();
  return label_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Footer::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Footer.label)
}

// optional bool index_visible = 2 [default = false];
inline bool Footer::has_index_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Footer::set_has_index_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Footer::clear_has_index_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Footer::clear_index_visible() {
  index_visible_ = false;
  clear_has_index_visible();
}
inline bool Footer::index_visible() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Footer.index_visible)
  return index_visible_;
}
inline void Footer::set_index_visible(bool value) {
  set_has_index_visible();
  index_visible_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Footer.index_visible)
}

// optional bool logo_visible = 3 [default = false];
inline bool Footer::has_logo_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Footer::set_has_logo_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Footer::clear_has_logo_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Footer::clear_logo_visible() {
  logo_visible_ = false;
  clear_has_logo_visible();
}
inline bool Footer::logo_visible() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Footer.logo_visible)
  return logo_visible_;
}
inline void Footer::set_logo_visible(bool value) {
  set_has_logo_visible();
  logo_visible_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Footer.logo_visible)
}

// optional string sub_label = 4;
inline bool Footer::has_sub_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Footer::set_has_sub_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Footer::clear_has_sub_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Footer::clear_sub_label() {
  sub_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sub_label();
}
inline const ::std::string& Footer::sub_label() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Footer.sub_label)
  return sub_label_.GetNoArena();
}
inline void Footer::set_sub_label(const ::std::string& value) {
  set_has_sub_label();
  sub_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Footer.sub_label)
}
#if LANG_CXX11
inline void Footer::set_sub_label(::std::string&& value) {
  set_has_sub_label();
  sub_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Footer.sub_label)
}
#endif
inline void Footer::set_sub_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sub_label();
  sub_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Footer.sub_label)
}
inline void Footer::set_sub_label(const char* value, size_t size) {
  set_has_sub_label();
  sub_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Footer.sub_label)
}
inline ::std::string* Footer::mutable_sub_label() {
  set_has_sub_label();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Footer.sub_label)
  return sub_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Footer::release_sub_label() {
  // @@protoc_insertion_point(field_release:mozc.commands.Footer.sub_label)
  if (!has_sub_label()) {
    return NULL;
  }
  clear_has_sub_label();
  return sub_label_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Footer::set_allocated_sub_label(::std::string* sub_label) {
  if (sub_label != NULL) {
    set_has_sub_label();
  } else {
    clear_has_sub_label();
  }
  sub_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_label);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Footer.sub_label)
}

// -------------------------------------------------------------------

// CandidateWord

// optional int32 id = 1;
inline bool CandidateWord::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CandidateWord::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CandidateWord::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CandidateWord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CandidateWord::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateWord.id)
  return id_;
}
inline void CandidateWord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateWord.id)
}

// optional uint32 index = 2;
inline bool CandidateWord::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CandidateWord::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CandidateWord::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CandidateWord::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CandidateWord::index() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateWord.index)
  return index_;
}
inline void CandidateWord::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateWord.index)
}

// optional string key = 3;
inline bool CandidateWord::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CandidateWord::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CandidateWord::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CandidateWord::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& CandidateWord::key() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateWord.key)
  return key_.GetNoArena();
}
inline void CandidateWord::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateWord.key)
}
#if LANG_CXX11
inline void CandidateWord::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.CandidateWord.key)
}
#endif
inline void CandidateWord::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.CandidateWord.key)
}
inline void CandidateWord::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.CandidateWord.key)
}
inline ::std::string* CandidateWord::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozc.commands.CandidateWord.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CandidateWord::release_key() {
  // @@protoc_insertion_point(field_release:mozc.commands.CandidateWord.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CandidateWord::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.CandidateWord.key)
}

// optional string value = 4;
inline bool CandidateWord::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CandidateWord::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CandidateWord::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CandidateWord::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& CandidateWord::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateWord.value)
  return value_.GetNoArena();
}
inline void CandidateWord::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateWord.value)
}
#if LANG_CXX11
inline void CandidateWord::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.CandidateWord.value)
}
#endif
inline void CandidateWord::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.CandidateWord.value)
}
inline void CandidateWord::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.CandidateWord.value)
}
inline ::std::string* CandidateWord::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozc.commands.CandidateWord.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CandidateWord::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.CandidateWord.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CandidateWord::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.CandidateWord.value)
}

// optional .mozc.commands.Annotation annotation = 5;
inline bool CandidateWord::has_annotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CandidateWord::set_has_annotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CandidateWord::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CandidateWord::clear_annotation() {
  if (annotation_ != NULL) annotation_->Clear();
  clear_has_annotation();
}
inline const ::mozc::commands::Annotation& CandidateWord::_internal_annotation() const {
  return *annotation_;
}
inline const ::mozc::commands::Annotation& CandidateWord::annotation() const {
  const ::mozc::commands::Annotation* p = annotation_;
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateWord.annotation)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Annotation*>(
      &::mozc::commands::_Annotation_default_instance_);
}
inline ::mozc::commands::Annotation* CandidateWord::release_annotation() {
  // @@protoc_insertion_point(field_release:mozc.commands.CandidateWord.annotation)
  clear_has_annotation();
  ::mozc::commands::Annotation* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline ::mozc::commands::Annotation* CandidateWord::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Annotation>(GetArenaNoVirtual());
    annotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.CandidateWord.annotation)
  return annotation_;
}
inline void CandidateWord::set_allocated_annotation(::mozc::commands::Annotation* annotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotation_;
  }
  if (annotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.CandidateWord.annotation)
}

// -------------------------------------------------------------------

// CandidateList

// optional uint32 focused_index = 1;
inline bool CandidateList::has_focused_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CandidateList::set_has_focused_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CandidateList::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CandidateList::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 CandidateList::focused_index() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateList.focused_index)
  return focused_index_;
}
inline void CandidateList::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateList.focused_index)
}

// repeated .mozc.commands.CandidateWord candidates = 2;
inline int CandidateList::candidates_size() const {
  return candidates_.size();
}
inline void CandidateList::clear_candidates() {
  candidates_.Clear();
}
inline ::mozc::commands::CandidateWord* CandidateList::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.CandidateList.candidates)
  return candidates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >*
CandidateList::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.CandidateList.candidates)
  return &candidates_;
}
inline const ::mozc::commands::CandidateWord& CandidateList::candidates(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateList.candidates)
  return candidates_.Get(index);
}
inline ::mozc::commands::CandidateWord* CandidateList::add_candidates() {
  // @@protoc_insertion_point(field_add:mozc.commands.CandidateList.candidates)
  return candidates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >&
CandidateList::candidates() const {
  // @@protoc_insertion_point(field_list:mozc.commands.CandidateList.candidates)
  return candidates_;
}

// optional .mozc.commands.Category category = 3 [default = CONVERSION];
inline bool CandidateList::has_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CandidateList::set_has_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CandidateList::clear_has_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CandidateList::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category CandidateList::category() const {
  // @@protoc_insertion_point(field_get:mozc.commands.CandidateList.category)
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void CandidateList::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.CandidateList.category)
}

// -------------------------------------------------------------------

// Candidates_Candidate

// required uint32 index = 4;
inline bool Candidates_Candidate::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Candidates_Candidate::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Candidates_Candidate::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Candidates_Candidate::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Candidates_Candidate::index() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.Candidate.index)
  return index_;
}
inline void Candidates_Candidate::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.Candidate.index)
}

// required string value = 5;
inline bool Candidates_Candidate::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates_Candidate::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates_Candidate::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates_Candidate::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Candidates_Candidate::value() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.Candidate.value)
  return value_.GetNoArena();
}
inline void Candidates_Candidate::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.Candidate.value)
}
#if LANG_CXX11
inline void Candidates_Candidate::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozc.commands.Candidates.Candidate.value)
}
#endif
inline void Candidates_Candidate::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozc.commands.Candidates.Candidate.value)
}
inline void Candidates_Candidate::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozc.commands.Candidates.Candidate.value)
}
inline ::std::string* Candidates_Candidate::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.Candidate.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Candidates_Candidate::release_value() {
  // @@protoc_insertion_point(field_release:mozc.commands.Candidates.Candidate.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Candidates_Candidate::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Candidates.Candidate.value)
}

// optional int32 id = 9;
inline bool Candidates_Candidate::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Candidates_Candidate::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Candidates_Candidate::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Candidates_Candidate::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Candidates_Candidate::id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.Candidate.id)
  return id_;
}
inline void Candidates_Candidate::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.Candidate.id)
}

// optional .mozc.commands.Annotation annotation = 7;
inline bool Candidates_Candidate::has_annotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidates_Candidate::set_has_annotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidates_Candidate::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidates_Candidate::clear_annotation() {
  if (annotation_ != NULL) annotation_->Clear();
  clear_has_annotation();
}
inline const ::mozc::commands::Annotation& Candidates_Candidate::_internal_annotation() const {
  return *annotation_;
}
inline const ::mozc::commands::Annotation& Candidates_Candidate::annotation() const {
  const ::mozc::commands::Annotation* p = annotation_;
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.Candidate.annotation)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Annotation*>(
      &::mozc::commands::_Annotation_default_instance_);
}
inline ::mozc::commands::Annotation* Candidates_Candidate::release_annotation() {
  // @@protoc_insertion_point(field_release:mozc.commands.Candidates.Candidate.annotation)
  clear_has_annotation();
  ::mozc::commands::Annotation* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline ::mozc::commands::Annotation* Candidates_Candidate::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Annotation>(GetArenaNoVirtual());
    annotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.Candidate.annotation)
  return annotation_;
}
inline void Candidates_Candidate::set_allocated_annotation(::mozc::commands::Annotation* annotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotation_;
  }
  if (annotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Candidates.Candidate.annotation)
}

// optional int32 information_id = 10;
inline bool Candidates_Candidate::has_information_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Candidates_Candidate::set_has_information_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Candidates_Candidate::clear_has_information_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Candidates_Candidate::clear_information_id() {
  information_id_ = 0;
  clear_has_information_id();
}
inline ::google::protobuf::int32 Candidates_Candidate::information_id() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.Candidate.information_id)
  return information_id_;
}
inline void Candidates_Candidate::set_information_id(::google::protobuf::int32 value) {
  set_has_information_id();
  information_id_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.Candidate.information_id)
}

// -------------------------------------------------------------------

// Candidates

// optional uint32 focused_index = 1;
inline bool Candidates::has_focused_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Candidates::set_has_focused_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Candidates::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Candidates::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 Candidates::focused_index() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.focused_index)
  return focused_index_;
}
inline void Candidates::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.focused_index)
}

// required uint32 size = 2;
inline bool Candidates::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Candidates::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Candidates::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Candidates::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 Candidates::size() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.size)
  return size_;
}
inline void Candidates::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.size)
}

// repeated group Candidate = 3 { ... };
inline int Candidates::candidate_size() const {
  return candidate_.size();
}
inline void Candidates::clear_candidate() {
  candidate_.Clear();
}
inline ::mozc::commands::Candidates_Candidate* Candidates::mutable_candidate(int index) {
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.candidate)
  return candidate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >*
Candidates::mutable_candidate() {
  // @@protoc_insertion_point(field_mutable_list:mozc.commands.Candidates.candidate)
  return &candidate_;
}
inline const ::mozc::commands::Candidates_Candidate& Candidates::candidate(int index) const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.candidate)
  return candidate_.Get(index);
}
inline ::mozc::commands::Candidates_Candidate* Candidates::add_candidate() {
  // @@protoc_insertion_point(field_add:mozc.commands.Candidates.candidate)
  return candidate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >&
Candidates::candidate() const {
  // @@protoc_insertion_point(field_list:mozc.commands.Candidates.candidate)
  return candidate_;
}

// required uint32 position = 6;
inline bool Candidates::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Candidates::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Candidates::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Candidates::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Candidates::position() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.position)
  return position_;
}
inline void Candidates::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.position)
}

// optional .mozc.commands.Candidates subcandidates = 8;
inline bool Candidates::has_subcandidates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates::set_has_subcandidates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates::clear_has_subcandidates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates::clear_subcandidates() {
  if (subcandidates_ != NULL) subcandidates_->Clear();
  clear_has_subcandidates();
}
inline const ::mozc::commands::Candidates& Candidates::_internal_subcandidates() const {
  return *subcandidates_;
}
inline const ::mozc::commands::Candidates& Candidates::subcandidates() const {
  const ::mozc::commands::Candidates* p = subcandidates_;
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.subcandidates)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Candidates*>(
      &::mozc::commands::_Candidates_default_instance_);
}
inline ::mozc::commands::Candidates* Candidates::release_subcandidates() {
  // @@protoc_insertion_point(field_release:mozc.commands.Candidates.subcandidates)
  clear_has_subcandidates();
  ::mozc::commands::Candidates* temp = subcandidates_;
  subcandidates_ = NULL;
  return temp;
}
inline ::mozc::commands::Candidates* Candidates::mutable_subcandidates() {
  set_has_subcandidates();
  if (subcandidates_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Candidates>(GetArenaNoVirtual());
    subcandidates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.subcandidates)
  return subcandidates_;
}
inline void Candidates::set_allocated_subcandidates(::mozc::commands::Candidates* subcandidates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete subcandidates_;
  }
  if (subcandidates) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      subcandidates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subcandidates, submessage_arena);
    }
    set_has_subcandidates();
  } else {
    clear_has_subcandidates();
  }
  subcandidates_ = subcandidates;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Candidates.subcandidates)
}

// optional .mozc.commands.InformationList usages = 10;
inline bool Candidates::has_usages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidates::set_has_usages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidates::clear_has_usages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidates::clear_usages() {
  if (usages_ != NULL) usages_->Clear();
  clear_has_usages();
}
inline const ::mozc::commands::InformationList& Candidates::_internal_usages() const {
  return *usages_;
}
inline const ::mozc::commands::InformationList& Candidates::usages() const {
  const ::mozc::commands::InformationList* p = usages_;
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.usages)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::InformationList*>(
      &::mozc::commands::_InformationList_default_instance_);
}
inline ::mozc::commands::InformationList* Candidates::release_usages() {
  // @@protoc_insertion_point(field_release:mozc.commands.Candidates.usages)
  clear_has_usages();
  ::mozc::commands::InformationList* temp = usages_;
  usages_ = NULL;
  return temp;
}
inline ::mozc::commands::InformationList* Candidates::mutable_usages() {
  set_has_usages();
  if (usages_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::InformationList>(GetArenaNoVirtual());
    usages_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.usages)
  return usages_;
}
inline void Candidates::set_allocated_usages(::mozc::commands::InformationList* usages) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete usages_;
  }
  if (usages) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      usages = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, usages, submessage_arena);
    }
    set_has_usages();
  } else {
    clear_has_usages();
  }
  usages_ = usages;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Candidates.usages)
}

// optional .mozc.commands.Category category = 11 [default = CONVERSION];
inline bool Candidates::has_category() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Candidates::set_has_category() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Candidates::clear_has_category() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Candidates::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category Candidates::category() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.category)
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void Candidates::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.category)
}

// optional .mozc.commands.DisplayType display_type = 12 [default = MAIN];
inline bool Candidates::has_display_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Candidates::set_has_display_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Candidates::clear_has_display_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Candidates::clear_display_type() {
  display_type_ = 0;
  clear_has_display_type();
}
inline ::mozc::commands::DisplayType Candidates::display_type() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.display_type)
  return static_cast< ::mozc::commands::DisplayType >(display_type_);
}
inline void Candidates::set_display_type(::mozc::commands::DisplayType value) {
  assert(::mozc::commands::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.display_type)
}

// optional .mozc.commands.Footer footer = 13;
inline bool Candidates::has_footer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Candidates::set_has_footer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Candidates::clear_has_footer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Candidates::clear_footer() {
  if (footer_ != NULL) footer_->Clear();
  clear_has_footer();
}
inline const ::mozc::commands::Footer& Candidates::_internal_footer() const {
  return *footer_;
}
inline const ::mozc::commands::Footer& Candidates::footer() const {
  const ::mozc::commands::Footer* p = footer_;
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.footer)
  return p != NULL ? *p : *reinterpret_cast<const ::mozc::commands::Footer*>(
      &::mozc::commands::_Footer_default_instance_);
}
inline ::mozc::commands::Footer* Candidates::release_footer() {
  // @@protoc_insertion_point(field_release:mozc.commands.Candidates.footer)
  clear_has_footer();
  ::mozc::commands::Footer* temp = footer_;
  footer_ = NULL;
  return temp;
}
inline ::mozc::commands::Footer* Candidates::mutable_footer() {
  set_has_footer();
  if (footer_ == NULL) {
    auto* p = CreateMaybeMessage<::mozc::commands::Footer>(GetArenaNoVirtual());
    footer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mozc.commands.Candidates.footer)
  return footer_;
}
inline void Candidates::set_allocated_footer(::mozc::commands::Footer* footer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete footer_;
  }
  if (footer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      footer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, footer, submessage_arena);
    }
    set_has_footer();
  } else {
    clear_has_footer();
  }
  footer_ = footer;
  // @@protoc_insertion_point(field_set_allocated:mozc.commands.Candidates.footer)
}

// optional .mozc.commands.Candidates.Direction direction = 14 [default = VERTICAL];
inline bool Candidates::has_direction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Candidates::set_has_direction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Candidates::clear_has_direction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Candidates::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::mozc::commands::Candidates_Direction Candidates::direction() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.direction)
  return static_cast< ::mozc::commands::Candidates_Direction >(direction_);
}
inline void Candidates::set_direction(::mozc::commands::Candidates_Direction value) {
  assert(::mozc::commands::Candidates_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.direction)
}

// optional uint32 page_size = 18 [default = 9];
inline bool Candidates::has_page_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Candidates::set_has_page_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Candidates::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Candidates::clear_page_size() {
  page_size_ = 9u;
  clear_has_page_size();
}
inline ::google::protobuf::uint32 Candidates::page_size() const {
  // @@protoc_insertion_point(field_get:mozc.commands.Candidates.page_size)
  return page_size_;
}
inline void Candidates::set_page_size(::google::protobuf::uint32 value) {
  set_has_page_size();
  page_size_ = value;
  // @@protoc_insertion_point(field_set:mozc.commands.Candidates.page_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace mozc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mozc::commands::Candidates_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Candidates_Direction>() {
  return ::mozc::commands::Candidates_Direction_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Category>() {
  return ::mozc::commands::Category_descriptor();
}
template <> struct is_proto_enum< ::mozc::commands::DisplayType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::DisplayType>() {
  return ::mozc::commands::DisplayType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2fcandidates_2eproto
